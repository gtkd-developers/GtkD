#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping Gtk
#####
###
#

# must start with wrap



addTypedefs: start
public import gtkc.cairotypes;
public import gtkc.glibtypes;
public import gtkc.gobjecttypes;
public import gtkc.giotypes;
public import gtkc.pangotypes;
public import gtkc.atktypes;
public import gtkc.gdkpixbuftypes;
public import gtkc.gdktypes;

version(LDC)
{
	version(D_Version2)
	{
		extern(C) Object _d_newclass(ClassInfo ci);
	}
	else
	{
		extern (C) void* _d_allocclass(ClassInfo ci);
	}
}
else
{
	extern(C) Object _d_newclass(ClassInfo ci);
}

alias void GtkAccelGroupEntry;
alias void GtkContainerClass;

public struct GtkStylePropertiesPrivate{}
public struct GtkCellRendererClassPrivate{}

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
	/** The GtkNotebookTab is not documented */
	public enum GtkNotebookTab
	{
		FIRST,
		LAST
	}
	alias GtkNotebookTab NotebookTab;
addEnums: end

addStructs: start

struct GtkWidgetClass
{
	GObjectClass parent_class;

	guint activate_signal;

	/* seldomly overidden */
	extern(C) void  function(GtkWidget *widget,uint nPspecs,GParamSpec **pspecs) dispatchChildPropertiesChanged;

	/* basics */
	extern(C) void function(GtkWidget* widget) destroy;
	extern(C) void function(GtkWidget* widget) show;
	extern(C) void function(GtkWidget* widget) show_all;
	extern(C) void function(GtkWidget* widget) hide;
	extern(C) void function(GtkWidget* widget) map;
	extern(C) void function(GtkWidget* widget) unmap;
	extern(C) void function(GtkWidget* widget) realize;
	extern(C) void function(GtkWidget* widget) unrealize;
	extern(C) void function(GtkWidget* widget, GtkAllocation* allocation) size_allocate;
	extern(C) void function(GtkWidget* widget, GtkStateType previous_state) state_changed;
	extern(C) void function(GtkWidget* widget, GtkStateFlags previous_state_flags) state_flags_changed;
	extern(C) void function(GtkWidget* widget, GtkWidget* previous_parent) parent_set;
	extern(C) void function(GtkWidget* widget, GtkWidget* previous_toplevel) hierarchy_changed;
	extern(C) void function(GtkWidget* widget, GtkStyle* previous_style) style_set;
	extern(C) void function(GtkWidget* widget, GtkTextDirection previous_direction) direction_changed;
	extern(C) void function(GtkWidget* widget, gboolean was_grabbed) grab_notify;
	extern(C) void function(GtkWidget* widget, GParamSpec* pspec) child_notify;
	extern(C) gboolean function(GtkWidget* widget, cairo_t* cr) draw;

	/* size requests */
	extern(C) GtkSizeRequestMode function(GtkWidget* widget) get_request_mode;

	extern(C) void function(GtkWidget* widget, gint* minimum_height, gint* natural_height) get_preferred_height;
	extern(C) void function(GtkWidget* widget, gint height, gint* minimum_width, gint            *natural_width) get_preferred_width_for_height;
	extern(C) void function(GtkWidget* widget, gint* minimum_width, gint* natural_width) get_preferred_width;
	extern(C) void function(GtkWidget* widget, gint width, gint* minimum_height,gint            *natural_height) get_preferred_height_for_width;

	/* Mnemonics */
	extern(C) gboolean function(GtkWidget* widget, gboolean group_cycling) mnemonic_activate;

	/* explicit focus */
	extern(C) void function(GtkWidget* widget) grab_focus;
	extern(C) gboolean function(GtkWidget* widget, GtkDirectionType direction) focus;

	/* keyboard navigation */
	extern(C) void function(GtkWidget* widget, GtkDirectionType direction) move_focus;
	extern(C) gboolean function(GtkWidget* widget, GtkDirectionType direction) keynav_failed;

	/* events */
	extern(C) gboolean function(GtkWidget* widget, GdkEvent* event) event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventButton* event) button_press_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventButton* event) button_release_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventScroll* event) scroll_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventMotion* event) motion_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventAny* event) delete_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventAny* event) destroy_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventKey* event) key_press_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventKey* event) key_release_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventCrossing* event) enter_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventCrossing* sevent) leave_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventConfigure* event) configure_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventFocus* event) focus_in_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventFocus* event) focus_out_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventAny* event) map_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventAny* event) unmap_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventProperty* event) property_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventSelection* event) selection_clear_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventSelection* event) selection_request_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventSelection* event) selection_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventProximity* event) proximity_in_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventProximity* event) proximity_out_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventVisibility* event) visibility_notify_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventWindowState* event) window_state_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventExpose* event) damage_event;
	extern(C) gboolean function(GtkWidget* widget, GdkEventGrabBroken* event) grab_broken_event;

	/* selection */
	extern(C) void function(GtkWidget* widget, GtkSelectionData* selection_data, guint info, guint time_) selection_get;
	extern(C) void function(GtkWidget* widget, GtkSelectionData* selection_data, guint time_) selection_received;

	/* Source side drag signals */
	extern(C) void function(GtkWidget* widget, GdkDragContext* context) drag_begin;
	extern(C) void function(GtkWidget* widget, GdkDragContext* context) drag_end;
	extern(C) void function(GtkWidget* widget, GdkDragContext* context, GtkSelectionData* selection_data, guint info, guint time_) drag_data_get;
	extern(C) void function(GtkWidget* widget, GdkDragContext* context) drag_data_delete;

	/* Target side drag signals */
	extern(C) void function(GtkWidget* widget, GdkDragContext* context, guint time_) drag_leave;
	extern(C) gboolean function(GtkWidget* widget, GdkDragContext* context, gint x, gint y, guint time_) drag_motion;
	extern(C) gboolean function(GtkWidget* widget, GdkDragContext* context, gint x, gint y, guint time_) drag_drop;
	extern(C) void function(GtkWidget* widget, GdkDragContext* context, gint x, gint y, GtkSelectionData* selection_data, guint info, guint time_) drag_data_received;
	extern(C) gboolean function(GtkWidget* widget, GdkDragContext* context, GtkDragResult result) drag_failed;

	/* Signals used only for keybindings */
	extern(C) gboolean function(GtkWidget* widget) popup_menu;

	/* If a widget has multiple tooltips/whatsthis, it should show the
	* one for the current focus location, or if that doesn't make
	* sense, should cycle through them showing each tip alongside
	* whatever piece of the widget it applies to.
	*/
	extern(C) gboolean function(GtkWidget* widget, GtkWidgetHelpType help_type) show_help;

	/* accessibility support */
	extern(C) AtkObject* function(GtkWidget* widget) get_accessible;

	extern(C) void function(GtkWidget* widget, GdkScreen* previous_screen) screen_changed;
	extern(C) gboolean function(GtkWidget* widget, guint signal_id) can_activate_accel;
	extern(C) void function(GtkWidget* widget) composited_changed;
	extern(C) gboolean function(GtkWidget* widget, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip* tooltip) query_tooltip;
	extern(C) void function(GtkWidget* widget, gboolean* hexpand_p, gboolean* vexpand_p) compute_expand;
	extern(C) void function(GtkWidget* widget, GtkOrientation orientation, gint* minimum_size, gint* natural_size) adjust_size_request;
	extern(C) void function(GtkWidget* widget, GtkOrientation orientation, gint* minimum_size, gint* natural_size, gint* allocated_pos, gint* allocated_size) adjust_size_allocation;
	extern(C) void function(GtkWidget* widget) style_updated;

	/*< private >*/
	/* Padding for future expansion */
	extern(C) void function() _gtk_reserved1;
	extern(C) void function() _gtk_reserved2;
	extern(C) void function() _gtk_reserved3;
	extern(C) void function() _gtk_reserved4;
	extern(C) void function() _gtk_reserved5;
	extern(C) void function() _gtk_reserved6;
	extern(C) void function() _gtk_reserved7;
	extern(C) void function() _gtk_reserved8;
};

struct GtkTextIter
{
	/* GtkTextIter is an opaque datatype; ignore all these fields.
	* Initialize the iter with gtk_text_buffer_get_iter_*
	* functions
	*/
	/*< private >*/
	gpointer dummy1;
	gpointer dummy2;
	gint dummy3;
	gint dummy4;
	gint dummy5;
	gint dummy6;
	gint dummy7;
	gint dummy8;
	gpointer dummy9;
	gpointer dummy10;
	gint dummy11;
	gint dummy12;
	/* padding */
	gint dummy13;
	gpointer dummy14;
}

struct GtkTreeIter
{
	gint stamp;
	gpointer userData;
	gpointer userData2;
	gpointer userData3;
}

struct GtkRequisition
{
	gint width;
	gint height;
}

/**
 * A GtkTargetList structure is a reference counted list
 * of GtkTargetPair. It is used to represent the same
 * information as a table of GtkTargetEntry, but in
 * an efficient form. This structure should be treated as
 * opaque.
 */
public struct GtkTargetList
{
		GList *list;
		uint refCount;
}

public struct GtkTargetPair
{
	GdkAtom target;
	uint flags;
	uint info;
}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end


wrap: gtk

###########################################################
### Core Reference ########################################
###########################################################


file: gtk3-General.html
class: Main
prefix: gtk_main_
prefix: gtk_
noprefix: gtk_true
noprefix: gtk_false
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.OptionGroup
import: gdk.Device
import: gdk.Event
import: gdk.Threads
import: gthread.Thread
import: gtk.Widget
import:  pango.PgLanguage
structWrap: GOptionGroup* OptionGroup
structWrap: GdkDevice* Device
structWrap: GdkEvent* Event
structWrap: GtkWidget* Widget
structWrap: PangoLanguage* PgLanguage

inout: gtk_parse_args argv
array: gtk_parse_args argv argc
inout: gtk_init argv
array: gtk_init argv argc
inout: gtk_init_check argv
array: gtk_init_check argv argc
inout: gtk_init_with_args argv
array: gtk_init_with_args argv argc
array: gtk_init_with_args entries
out: gtk_get_current_event_state state

alias: main run

code: start
	/**
	 * This initiates GtkD to supports multi threaded programs.
	 * read full documantation at http://gtk.org/faq/#AEN482
	 * from the FAQ:
	 * "There is a single global lock that you must acquire with 
	 * gdk_threads_enter() before making any GDK calls, 
	 * and release with gdk_threads_leave() afterwards throughout your code."
	 * This is to be used on any call to GDK not executed from the main thread.
	 */
	public static void initMultiThread(string[] args)
	{
		threadsInit();
		init(args);
	}
code: end
outFile: Main

file: gtk3-Feature-Test-Macros.html
class: Version
prefix: gtk_
import: glib.Str
outFile: Version

file: gtk3-Keyboard-Accelerators.html
struct:  GtkAccelGroup
class: AccelGroup
prefix: gtk_accel_group_
prefix: gtk_
import: glib.Str
import: gobject.Closure
import: gobject.ObjectG
import: gdk.Display
import: glib.ListSG
structWrap: GClosure* Closure
structWrap: GObject* ObjectG
structWrap: GSList* ListSG
structWrap: GdkDisplay* Display
structWrap: GtkAccelGroup* AccelGroup

array: gtk_accel_group_query Return n_entries
out: gtk_accelerator_parse accelerator_key
out: gtk_accelerator_parse accelerator_mods
out: gtk_accelerator_parse_with_keycode accelerator_key
out: gtk_accelerator_parse_with_keycode accelerator_codes
out: gtk_accelerator_parse_with_keycode accelerator_mods

outFile: AccelGroup

file: gtk3-Accelerator-Maps.html
struct:  GtkAccelMap
class: AccelMap
prefix: gtk_accel_map_
import: glib.Str
import: glib.ScannerG
structWrap: GScanner* ScannerG
structWrap: GtkAccelMap* AccelMap
out: gtk_accel_map_lookup_entry key
outFile: AccelMap

file: gtk3-Clipboards.html
struct: GtkClipboard
class: Clipboard
prefix: gtk_clipboard_
import: glib.Str
import: gobject.ObjectG
import: gdk.Display
import: gdk.Pixbuf
import: gtk.TextBuffer
structWrap: GObject* ObjectG
structWrap: GdkDisplay* Display
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkClipboard* Clipboard
structWrap: GtkTextBuffer* TextBuffer

array: gtk_clipboard_set_with_data targets n_targets
array: gtk_clipboard_set_with_owner targets n_targets
array: gtk_clipboard_set_text text len
out: gtk_clipboard_wait_for_rich_text format
array: gtk_clipboard_wait_for_rich_text Return length
out: gtk_clipboard_wait_for_targets targets
array: gtk_clipboard_wait_for_targets targets n_targets
array: gtk_clipboard_set_can_store targets n_targets

outFile: Clipboard

file: gtk3-Drag-and-Drop.html
struct: GdkDragContext
class: DragAndDrop
prefix: gtk_drag_
prefix: gtk_
import: glib.Str
import: cairo.Surface
import: gdk.DragContext
import: gdk.Event
import: gdk.Pixbuf
import: gdk.Window
import: gio.IconIF
import: gtk.TargetList
import: gtk.Widget
structWrap: cairo_surface_t* Surface
structWrap: GdkDragContext* DragContext
structWrap: GdkEvent* Event
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkWindow* Window
structWrap: GIcon* IconIF
structWrap: GtkWidget* Widget
structWrap: GtkTargetList* TargetList

array: gtk_drag_dest_set targets n_targets
array: gtk_drag_source_set targets n_targets
outFile: DragAndDrop

file: gtk3-Stock-Items.html
struct: GtkStockItem
class: StockItem
prefix: gtk_stock_item_
prefix: gtk_stock_
import: glib.Str
import: gtkc.paths
import: gtkc.Loader
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkStockItem* StockItem

array: gtk_stock_add items n_items
array: gtk_stock_add_static items n_items
code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkStockItem !is null )
		{
			gtk_stock_item_free(gtkStockItem);
		}
	}
code: end
outFile: StockItem

file: GtkSettings.html
struct: GtkSettings
class: Settings
implements: StyleProviderIF
prefix: gtk_settings_
prefix: gtk_
import: glib.Str
import: gobject.ParamSpec
import: gobject.Value
import: glib.StringG
import: gdk.Screen
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GString* StringG
structWrap: GdkScreen* Screen
structWrap: GtkSettings* Settings

# imports for StyleProvider Interface
import: gtk.StyleProviderT
import: gtk.StyleProviderIF

out: gtk_settings_set_property_value svalue

code: start
	// add the StyleProvider capabilities
	mixin StyleProviderT!(GtkSettings);
code: end
outFile: Settings

file: gtk3-Bindings.html
struct: GtkBindingSet
class: BindingSet
prefix: gtk_binding_set_
prefix: gtk_binding_
prefix: gtk_bindings_
import: glib.Str
import: glib.ListSG
import: gobject.ObjectG
structWrap: GSList* ListSG
structWrap: GObject* ObjectG
structWrap: GtkBindingSet* BindingSet
openFile: BindingSet

file: gtk3-Standard-Enumerations.html
closeFile: BindingSet

file: gtk3-Selections.html
struct: GtkTargetEntry
nostruct: GtkTargetList
class: TargetEntry
prefix: gtk_target_entry_
prefix: gtk_
noprefix: gtk_target_table_
noprefix: gtk_targets_
noprefix: gtk_target_list_
noprefix: gtk_selection_
import: glib.Str
import: gtkc.paths
import: gtkc.Loader
structWrap: GtkTargetEntry* TargetEntry

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkTargetEntry !is null )
		{
			gtk_target_entry_free(gtkTargetEntry);
		}
	}
code: end
outFile: TargetEntry

struct: GtkTargetList
class: TargetList
extend: GBoxed
prefix: gtk_target_list_
prefix: gtk_targets_
prefix: gtk_target_
noprefix: gtk_target_entry_
strictPrefix: Y
import: gtk.TextBuffer
import: gtk.TargetEntry
import: gtkc.Loader
import: gtkc.paths
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTargetEntry* TargetEntry
structWrap: GtkTargetList* TargetList

array: gtk_target_list_new targets ntargets
array: gtk_target_list_add_table targets ntargets
out: gtk_target_list_find info
array: gtk_target_table_free targets n_targets
array: gtk_target_table_new_from_list Return n_targets
array: gtk_targets_include_image targets n_targets
array: gtk_targets_include_text targets n_targets
array: gtk_targets_include_uri targets n_targets
array: gtk_targets_include_rich_text targets n_targets

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkTargetList !is null )
		{
			gtk_target_list_unref(gtkTargetList);
		}
	}
code: end
outFile: TargetList

struct: GtkSelectionData
class: SelectionData
prefix: gtk_selection_
strictPrefix: Y
import: glib.Str
import: gdk.Display
import: gdk.Pixbuf
import: gtk.TextBuffer
import: gtk.Widget
import: gtkc.Loader
import: gtkc.paths
structWrap: GdkDisplay* Display
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkSelectionData* SelectionData
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkWidget* Widget

array: gtk_selection_add_targets targets ntargets
array: gtk_selection_data_set data length
array: gtk_selection_data_set_text str len
array: gtk_selection_data_set_uris uris
out: gtk_selection_data_get_targets targets
array: gtk_selection_data_get_targets targets n_atoms
array: gtk_selection_data_get_data_with_length Return length

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkSelectionData !is null )
		{
			gtk_selection_data_free(gtkSelectionData);
		}
	}
code: end
outFile: SelectionData


file: gtk3-Testing.html
class: Testing
prefix: gtk_test_
import: glib.Str
import: gtk.SpinButton
import: gtk.Widget
structWrap: GtkSpinButton* SpinButton
structWrap: GtkWidget* Widget

array: gtk_test_list_all_types Return n_types

code: start
	/**
	 * This function is used to initialize a GTK+ test program.
	 * It will in turn call g_test_init() and gtk_init() to
	 * properly initialize the testing framework and graphical toolkit.
	 * It'll also set the program's locale to "C" and prevent loading of
	 * rc files and Gtk+ modules. This is done to make tets program environments as deterministic as possible.
	 * Like gtk_init() and g_test_init(), any known arguments will be processed and stripped from argc and argv.
	 * Params:
	 *  argvp = Address of the argv parameter of main(). Any parameters understood by g_test_init() or gtk_init() are stripped before return. 
	 */
	public static void testInit(ref string[] argv)
	{
		// void gtk_test_init(int *argcp, char ***argvp, ...);
		char** outargv = Str.toStringzArray(argv);
		int argc = cast(int) argv.length;
		
		gtk_test_init(&argc, &outargv, null);
		
		argv = Str.toStringArray(outargv);
	}
code: end
outFile: Testing

file: gtk3-Filesystem-utilities.html
struct: GtkMountOperation
ctorStruct: GMountOperation
class: MountOperation
extend: GioMountOperation
prefix: gtk_mount_operation_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.MountOperation : GioMountOperation = MountOperation
import: gdk.Screen
import: gtk.Window
structWrap: GdkScreen* Screen
structWrap: GtkWindow* Window
outFile: MountOperation

###########################################################
### Theming in GTK+ #######################################
###########################################################

file: GtkStyleContext.html
struct: GtkStyleContext
class: StyleContext
prefix: gtk_style_context_
prefix: gtk_
noprefix: gtk_border_
import: std.stdarg
import: glib.Str
import: cairo.Context
import: gobject.Value
import: glib.ListG
import: gdk.FrameClock
import: gdk.Pixbuf
import: gdk.RGBA
import: gdk.Screen
import: gdk.Window
import: gtk.CssSection
import: gtk.IconSet
import: gtk.IconSource
import: gtk.StyleProviderIF
import: gtk.WidgetPath
import: pango.PgFontDescription
import: pango.PgLayout
structWrap: cairo_t* Context
structWrap: GValue* Value
structWrap: GList* ListG
structWrap: GdkFrameClock* FrameClock
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkRGBA* RGBA
structWrap: GdkScreen* Screen
structWrap: GdkWindow* Window
structWrap: GtkCssSection* CssSection
structWrap: GtkIconSet* IconSet
structWrap: GtkIconSource* IconSource
structWrap: GtkStyleContext* StyleContext
structWrap: GtkStyleProvider* StyleProviderIF
structWrap: GtkWidgetPath* WidgetPath
structWrap: PangoFontDescription* PgFontDescription
structWrap: PangoLayout* PgLayout

out: gtk_style_context_get_border border
out: gtk_style_context_get_padding padding
out: gtk_style_context_get_margin margin
out: gtk_style_context_state_is_running progress

outFile: StyleContext

struct: GtkBorder
class: Border
extend: GBoxed
prefix: gtk_border_
strictPrefix: Y
import: gtkc.paths
import: gtkc.Loader
structWrap: GtkBorder* Border

code: start
	~this ()
	{
		if ( Linker.isLoaded(LIBRARY.GTK) && gtkBorder !is null )
		{
			gtk_border_free(gtkBorder);
		}
	}
code: end
outFile: Border

file: GtkCssProvider.html
struct: GtkCssProvider
class: CssProvider
implements: StyleProviderIF
prefix: gtk_css_provider_
noprefix: gtk_css_section_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.File
import: gtk.CssSection
structWrap: GError* ErrorG
structWrap: GFile* File
structWrap: GtkCssSection* CssSection
structWrap: GtkCssProvider* CssProvider
array: gtk_css_provider_load_from_data data length

override: toString

# imports for StyleProvider Interface
import: gtk.StyleProviderT
import: gtk.StyleProviderIF

code: start
	// add the StyleProvider capabilities
	mixin StyleProviderT!(GtkCssProvider);
code: end
outFile: CssProvider

struct: GtkCssSection
class: CssSection
extend: GBoxed
prefix: gtk_css_section_
strictPrefix: Y
import: gtkc.paths
import: gtkc.Loader
import: gio.File
structWrap: GFile* File
structWrap: GtkCssSection* CssSection

nosignal: parsing-error

code: start
	~this ()
	{
		if ( Linker.isLoaded(LIBRARY.GTK) && gtkCssSection !is null )
		{
			gtk_css_section_unref(gtkCssSection);
		}
	}
code: end
outFile: CssSection

file: GtkStyleProvider.html
struct: GtkStyleProvider
class: StyleProviderT
template: TStruct
prefix: gtk_style_provider_
import: gobject.ParamSpec
import: gobject.Value
import: gtk.IconFactory
import: gtk.StyleProperties
import: gtk.WidgetPath
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GtkIconFactory* IconFactory
structWrap: GtkStyleProperties* StyleProperties
structWrap: GtkWidgetPath* WidgetPath
interface: StyleProviderIF
outFile: StyleProviderT

file: gtk3-GtkStyleProperties.html
struct: GtkStyleProperties
class: StyleProperties
extend: GObject
prefix: gtk_style_properties_
import: std.stdarg
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ParamSpec
import: gobject.Value
import: gtk.SymbolicColor
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GtkSymbolicColor* SymbolicColor
structWrap: GtkStyleProperties* StyleProperties
out: gtk_style_properties_lookup_property parse_func
out: gtk_style_properties_lookup_property pspec

alias: setProperty setStyleProperty
alias: setValist setStyleValist
alias: getProperty getStyleProperty
alias: getValist getStyleValist
outFile: StyleProperties

file: GtkThemingEngine.html
struct: GtkThemingEngine
class: ThemingEngine
prefix: gtk_theming_engine_
import: std.stdarg
import: glib.Str
import: gobject.ParamSpec
import: gobject.Value
import: gdk.RGBA
import: gdk.Screen
import: gtk.WidgetPath
import: pango.PgFontDescription
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GdkRGBA* RGBA
structWrap: GdkScreen* Screen
structWrap: GtkThemingEngine* ThemingEngine
structWrap: GtkWidgetPath* WidgetPath
structWrap: PangoFontDescription* PgFontDescription

out: gtk_theming_engine_get_border border
out: gtk_theming_engine_get_padding padding
out: gtk_theming_engine_get_margin margin
out: gtk_theming_engine_has_region flags
out: gtk_theming_engine_state_is_running progress
outFile: ThemingEngine

file: gtk3-GtkWidgetPath.html
struct: GtkWidgetPath
class: WidgetPath
prefix: gtk_widget_path_
import: glib.Str
import: glib.ListSG
import: gtk.Widget
import: gtkc.Loader
import: gtkc.paths
structWrap: GSList* ListSG
structWrap: GtkWidget* Widget
structWrap: GtkWidgetPath* WidgetPath

override: toString

out: gtk_widget_path_iter_has_qregion flags
out: gtk_widget_path_iter_has_region flags

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkWidgetPath !is null )
		{
			gtk_widget_path_free(gtkWidgetPath);
		}
	}
code: end
outFile: WidgetPath

file: gtk3-GtkSymbolicColor.html
struct: GtkSymbolicColor
class: SymbolicColor
prefix: gtk_symbolic_color_
import: glib.Str
import: gdk.RGBA
import: gtk.StyleProperties
import: gtkc.Loader
import: gtkc.paths
structWrap: GdkRGBA* RGBA
structWrap: GtkStyleProperties* StyleProperties
structWrap: GtkSymbolicColor* SymbolicColor

override: toString

nocode: gtk_symbolic_color_new_shade
nocode: gtk_symbolic_color_new_alpha

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkSymbolicColor !is null )
		{
			gtk_symbolic_color_unref(gtkSymbolicColor);
		}
	}

	/**
	 * Creates a symbolic color defined as a shade of another color.
	 * A factor > 1.0 would resolve to a brighter or more transparent color,
	 * while < 1.0 would resolve to a darker or more opaque color.
	 * 
	 * Params:
	 *     color    = another GtkSymbolicColor.
	 *     factor   = shading factor to apply to color.
	 *     useAlpha = if true change the relative alpha value of the color,
	 *                otherwise change the shade.
	 * 
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (SymbolicColor color, double factor, bool useAlpha = true)
	{
		GtkSymbolicColor* p;

		if ( useAlpha )
		{
			p = gtk_symbolic_color_new_alpha((color is null) ? null : color.getSymbolicColorStruct(), factor);
		}
		else
		{
			p = gtk_symbolic_color_new_shade((color is null) ? null : color.getSymbolicColorStruct(), factor);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_symbolic_color_new_shade((color is null) ? null : color.getSymbolicColorStruct(), factor)");
		}

		this(cast(GtkSymbolicColor*) p);
	}
code: end
outFile: SymbolicColor

file: gtk3-GtkGradient.html
struct: GtkGradient
class: Gradient
prefix: gtk_gradient_
import: glib.Str
import: cairo.Pattern
import: gtk.StyleContext
import: gtk.StyleProperties
import: gtk.SymbolicColor
import: gtkc.paths
import: gtkc.Loader
structWrap: cairo_pattern_t* Pattern
structWrap: GtkGradient* Gradient
structWrap: GtkStyleContext* StyleContext
structWrap: GtkStyleProperties* StyleProperties
structWrap: GtkSymbolicColor* SymbolicColor

override: toString

out: gtk_gradient_resolve resolved_gradient

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkGradient !is null )
		{
			gtk_gradient_unref(gtkGradient);
		}
	}
code: end
outFile: Gradient

file: GtkIconTheme.html
struct: GtkIconTheme
class: IconTheme
prefix: gtk_icon_theme_
noprefix: gtk_icon_info_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.IconIF
import: gdk.Pixbuf
import: gdk.RGBA
import: gdk.Screen
import: gtk.IconInfo
import: gtk.StyleContext
structWrap: GList* ListG
structWrap: GIcon* IconIF
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkRGBA* RGBA
structWrap: GdkScreen* Screen
structWrap: GtkIconInfo* IconInfo
structWrap: GtkIconTheme* IconTheme
structWrap: GtkStyleContext* StyleContext

array: gtk_icon_theme_set_search_path path n_elements
out: gtk_icon_theme_get_search_path path
array: gtk_icon_theme_get_search_path path n_elements
array: gtk_icon_theme_choose_icon icon_names
outFile: IconTheme

struct: GtkIconInfo
class: IconInfo
prefix: gtk_icon_info_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gdk.Pixbuf
import: gdk.RGBA
import: gtk.IconTheme
import: gtk.Style
import: gtk.StyleContext
import: gtkc.paths
import: gtkc.Loader
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkRGBA* RGBA
structWrap: GtkIconInfo* IconInfo
structWrap: GtkIconTheme* IconTheme
structWrap: GtkStyle* Style
structWrap: GtkStyleContext* StyleContext

out: gtk_icon_info_load_symbolic was_symbolic
out: gtk_icon_info_load_symbolic_for_style was_symbolic
out: gtk_icon_info_get_embedded_rect rectangle
out: gtk_icon_info_get_attach_points points
array: gtk_icon_info_get_attach_points points n_points
out: gtk_icon_info_load_symbolic_finish was_symbolic
out: gtk_icon_info_load_symbolic_for_context_finish was_symbolic

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkIconInfo !is null )
		{
			gtk_icon_info_free(gtkIconInfo);
		}
	}
code: end
outFile: IconInfo

file: gtk3-Themeable-Stock-Images.html
struct: GtkIconSource
class: IconSource
prefix: gtk_icon_source_
noprefix: gtk_icon_factory_
noprefix: gtk_icon_set_
noprefix: gtk_icon_size_
import: glib.Str
import: gdk.Pixbuf
import: gtkc.paths
import: gtkc.Loader
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkIconSource* IconSource

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkIconSource !is null )
		{
			gtk_icon_source_free(gtkIconSource);
		}
	}
code: end
outFile: IconSource

struct: GtkIconFactory
class: IconFactory
implements: BuildableIF
prefix: gtk_icon_factory_
strictPrefix: Y
import: glib.Str
import: gtk.IconSet
structWrap: GtkIconSet* IconSet

# imports for Icon Interface
import: gtk.BuildableT
import: gtk.BuildableIF

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkIconFactory);
code: end
outFile: IconFactory

struct: GtkIconSet
class: IconSet
extend: GBoxed
prefix: gtk_icon_set_
strictPrefix: Y
import: glib.Str
import: gdk.Pixbuf
import: gtk.IconSource
import: gtk.Style
import: gtk.StyleContext
import: gtk.Widget
import: gtkc.paths
import: gtkc.Loader
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkIconSet* IconSet
structWrap: GtkIconSource* IconSource
structWrap: GtkStyle* Style
structWrap: GtkStyleContext* StyleContext
structWrap: GtkWidget* Widget

out: gtk_icon_set_get_sizes sizes
array: gtk_icon_set_get_sizes sizes n_sizes

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkIconSet !is null )
		{
			gtk_icon_set_unref(gtkIconSet);
		}
	}
code: end
outFile: IconSet

class: IconSize
prefix: gtk_icon_size_
strictPrefix: Y
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings

out: gtk_icon_size_lookup width
out: gtk_icon_size_lookup height
out: gtk_icon_size_lookup_for_settings width
out: gtk_icon_size_lookup_for_settings height
outFile: IconSize

file: GtkNumerableIcon.html
struct: GtkNumerableIcon
class: NumerableIcon
extend: GioEmblemedIcon
prefix: gtk_numerable_icon_
import: glib.Str
import: gio.EmblemedIcon : GioEmblemedIcon = EmblemedIcon
import: gio.Icon
import: gio.IconIF
import: gtk.StyleContext
structWrap: GIcon* IconIF
structWrap: GtkStyleContext* StyleContext
outFile: NumerableIcon

file: gtk3-Resource-Files.html
struct: GtkRcStyle
class: RcStyle
prefix: gtk_rc_
import: glib.Str
import: glib.ScannerG
import: gdk.Color
import: gtk.Settings
import: gtk.Style
import: gtk.Widget
structWrap: GScanner* ScannerG
structWrap: GdkColor* Color
structWrap: GtkRcStyle* RcStyle
structWrap: GtkSettings* Settings
structWrap: GtkStyle* Style
structWrap: GtkWidget* Widget

array: gtk_rc_set_default_files filenames
out: gtk_rc_parse_state state
out: gtk_rc_parse_priority priority

code: start
	deprecated:
code: end
outFile: RcStyle

file: GtkStyle.html
struct: GtkStyle
class: Style
prefix: gtk_style_
prefix: gtk_
import: std.stdarg
import: glib.Str
import: cairo.Context
import: gobject.Value
import: gdk.Color
import: gdk.Pixbuf
import: gdk.Window
import: gtk.IconSet
import: gtk.IconSource
import: gtk.Widget
import: pango.PgLayout
structWrap: cairo_t* Context
structWrap: GValue* Value
structWrap: GdkColor* Color
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkWindow* Window
structWrap: GtkIconSet* IconSet
structWrap: GtkIconSource* IconSource
structWrap: GtkStyle* Style
structWrap: GtkWidget* Widget
structWrap: PangoLayout* PgLayout

array: gtk_draw_polygon points npoints
array: gtk_paint_polygon points npoints
inout: gtk_draw_insertion_cursor location

code: start
	deprecated:
code: end
outFile: Style

###########################################################
### Windows ###############################################
###########################################################

file: GtkDialog.html
struct: GtkDialog
class: Dialog
prefix: gtk_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Screen
import: gtk.Button
import: gtk.Widget
import: gtk.Window
import: gtk.HButtonBox
import: gtk.VBox
structWrap: GdkScreen* Screen
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window

alias: setAlternativeButtonOrderFromArray setAlternativeButtonOrder
array: gtk_dialog_set_alternative_button_order_from_array new_order n_params

# Make these return the correct class.
nocode: gtk_dialog_get_action_area
nocode: gtk_dialog_get_content_area

code: start
	/**
	 * Both title and parent can be null.
	 */
	this(string title, Window parent, GtkDialogFlags flags, string[] buttonsText, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(buttonsText[0]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(buttonsText[1 .. $], responses[1 .. $]);
	}
	
	/** ditto */
	this(string title, Window parent, GtkDialogFlags flags, StockID[] stockIDs, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(StockDesc[stockIDs[0]]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(stockIDs[1 .. $], responses[1 .. $]);
	}

	/** */
	public Button addButton(StockID stockID, int responseId)
	{
		auto p = gtk_dialog_add_button(gtkDialog, Str.toStringz(StockDesc[stockID]), responseId);

		if ( p is null )
		{
			return null;
		}

		return new Button(cast(GtkButton*)p);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	//Return the corect class instead of Widget
	/**
	 * Returns the action area of dialog.
	 * Since 2.14
	 * Returns: the action area.
	 */
	public HButtonBox getActionArea()
	{
		// GtkWidget* gtk_dialog_get_action_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_action_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new HButtonBox(cast(GtkHButtonBox*) p);
	}
	
	//Return the corect class instead of Widget
	/**
	 * Returns the content area of dialog.
	 * Since 2.14
	 * Returns: the content area GtkVBox.
	 */
	public VBox getContentArea()
	{
		// GtkWidget* gtk_dialog_get_content_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_content_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new VBox(cast(GtkVBox*) p);
	}
code: end
outFile: Dialog

file: GtkInvisible.html
struct: GtkInvisible
class: Invisible
prefix: gtk_invisible_
prefix: gtk_
import: gdk.Screen
structWrap: GdkScreen* Screen
override: getScreen
outFile: Invisible

file: GtkMessageDialog.html
struct: GtkMessageDialog
class: MessageDialog
prefix: gtk_message_dialog_
import: glib.Str
import: gtk.VBox
import: gtk.Widget
import: gtk.Window
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window

nocode: gtk_message_dialog_new
nocode: gtk_message_dialog_new_with_markup
nocode: gtk_message_dialog_get_message_area

code: start
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text the
	 * user may want to see. When the user clicks a button a "response"
	 * signal is emitted with response IDs from GtkResponseType. See
	 * GtkDialog for more details.
	 * Params:
	 *    	parent = transient parent, or NULL for none
	 *    	flags = flags
	 *    	type = type of message
	 *    	buttons= set of buttons to use
	 *    	messageFormat = printf()-style format string, or NULL
	 *    	message = the message - should be null, any formatting should be done prior to call this constructor
	 *  arguments for message_format
	 * Returns:
	 *  a new GtkMessageDialog
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, string messageFormat, string message=null )
	{
		this(parent, flags, type, buttons, false, messageFormat, message );
	}
	
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text which
	 * is marked up with the Pango text markup language.
	 * When the user clicks a button a "response" signal is emitted with
	 * response IDs from GtkResponseType. See GtkDialog for more details.
	 * 
	 * If Markup is true special XML characters in the printf() arguments passed to this
	 * function will automatically be escaped as necessary.
	 * (See g_markup_printf_escaped() for how this is implemented.)
	 * Usually this is what you want, but if you have an existing
	 * Pango markup string that you want to use literally as the
	 * label, then you need to use gtk_message_dialog_set_markup()
	 * instead, since you can't pass the markup string either
	 * as the format (it might contain '%' characters) or as a string
	 * argument.
	 * Since 2.4
	 * Examples:
	 * --------------------
	 *  GtkWidget *dialog;
	 *  dialog = gtk_message_dialog_new (main_application_window,
	 *  GTK_DIALOG_DESTROY_WITH_PARENT,
	 *  GTK_MESSAGE_ERROR,
	 *  GTK_BUTTONS_CLOSE,
	 *  NULL);
	 *  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog),
	 *  markup);
	 * --------------------
	 * Params:
	 *  parent = transient parent, or NULL for none
	 *  flags = flags
	 *  type = type of message
	 *  buttons = set of buttons to use
	 *  messageFormat = printf()-style format string, or NULL
	 *  message = the message - should be null, any formatting should be done prior to call this constructor
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, bool markup, string messageFormat, string message=null )
	{
		GtkMessageDialog* p;

		if ( markup )
		{
			// GtkWidget* gtk_message_dialog_new_with_markup  (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new_with_markup(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}
		else
		{
			// GtkWidget* gtk_message_dialog_new (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new()");
		}

		this(p);
	}

	/**
	 * Since 2.22
	 * Returns: A GtkVBox corresponding to the "message area" in the message_dialog. This is the box where the dialog's primary and secondary labels are packed. You can add your own extra content to that box and it will appear below those labels, on the right side of the dialog's image (or on the left for right-to-left languages). See gtk_dialog_get_content_area() for the corresponding function in the parent GtkDialog.
	 */
	public VBox getMessageArea()
	{
		// GtkWidget * gtk_message_dialog_get_message_area (GtkMessageDialog *message_dialog);
		auto p = gtk_message_dialog_get_message_area(gtkMessageDialog);
		if(p is null)
		{
			return null;
		}
		return new VBox(cast(GtkVBox*) p);
	}
code: end
outFile: MessageDialog

file: 
class: PopupBox
import: gtk.MessageDialog;
import: gtk.Window;

code: start
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(string message, string title)
	{
		information(null, message, title);
	}
	
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.INFO,
										ButtonsType.OK ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-info",GtkResponseType.GTK_RESPONSE_OK);
		d.run();
		d.destroy();
	}
	
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(string message, string title)
	{
		error(null, message, title);
	}
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.ERROR,
										ButtonsType.CANCEL ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-error",ResponseType.GTK_RESPONSE_CANCEL);
		d.run();
		d.destroy();
	}
	
	
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(string message, string title)
	{
		return yesNo(null, message, title);
	}
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.NO);
		d.addButton("gtk-yes",ResponseType.YES);
		int responce = d.run();
		d.destroy();
		return responce == ResponseType.YES;
	}

	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(string message, string title)
	{
		return yesNoCancel(null, message, title);
	}
	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.NO);
		d.addButton("gtk-yes",ResponseType.YES);
		d.addButton("gtk-cancel",ResponseType.CANCEL);
		ResponseType responce = cast(ResponseType)d.run();
		d.destroy();
		return responce;
	}
code: end
outFile: PopupBox

file: GtkWindow.html
struct: GtkWindow
class: Window
prefix: gtk_window_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gdk.Pixbuf
import: gdk.Screen
import: gtk.AccelGroup
import: gtk.Application
import: gtk.Widget
import: gtk.WindowGroup
structWrap: GList* ListG
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkScreen* Screen
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkApplication* Application
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window
structWrap: GtkWindowGroup* WindowGroup

override: getScreen
override: setOpacity
override: getOpacity

inout: gtk_window_set_geometry_hints geometry
out: gtk_window_get_default_size width
out: gtk_window_get_default_size height
out: gtk_window_get_position root_x
out: gtk_window_get_position root_y
out: gtk_window_get_size width
out: gtk_window_get_size height
out: gtk_window_get_resize_grip_area rect

code: start
	/**
	 * Creates a top level window with a title
	 * Params:
	 * 		title = The Window title
	 */
	public this(string title)
	{
		this(GtkWindowType.TOPLEVEL);
		setTitle(title);
	}

	/**
	 * Move the window to an absolute position.
	 * just calls move(int, int).
	 * convinience because GdkEvent structs return the position coords as doubles
	 */
	public void move(double x, double y)
	{
		move(cast(int)x, cast(int)y);
	}
code: end
outFile: Window

file: 
import: gtk.Widget
import: gtk.Window
import: gtk.Main
import: gdk.Event

code: start

/**
 * A top Level window that will stop the main event cycle when it's closed.
 * Closing the last of the windows of class "MainWindow" will end the application.
 */
public class MainWindow : Window
{

	private static int countTotalMainWindows = 0;

	/**
	 * Creates a new MainWindow with a title
	 */
	public this(string title)
	{
		super(title);
		countTotalMainWindows++;
		//printf("MainWindows.this count = %d\n", countTotalMainWindows);
		addOnDelete(&windowDelete);
	}
	
	/**
	 * Executed when the user tries to close the window
	 * Returns: true to refuse to close the window
	 */
	protected bool windowDelete(Event event, Widget widget)
	{
		--countTotalMainWindows;
		//printf("MainWindows.windowDelete count = %d\n", countTotalMainWindows);
		if ( exit(0, false) || countTotalMainWindows==0 )
		{
			Main.quit();
			return false;
		}
		return false;
	}
	
	/**
	 * Allows the application to close and decide if it can exit
	 * Params:
	 *  code = the code reason to exit
	 *  force = if true the application must expect to be closed even against it's will
	 * Returns: false to refuse to exit
	 */
	protected bool exit(int code, bool force)
	{
		return force;
	}
}

code: end
outFile: MainWindow

file: GtkWindowGroup.html
struct: GtkWindowGroup
class: WindowGroup
prefix: gtk_window_group_
import: glib.ListG
import: gdk.Device
import: gtk.Widget
import: gtk.Window
structWrap: GList* ListG
structWrap: GdkDevice* Device
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window
outFile: WindowGroup

file: GtkAboutDialog.html
struct: GtkAboutDialog
class: AboutDialog
prefix: gtk_about_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
import: gtk.Window
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkWindow* Window

override: getName
override: setName

array: gtk_about_dialog_set_authors authors
array: gtk_about_dialog_set_artists artists
array: gtk_about_dialog_set_documenters documenters
array: gtk_about_dialog_add_credit_section people

outFile: AboutDialog

file: GtkAssistant.html
struct: GtkAssistant
class: Assistant
prefix: gtk_assistant_
import: glib.Str
import: gdk.Pixbuf
import: gtk.Widget
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkWidget* Widget
outFile: Assistant

file: GtkOffscreenWindow.html
struct: GtkOffscreenWindow
class: OffscreenWindow
prefix: gtk_offscreen_window_
import: cairo.Surface
import: gdk.Pixbuf
structWrap: cairo_surface_t* Surface
structWrap: GdkPixbuf* Pixbuf
outFile: OffscreenWindow

###########################################################
### Display Widgets #######################################
###########################################################

file: GtkAccelLabel.html
struct: GtkAccelLabel
class: AccelLabel
prefix: gtk_accel_label_
import: glib.Str
import: gobject.Closure
import: gtk.Widget
structWrap: GClosure* Closure
structWrap: GtkWidget* Widget
outFile: AccelLabel

file: GtkImage.html
struct: GtkImage
class: Image
prefix: gtk_image_
import: glib.Str
import: gio.Icon
import: gio.IconIF
import: gdk.Pixbuf
import: gdkpixbuf.PixbufAnimation
import: gtk.IconSet
structWrap: GIcon* IconIF
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkPixbufAnimation* PixbufAnimation
structWrap: GtkIconSet* IconSet

out: gtk_image_get_icon_set icon_set
out: gtk_image_get_icon_set size
out: gtk_image_get_stock stock_id
out: gtk_image_get_stock size
out: gtk_image_get_icon_name icon_name
out: gtk_image_get_icon_name size
out: gtk_image_get_gicon gicon
out: gtk_image_get_gicon size

nocode: gtk_image_new_from_stock

code: start
	/**
	 * Creates a GtkImage displaying a stock icon. Sample stock icon
	 * names are GTK_STOCK_OPEN, GTK_STOCK_EXIT. Sample stock sizes
	 * are GTK_ICON_SIZE_MENU, GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
	 * icon name isn't known, the image will be empty.
	 * You can register your own stock icon names, see
	 * gtk_icon_factory_add_default() and gtk_icon_factory_add().
	 * Params:
	 *  StockID = a stock icon name
	 *  size = a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the stock icon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_stock (const gchar *stock_id,  GtkIconSize size);
		auto p = gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size)");
		}
		this(cast(GtkImage*)p);
	}
code: end
outFile: Image

file: GtkLabel.html
struct: GtkLabel
class: Label
prefix: gtk_label_
import: glib.Str
import: gtk.Menu
import: gtk.Widget
import: pango.PgAttributeList
import: pango.PgLayout
structWrap: GtkMenu* Menu
structWrap: GtkWidget* Widget
structWrap: PangoAttrList* PgAttributeList
structWrap: PangoLayout* PgLayout

out: gtk_label_get_layout_offsets x
out: gtk_label_get_layout_offsets y
out: gtk_label_get_selection_bounds start
out: gtk_label_get_selection_bounds end

nocode: gtk_label_new
nocode: gtk_label_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkLabel, containing the text in str.
	 * If characters in str are preceded by an underscore, they are
	 * underlined. If you need a literal underscore character in a label, use
	 * '__' (two underscores). The first underlined character represents a 
	 * keyboard accelerator called a mnemonic. The mnemonic key can be used 
	 * to activate another widget, chosen automatically, or explicitly using
	 * gtk_label_set_mnemonic_widget().
	 * If gtk_label_set_mnemonic_widget()
	 * is not called, then the first activatable ancestor of the GtkLabel
	 * will be chosen as the mnemonic widget. For instance, if the
	 * label is inside a button or menu item, the button or menu item will
	 * automatically become the mnemonic widget and be activated by
	 * the mnemonic.
	 * Params:
	 *  str = The text of the label, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = when false uses the literal text passed in without mnemonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string str, bool mnemonic=true)
	{
		GtkLabel* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_label_new_with_mnemonic (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new_with_mnemonic(Str.toStringz(str));
		}
		else
		{
			// GtkWidget* gtk_label_new (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new(Str.toStringz(str));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_label_new");
		}

		this(p);
	}
code: end
outFile: Label

file: GtkProgressBar.html
struct: GtkProgressBar
class: ProgressBar
prefix: gtk_progress_bar_
import: glib.Str
outFile: ProgressBar

file: GtkStatusbar.html
struct: GtkStatusbar
class: Statusbar
prefix: gtk_statusbar_
import: glib.Str
import: gtk.Box
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode:  gtk_statusbar_get_message_area

code: start
	/**
	 * Retrieves the box containing the label widget.
	 * Since 2.20
	 * Returns: a GtkBox. [transfer none]
	 */
	public Box getMessageArea()
	{
		// GtkWidget * gtk_statusbar_get_message_area (GtkStatusbar *statusbar);
		auto p = gtk_statusbar_get_message_area(gtkStatusbar);
		if(p is null)
		{
			return null;
		}
		return new Box(cast(GtkBox*) p);
	}
code: end
outFile: Statusbar

file: GtkLevelBar.html
struct: GtkLevelBar
class: LevelBar
prefix: gtk_level_bar_
import: glib.Str
out: gtk_level_bar_get_offset_value value
outFile: LevelBar

file: GtkInfoBar.html
struct: GtkInfoBar
ctorStruct: GtkWidget
class: InfoBar
prefix:  gtk_info_bar_
import: glib.Str
import: gtk.Button
import: gtk.HBox;
import: gtk.VButtonBox
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_info_bar_get_action_area
nocode: gtk_info_bar_get_content_area

code: start
	/** */
	public this(string[] buttonsText, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}

	/** */
	public this(StockID[] stockIDs, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/** */
	public Button addButton(StockID stockID, int responseId)
	{
		auto p = gtk_info_bar_add_button(gtkInfoBar, Str.toStringz(StockDesc[stockID]), responseId);

		if ( p is null )
		{
			return null;
		}

		return new Button(cast(GtkButton*)p);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/**
	 * Returns the action area of info_bar.
	 * Since 2.18
	 * Returns: the action area.
	 */
	public VButtonBox getActionArea()
	{
		// GtkWidget * gtk_info_bar_get_action_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_action_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new VButtonBox(cast(GtkVButtonBox*) p);
	}
	
	/**
	 * Returns the content area of info_bar.
	 * Since 2.18
	 * Returns: the content area.
	 */
	public HBox getContentArea()
	{
		// GtkWidget * gtk_info_bar_get_content_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_content_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new HBox(cast(GtkHBox*) p);
	}
code: end
outFile: InfoBar

file: GtkStatusIcon.html
struct: GtkStatusIcon
class: StatusIcon
prefix: gtk_status_icon_
import: glib.Str
import: gio.Icon
import: gio.IconIF
import: gdk.Pixbuf
import: gdk.Screen
import: gtk.Menu
import: gtk.Tooltip
structWrap: GIcon* IconIF
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkScreen* Screen
structWrap: GtkMenu* Menu
structWrap: GtkTooltip* Tooltip

out: gtk_status_icon_position_menu x
out: gtk_status_icon_position_menu y
out: gtk_status_icon_position_menu push_in
out: gtk_status_icon_get_geometry screen
out: gtk_status_icon_get_geometry area
out: gtk_status_icon_get_geometry orientation

nocode: gtk_status_icon_new_from_stock
nocode: gtk_status_icon_new_from_file
nocode: gtk_status_icon_new_from_icon_name
#new_from_icon_name conflicts with new_from_file.

code: start
	/**
	 * Creates a status icon displaying a stock icon. Sample stock icon
	 * names are StockID.OPEN, StockID.QUIT. You can register your
	 * own stock icon names, see gtk_icon_factory_add_default() and
	 * gtk_icon_factory_add().
	 * Since 2.10
	 * Params:
	 *  stock_id = a stock icon id
	 * Returns:
	 *  a new GtkStatusIcon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID)
	{
		// GtkStatusIcon* gtk_status_icon_new_from_stock (const gchar *stock_id);
		auto p = gtk_status_icon_new_from_stock(Str.toStringz(StockDesc[stockID]));
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_stock");
		}
		this(cast(GtkStatusIcon*)p);
	}

	/**
	 * Creates a status icon displaying an icon from the current icon theme.
	 * If the current icon theme is changed, the icon will be updated
	 * appropriately.
	 * Since 2.10
	 * Params:
	 *  iconName =  an icon name
	 *  loadFromFile = treat iconName as a filename and load that image
	 *  with gtk_status_icon_new_from_file.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string iconName, bool loadFromFile = false)
	{
		//TODO: look at a better way to do this.
		GtkStatusIcon* p;

		if(loadFromFile)
		{
			// GtkStatusIcon* gtk_status_icon_new_from_file (const gchar *filename);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_file(Str.toStringz(iconName));
		}
		else
		{
			// GtkStatusIcon* gtk_status_icon_new_from_icon_name (const gchar *icon_name);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_icon_name(Str.toStringz(iconName));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_");
		}

		this(p);
	}
code: end
outFile: StatusIcon

file: GtkSpinner.html
struct: GtkSpinner
class: Spinner
prefix: gtk_spinner_
outFile: Spinner

###########################################################
### Buttons and Toggles ###################################
###########################################################

file: GtkButton.html
struct: GtkButton
class: Button
implements: ActionableIF
implements: ActivatableIF
prefix: gtk_button_
import: glib.Str
import: gtk.Image
import: gdk.Window
import: gtk.Widget
structWrap: GdkWindow* Window
structWrap: GtkWidget* Widget

#imports for Actionable Interface.
import: gtk.ActionableIF
import: gtk.ActionableT

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

out: gtk_button_get_alignment xalign
out: gtk_button_get_alignment yalign

nocode: gtk_button_new_with_mnemonic
nocode: gtk_button_new_with_label
nocode: gtk_button_new_from_stock

code: start
	private static IconSize currentIconSize = IconSize.BUTTON;

	// add the Actionable capabilities
	mixin ActionableT!(GtkButton);

	// add the Activatable capabilities
	mixin ActivatableT!(GtkButton);

	/** */
	public static void setIconSize(IconSize iconSize)
	{
		currentIconSize = iconSize;
	}

	/** */
	public static IconSize getIconSize()
	{
		return currentIconSize;
	}

	/**
	 * Creates a new GtkButton containing a label.
	 * If characters in label are preceded by an underscore, they are underlined.
	 * If you need a literal underscore character in a label, use '__' (two
	 * underscores). The first underlined character represents a keyboard
	 * accelerator called a mnemonic.
	 * Pressing Alt and that key activates the button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Returns:
	 *  a new GtkButton
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_button_new_with_label (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new_with_label");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkButton containing the image and text from a stock item.
	 * Some stock ids have preprocessor macros like GTK_STOCK_OK and
	 * GTK_STOCK_APPLY.
	 * If stock_id is unknown, then it will be treated as a mnemonic
	 * label (as for gtk_button_new_with_mnemonic()).
	 * Params:
	 *  StockID = the name of the stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, bool hideLabel=false)
	{
		// GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
		if ( hideLabel )
		{
			this();
			Image image = new Image(stockID,currentIconSize);
			add(image);
		}
		else
		{
			auto p = gtk_button_new_from_stock(Str.toStringz(StockDesc[stockID]));

			if(p is null)
			{
				throw new ConstructionException("null returned by gtk_button_new_from_stock");
			}

			this(cast(GtkButton*) p);
		}
	}
	
	/** */
	public this(StockID stockID, void delegate(Button) dlg, bool hideLabel=false)
	{
		this(stockID, hideLabel);
		addOnClicked(dlg);
	}
	
	/** */
	public this(string label, void delegate(Button) dlg, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(dlg);
	}

	/** */
	public this(string label, void delegate(Button) dlg, string action)
	{
		this(label);
		setActionName(action);
		addOnClicked(dlg);
	}
code: end
outFile: Button

file: GtkCheckButton.html
struct: GtkCheckButton
class: CheckButton
import: glib.Str
import: gtk.Button
prefix: gtk_check_button_

nocode: gtk_check_button_new_with_label
nocode: gtk_check_button_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckButton with a GtkLabel to the right of it.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the check button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_button_new_with_label (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_button_new_");
		}

		this(p);
	}

	/** */
	public this(string label, void delegate(CheckButton) onClicked, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(cast(void delegate(Button))onClicked);
	}
	
code: end
outFile: CheckButton

file: GtkRadioButton.html
struct: GtkRadioButton
class: RadioButton
prefix: gtk_radio_button_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioButton* RadioButton

nocode: gtk_radio_button_new_with_label
nocode: gtk_radio_button_new_with_mnemonic
nocode: gtk_radio_button_new_with_label_from_widget
nocode: gtk_radio_button_new_with_mnemonic_from_widget

code: start
	/**
	 * Creates a new RadioButton with a text label.
	 * Params:
	 *  group = an existing radio button group.
	 *  label = the text label to display next to the radio button.
	 *  mnemonic = if true the label will be created using
	 *  gtk_label_new_with_mnemonic(), so underscores in label indicate the
	 *  mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}
	
	/**
	 * Creates a new RadioButton with a text label, adding it to the same group
	 * as group.
	 * Params:
	 *  radioButton = an existing RadioButton.
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioButton radioButton, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic_from_widget(
						radioButton.getRadioButtonStruct(),
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label_from_widget(
						radioButton.getRadioButtonStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}

	/**
	 * Creates a new RadioButton with a text label,
	 * and creates a new group.
	 * Params:
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		this(cast(ListSG)null, label, mnemonic);
	}
code: end
outFile: RadioButton

file: GtkToggleButton.html
struct: GtkToggleButton
class: ToggleButton
prefix: gtk_toggle_button_
import: glib.Str

nocode: gtk_toggle_button_new_with_label
nocode: gtk_toggle_button_new_with_mnemonic

code: start
	/**
	 * Creates a new toggle button with a text label.
	 * Params:
	 *  label = a string containing the message to be placed in the toggle button.
	 *  mnemonic =  if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkToggleButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_toggle_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_toggle_button_new_with_label  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_toggle_button_new_");
		}

		this(p);
	}
code: end
outFile: ToggleButton

file: GtkLinkButton.html
struct: GtkLinkButton
class: LinkButton
prefix: gtk_link_button_
prefix: gtk_
import: glib.Str
outFile: LinkButton

file: GtkScaleButton.html
struct: GtkScaleButton
class: ScaleButton
implements: OrientableIF
prefix: gtk_scale_button_
import: glib.Str
import: gtk.Adjustment
import: gtk.Widget
structWrap: GtkAdjustment* Adjustment
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

nocode: gtk_scale_button_set_orientation
nocode: gtk_scale_button_get_orientation

array: gtk_scale_button_new icons
array: gtk_scale_button_set_icons icons

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkScaleButton);
code: end
outFile: ScaleButton

file: GtkVolumeButton.html
struct: GtkVolumeButton
class: VolumeButton
prefix: gtk_volume_button_
import: glib.Str
outFile: VolumeButton

file: GtkSwitch.html
struct: GtkSwitch
class: Switch
implements: ActionableIF
implements: ActivatableIF
prefix: gtk_switch_

#imports for Actionable Interface.
import: gtk.ActionableIF
import: gtk.ActionableT

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

code: start
	// add the Actionable capabilities
	mixin ActionableT!(GtkSwitch);

	// add the Activatable capabilities
	mixin ActivatableT!(GtkSwitch);
code: end
outFile: Switch

file: GtkLockButton.html
struct: GtkLockButton
class: LockButton
prefix: gtk_switch_
import: gio.Permission
structWrap: GPermission* Permission
outFile: LockButton

file: GtkMenuButton.html
struct: GtkMenuButton
class: MenuButton
prefix: gtk_menu_button_
import: gio.MenuModel
import: gtk.Menu
import: gtk.Widget
structWrap: GMenuModel* MenuModel
structWrap: GtkMenu* Menu
structWrap: GtkWidget* Widget

alias: setDirection setMenuDirection
alias: getDirection getMenuDirection

outFile: MenuButton

###########################################################
### numeric/text Data Entry ###############################
###########################################################

file: GtkEntry.html
struct: GtkEntry
class: Entry
implements: EditableIF
implements: CellEditableIF
prefix: gtk_entry_
import: glib.Str
import: gio.Icon
import: gio.IconIF
import: gdk.Pixbuf
import: gtk.Adjustment
import: gtk.Border
import: gtk.EntryBuffer
import: gtk.EntryCompletion
import: gtk.TargetList
import: gtk.Widget
import: pango.PgAttributeList
import: pango.PgLayout
structWrap: GIcon* IconIF
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkAdjustment* Adjustment
structWrap: GtkBorder* Border
structWrap: GtkEntryBuffer* EntryBuffer
structWrap: GtkEntryCompletion* EntryCompletion
structWrap: GtkTargetList* TargetList
structWrap: GtkWidget* Widget
structWrap: PangoAttrList* PgAttributeList
structWrap: PangoLayout* PgLayout

# imports for TreeModel Interface
import: gtk.EditableT
import: gtk.EditableIF

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

out: gtk_entry_get_text_area text_area
out: gtk_entry_get_layout_offsets x
out: gtk_entry_get_layout_offsets y
out: gtk_entry_get_icon_area icon_area

code: start
	// add the Editable capabilities
	mixin EditableT!(GtkEntry);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkEntry);

	/** */
	public this (string text)
	{
		this();
		setText(text);
	}

	/** */	
	public this (string text, int max)
	{
		this(text);
		setMaxLength(max);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId(GtkEntryIconPosition iconPos)
	{
		// const gchar* gtk_entry_get_icon_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos);
		string id = Str.toString(gtk_entry_get_icon_stock(gtkEntry, iconPos));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(GtkEntryIconPosition iconPos, StockID stockId)
	{
		// void gtk_entry_set_icon_from_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *stock_id);
		gtk_entry_set_icon_from_stock(gtkEntry, iconPos, Str.toStringz(StockDesc[stockId]));
	}
code: end
outFile: Entry

file: GtkEntryBuffer.html
struct: GtkEntryBuffer
class: EntryBuffer
prefix: gtk_entry_buffer_
import: glib.Str
array: gtk_entry_buffer_new initial_chars n_initial_chars
array: gtk_entry_buffer_set_text chars n_chars
array: gtk_entry_buffer_insert_text chars n_chars
array: gtk_entry_buffer_emit_inserted_text chars n_chars
outFile: EntryBuffer

file: GtkEntryCompletion.html
struct: GtkEntryCompletion
class: EntryCompletion
implements: BuildableIF
implements: CellLayoutIF
prefix: gtk_entry_completion_
import: glib.Str
import: gtk.CellArea
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.Widget
structWrap: GtkCellArea* CellArea
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkEntryCompletion);

	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkEntryCompletion);
code: end
outFile: EntryCompletion

file: GtkScale.html
struct: GtkScale
class: Scale
prefix: gtk_scale_
import: glib.Str
import: gtk.Adjustment
import: pango.PgLayout
structWrap: GtkAdjustment* Adjustment
structWrap: PangoLayout* PgLayout

out: gtk_scale_get_layout_offsets x
out: gtk_scale_get_layout_offsets y
outFile: Scale

file: GtkHScale.html
struct: GtkHScale
class: HScale
prefix: gtk_hscale_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScale

file: GtkVScale.html
struct: GtkVScale
class: VScale
prefix: gtk_vscale_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScale

file: GtkSpinButton.html
struct: GtkSpinButton
class: SpinButton
prefix: gtk_spin_button_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_spin_button_get_increments step
out: gtk_spin_button_get_increments page
out: gtk_spin_button_get_range min
out: gtk_spin_button_get_range max
outFile: SpinButton

file: GtkSearchEntry.html
struct: GtkSearchEntry
class: SearchEntry
prefix: gtk_search_entry_
outFile: SearchEntry

file: GtkEditable.html
struct: GtkEditable
class: EditableT
template: TStruct
prefix: gtk_editable_
import: glib.Str

out: gtk_editable_get_selection_bounds start_pos
out: gtk_editable_get_selection_bounds end_pos
array: gtk_editable_insert_text new_text new_text_length
inout: gtk_editable_insert_text position

interface: EditableIF
outFile: EditableT

###########################################################
### Multiline Text Editor #################################
###########################################################

file: GtkTextIter.html
struct: GtkTextIter
class: TextIter
nostruct: GtkTextIter
prefix: gtk_text_iter_
import: glib.Str
import: glib.ListSG
import: gdk.Pixbuf
import: gtk.TextAttributes
import: gtk.TextBuffer
import: gtk.TextChildAnchor
import: gtk.TextTag
import: gtkc.Loader
import: gtkc.paths
import: pango.PgLanguage
structWrap: GSList* ListSG
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkTextAttributes* TextAttributes
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTextChildAnchor* TextChildAnchor
structWrap: GtkTextIter* TextIter
structWrap: GtkTextTag* TextTag
structWrap: PangoLanguage* PgLanguage

code: start
	/** */
	public this()
	{
		this(new GtkTextIter);
	}
code: end
outFile: TextIter

file: GtkTextMark.html
struct: GtkTextMark
class: TextMark
prefix: gtk_text_mark_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
outFile: TextMark

file: GtkTextBuffer.html
struct: GtkTextBuffer
class: TextBuffer
prefix: gtk_text_buffer_
import: std.stdio
import: std.stdarg
import: gtkc.gobject;
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gdk.Color
import: gdk.Pixbuf
import: gtk.Clipboard
import: gtk.TargetList
import: gtk.TextChildAnchor
import: gtk.TextIter
import: gtk.TextMark
import: gtk.TextTag
import: gtk.TextTagTable
import: pango.PgFontDescription
import: pango.PgTabArray
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkClipboard* Clipboard
structWrap: GtkTargetList* TargetList
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTextChildAnchor* TextChildAnchor
structWrap: GtkTextIter* TextIter
structWrap: GtkTextMark* TextMark
structWrap: GtkTextTag* TextTag
structWrap: GtkTextTagTable* TextTagTable

array: gtk_text_buffer_insert text len
array: gtk_text_buffer_insert_at_cursor text len
array: gtk_text_buffer_insert_interactive text len
array: gtk_text_buffer_insert_interactive_at_cursor text len
array: gtk_text_buffer_set_text text len
array: gtk_text_buffer_deserialize data length
array: gtk_text_buffer_get_deserialize_formats Return n_formats
array: gtk_text_buffer_get_serialize_formats Return n_formats
array: gtk_text_buffer_serialize Return length

nocode: gtk_text_buffer_insert_with_tags
nocode: gtk_text_buffer_insert_with_tags_by_name
nocode: gtk_text_buffer_create_tag

code: start	
	/**
	 * Inserts text into buffer at iter, applying the list of tags to
	 * the newly-inserted text. The last tag specified must be NULL to
	 * terminate the list. Equivalent to calling gtk_text_buffer_insert(),
	 * then gtk_text_buffer_apply_tag() on the inserted text;
	 * gtk_text_buffer_insert_with_tags() is just a convenience function.
	 * Params:
	 *  iter = an iterator in buffer
	 *  text = UTF-8 text
	 *  tags = list of tags to apply
	 */
	public void insertWithTags(TextIter iter, string text, TextTag[] tags ... )
	{
		int startOffset = iter.getOffset();

		insert(iter, text);

		if ( tags.length == 0 )
			return;

		TextIter start = new TextIter();
		getIterAtOffset(start, startOffset);

		foreach( tag; tags )
		{
			applyTag(tag, start, iter);
		}
	}
	
	/**
	 * Same as gtk_text_buffer_insert_with_tags(), but allows you
	 * to pass in tag names instead of tag objects.
	 * Params:
	 *  iter = position in buffer
	 *  text = UTF-8 text
	 *  tags = tag names
	 */
 	public void insertWithTagsByName(TextIter iter, string text, string[] tags ... )
	{
		int startOffset = iter.getOffset();

		insert(iter, text);

		if ( tags.length == 0 )
			return;

		TextIter start = new TextIter();
		getIterAtOffset(start, startOffset);

		foreach( tag; tags )
		{
			applyTagByName(tag, start, iter);
		}
	}

	/**
	 * Creates a tag and adds it to the tag table for buffer. Equivalent to
	 * adding a new tag to the buffer's tag table.
	 *
	 * If tagName is null, the tag is anonymous.
	 * 
	 * If tagName is non-NULL, a tag called tagName must not already exist
	 * in the tag table for this buffer.
	 * 
	 * Params:
	 *     tagName = the name for the new tag.
	 *     ...     = A list of property names and there values.
	 */
	TextTag createTag(string tagName, ...)
	{
		TextTag tag = new TextTag(gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), null, null));

		for (size_t i = 0; i < _arguments.length; i+=2)
		{
			//TODO: Add a proper eception type for this.
			if ( _arguments[i] != typeid(string) )
				throw new Exception("TextBuffer.CreateTag: The property name must be a string.");

			string name = va_arg!(string)(_argptr);

			version(D_Version2)
			{
				mixin("if ( _arguments[i+1] == typeid(const(double)) )
				{
					g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(double)(_argptr), null);
					continue;
				}");
			}

			if ( _arguments[i+1] == typeid(bool) ||
				_arguments[i+1] == typeid(int) ||
				_arguments[i+1] == typeid(GtkJustification) ||
				_arguments[i+1] == typeid(GtkTextDirection) ||
				_arguments[i+1] == typeid(GtkWrapMode) ||
				_arguments[i+1] == typeid(PangoStretch) ||
				_arguments[i+1] == typeid(PangoStyle) ||
				_arguments[i+1] == typeid(PangoUnderline) ||
				_arguments[i+1] == typeid(PangoVariant) ||
				_arguments[i+1] == typeid(PangoWeight) )
			{

				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(int)(_argptr), null);
			}
			else if ( _arguments[i+1] == typeid(Color) )
			{
				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(Color)(_argptr).getColorStruct(), null);
			}
			else if ( _arguments[i+1] == typeid(double) )
			{
				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(double)(_argptr), null);
			}
			else if ( _arguments[i+1] == typeid(PgFontDescription) )
			{
				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(PgFontDescription)(_argptr).getPgFontDescriptionStruct(), null);
			}
			else if ( _arguments[i+1] == typeid(PgTabArray) )
			{
				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), va_arg!(PgTabArray)(_argptr).getPgTabArrayStruct(), null);
			}
			else if ( _arguments[i+1] == typeid(string) )
			{
				g_object_set(tag.getObjectGStruct(), Str.toStringz(name), Str.toStringz(va_arg!(string)(_argptr)), null);
			}
			else
			{
				version(Tango)
					Stderr.formatln("TextBuffer.CreateTag: Unsuported type: \"{}\" for property: \"{}\"", _arguments[i+1], name);
				else version(D_Version2)
					stderr.writefln("TextBuffer.CreateTag: Unsuported type: \"%s\" for property: \"%s\"", _arguments[i+1], name);
				else
					fwritefln(stderr, "TextBuffer.CreateTag: Unsuported type: \"%s\" for property: \"%s\"", _arguments[i+1], name);

				//TODO: throw segfaults, druntime bug?
				throw new Exception("TextBuffer.CreateTag: Unsuported type: \""~_arguments[i+1].toString()~"\" for property: \""~name~"\"");

			}
		}

		return tag;
	}

	/**
	 * Obtain the entire text
	 * Returns: The text string
	 */
	string getText()
	{
		TextIter start = new TextIter();
		TextIter end = new TextIter();
		getBounds(start,end);
		return Str.toString(gtk_text_buffer_get_slice(gtkTextBuffer, start.getTextIterStruct(), end.getTextIterStruct(), true));
	}
code: end
outFile: TextBuffer

file: GtkTextTag.html
struct: GtkTextTag
class: TextTag
prefix: gtk_text_tag_
noprefix: gtk_text_attributes_
import: glib.Str
import: gobject.ObjectG
import: gdk.Event
import: gtk.TextIter
structWrap: GObject* ObjectG
structWrap: GdkEvent* Event
structWrap: GtkTextIter* TextIter
outFile: TextTag

struct: GtkTextAttributes
class: TextAttributes
prefix: gtk_text_attributes_
strictPrefix: Y
import: gtkc.Loader
import: gtkc.paths
structWrap: GtkTextAttributes* TextAttributes
nosignal: event
code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkTextAttributes !is null )
		{
			gtk_text_attributes_unref(gtkTextAttributes);
		}
	}

	//TODO: properties ?
code: end
outFile: TextAttributes

file: GtkTextTagTable.html
struct: GtkTextTagTable
class: TextTagTable
prefix: gtk_text_tag_table_
import: glib.Str
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
outFile: TextTagTable

file: GtkTextView.html
struct: GtkTextView
class: TextView
implements: ScrollableIF
prefix: gtk_text_view_
noprefix: gtk_text_child_anchor_
import: glib.Str
import: glib.ListG
import: gdk.Window
import: gtk.Adjustment
import: gtk.TextAttributes
import: gtk.TextBuffer
import: gtk.TextChildAnchor
import: gtk.TextIter
import: gtk.TextMark
import: gtk.Widget
import: pango.PgTabArray
structWrap: GList* ListG
structWrap: GdkWindow* Window
structWrap: GtkAdjustment* Adjustment
structWrap: GtkTextAttributes* TextAttributes
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTextChildAnchor* TextChildAnchor
structWrap: GtkTextIter* TextIter
structWrap: GtkTextMark* TextMark
structWrap: GtkWidget* Widget
structWrap: PangoTabArray* PgTabArray

nocode: gtk_text_view_get_hadjustment
nocode: gtk_text_view_get_vadjustment

#imports for Scrollable Interface.
import: gtk.ScrollableIF
import: gtk.ScrollableT

out: gtk_text_view_get_visible_rect visible_rect
out: gtk_text_view_get_iter_location location
out: gtk_text_view_get_cursor_locations strong
out: gtk_text_view_get_cursor_locations weak
out: gtk_text_view_get_line_at_y line_top
out: gtk_text_view_get_line_yrange y
out: gtk_text_view_get_line_yrange height
out: gtk_text_view_get_iter_at_position trailing
out: gtk_text_view_buffer_to_window_coords window_x
out: gtk_text_view_buffer_to_window_coords window_y
out: gtk_text_view_window_to_buffer_coords buffer_x
out: gtk_text_view_window_to_buffer_coords buffer_y

code: start
	// add the Scrollable capabilities
	mixin ScrollableT!(GtkTextView);

	/**
	 * Get the text line at the pixel y
	 */
	string getLineTextAt(gint y)
	{
		
		TextIter iter = new TextIter();
		int windowX;
		int windowY;
		bufferToWindowCoords(TextWindowType.TEXT, 0, y, windowX, windowY);

		gtk_text_view_get_line_at_y(gtkTextView, iter.getTextIterStruct(), y+y-windowY, null);
		
		TextIter iterEnd = new TextIter();
		TextBuffer buffer = getBuffer();
		buffer.getIterAtOffset(iterEnd, iter.getOffset()+iter.getCharsInLine());
		return buffer.getText(iter, iterEnd, false);
	}

	/**
	 * Simply appends some on the cursor position
	 * Params:
	 *  text = the text to append
	 */
	void insertText(string text)
	{
		TextBuffer buf = getBuffer();
		buf.insertAtCursor(text);
	}

	/**
	 * Simply appends some text to this view
	 * Params:
	 *  text = the text to append
	 */
	void appendText(string text, bool ensureVisible=true)
	{
		TextBuffer buf = getBuffer();
		TextIter iter = new TextIter();
		buf.getEndIter(iter);
		buf.insert(iter, text);
		if ( ensureVisible )
		{
			gdouble within_margin = 0.0;
			bool use_align = false;
			gdouble xalign = 0.0;
			gdouble yalign = 0.0;
			scrollToMark(buf.createMark("",iter,true), within_margin, use_align, xalign, yalign);
		}
	}
code: end
outFile: TextView

struct: GtkTextChildAnchor
class: TextChildAnchor
prefix: gtk_text_child_anchor_
strictPrefix: Y

nosignal: backspace
nosignal: copy-clipboard
nosignal: cut-clipboard
nosignal: delete-from-cursor
nosignal: insert-at-cursor
nosignal: move-cursor
nosignal: move-viewport
nosignal: paste-clipboard
nosignal: populate-popup
nosignal: preedit-changed
nosignal: select-all
nosignal: set-anchor
nosignal: toggle-cursor-visible
nosignal: toggle-overwrite

import: glib.ListG
structWrap: GList* ListG
outFile: TextChildAnchor

###########################################################
### Tree, List and Icon Grid Widgets ######################
###########################################################

file: GtkTreeModel.html

struct: GtkTreePath
class: TreePath
strictPrefix: Y
prefix: gtk_tree_path_
import: glib.Str
import: gtkc.Loader
import: gtkc.paths
structWrap: GtkTreePath* TreePath

array: gtk_tree_path_get_indices Return getDepth()
array: gtk_tree_path_get_indices_with_depth Return depth

override: toString

nocode: gtk_tree_path_new
nocode: gtk_tree_path_new_first

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * Creates a new GtkTreePath. This structure refers to a row.
	 * Params:
	 * firstRow = if true this is the string representation of this path is "0"
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool firstRow=false)
	{
		GtkTreePath* p;

		if ( firstRow )
		{
			// GtkTreePath* gtk_tree_path_new_first (void);
			p = cast(GtkTreePath*)gtk_tree_path_new_first();
		}
		else
		{
			// GtkTreePath* gtk_tree_path_new (void);
			p = cast(GtkTreePath*)gtk_tree_path_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_path_new()");
		}

		this(p);
	}

	/**
	 * Creates a new path with "indices" as indices.
	 */
	this (int[] indices ... )
	{
		this(false);

		foreach( index; indices )
			appendIndex(index);
	}

	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkTreePath !is null )
		{
			gtk_tree_path_free(gtkTreePath);
		}
	}
code: end
outFile: TreePath

struct: GtkTreeModel
class: TreeModelT
template: TStruct
prefix: gtk_tree_model_
noprefix: gtk_tree_row_reference_
noprefix: gtk_tree_path_
noprefix: gtk_tree_iter_
nostruct: GtkTreeIter
import: glib.Str
import: gobject.Value
import: gtk.TreeIter
import: gtk.TreePath
structWrap: GValue* Value
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreePath* TreePath

nocode: gtk_tree_model_get_value
nocode: gtk_tree_model_get_iter

array: gtk_tree_model_rows_reordered new_order

interfaceCode: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column);

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column);

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path);

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null);
interfaceCode: end

code: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column)
	{
		Value value = getValue(iter, column);
		return value.getString();
	}

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column)
	{
		Value value = getValue(iter, column);
		return value.getInt();
	}

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path)
	{
		// gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,  GtkTreeIter *iter,  GtkTreePath *path);
		iter.setModel(this);
		return gtk_tree_model_get_iter(
				getTreeModelTStruct(), 
				(iter is null) ? null : iter.getTreeIterStruct(), 
				(path is null) ? null : path.getTreePathStruct());
	}

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null)
	{
		if ( value is null )
			value = new Value();

		// void gtk_tree_model_get_value (GtkTreeModel *tree_model,  GtkTreeIter *iter,  gint column,  GValue *value);
		gtk_tree_model_get_value(getTreeModelTStruct(), (iter is null) ? null : iter.getTreeIterStruct(), column, (value is null) ? null : value.getValueStruct());

		return value;
	}
code: end

interface: TreeModelIF
outFile: TreeModelT

struct: GtkTreeIter
class: TreeIter
strictPrefix: Y
prefix: gtk_tree_iter_
import: glib.Str
import: gobject.Value
import: gtk.TreeIterError
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkTreeIter* TreeIter

nocode: gtk_tree_iter_copy
nocode: gtk_tree_iter_free

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * this will be set only when the iter
	 * is created from the model.
	 */
	GtkTreeModel* gtkTreeModel; 

	/** */
	public void setModel(GtkTreeModel* gtkTreeModel)
	{
		this.gtkTreeModel = gtkTreeModel;
	}

	/** */       
	public void setModel(TreeModelIF treeModel)
	{
		this.gtkTreeModel = treeModel.getTreeModelTStruct();
	}

	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, string treePath)
	{
		this(treeModel, new TreePath(treePath));
	}
	   
	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, TreePath treePath)
	{
		this();
		setModel(treeModel);
		if ( !gtk_tree_model_get_iter_from_string(
				treeModel.getTreeModelTStruct(),
				getTreeIterStruct(), Str.toStringz(treePath.toString())) )
		{
			throw new ConstructionException("null returned by gtk_tree_model_get_iter_from_string");
		}
	}
	
	/**
	* creates a new tree iteractor.
	* used TreeView.createIter and TreeView.append() to create iteractor for a tree or list
	*/
	this()
	{
		this(new GtkTreeIter);
	}

	/**
	 * Creates a dynamically allocated tree iterator as a copy of iter.
	 */
	TreeIter copy(TreeIter iter)
	{
		TreeIter cp = new TreeIter();
		*(cp.gtkTreeIter) = *(iter.gtkTreeIter);

		return cp;
	}

	/**
	 * Get Value
	 * Params:
	 *  column =
	 *  value =
	 */
	void getValue(int column, Value value)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValue","Tree model not set");
		}
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
	}

	/**
	 * Get the value of a column as a string
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	string getValueString(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueString","Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		//printf("TreeIter.getValuaString = %.*s\n", value.getString().toString());
		return value.getString();
	}

	/**
	 * Get the value of a column as an int
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	int getValueInt(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueInt", "Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		return value.getInt();
	}

	/** */
	TreePath getTreePath()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getTreePath","Tree model not set");
		}
		return new TreePath(gtk_tree_model_get_path(gtkTreeModel, gtkTreeIter));
	}

	/**
	 * This return the path visible to the user.
	 */
	string getVisiblePath(string separator)
	{
		string vPath;
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getVisiblePath", "Tree model not set");
		}

		vPath = getValueString(0);
		TreeIter parent = getParent();
		while ( parent !is  null )
		{
			//printf("TreeIter.getVisiblePath parent = %.*s\n",parent.getValueString(0).toString());
			vPath = parent.getValueString(0) ~ separator ~ vPath;
			parent = parent.getParent();
		}
		
		//printf("TreeIter.getVisiblePath = %.*s\n", vPath.toString());
		
		return vPath;
	}
	
	/**
	 * Gets the parent of this iter
	 * Returns: the parent iter or null if can't get parent or an error occured
	 */
	TreeIter getParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getParent", "Tree model not set");
		}
		TreeIter parent = new TreeIter();
		bool gotParent = gtk_tree_model_iter_parent(gtkTreeModel, parent.getTreeIterStruct(), gtkTreeIter) == 0 ? false : true;
		if ( !gotParent )
		{
			return null;
		}
		parent.setModel(gtkTreeModel);
		return parent;
	}

	/** */
	TreeIter getGrandParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getGrandParent", "Tree model not set");
		}
		TreeIter grandParent = this;
		TreeIter parent = grandParent.getParent();
		while ( parent !is null )
		{
			grandParent = parent;
			parent = grandParent.getParent();
		}
		
		return grandParent;
	}

	/** A unique stamp to catch invalid iterators */
	public int stamp()
	{
		return gtkTreeIter.stamp;
	}

	/** Ditto */
	public void stamp(int stamp)
	{
		gtkTreeIter.stamp = stamp;
	}

	/** Model specific data */
	public void* userData()
	{
		return gtkTreeIter.userData;
	}

	/** Ditto */
	public void userData(void* data)
	{
		gtkTreeIter.userData = data;
	}

	public struct IterData
	{
		/// Data fields.
		union
		{
			int     dataInt;
			long    dataLong;
			double  dataFloat;
			double  dataDouble;
			string  dataString;

			void*   dataUser;
		}

		TypeInfo type = typeid(void);
	}

	/**
	 * setUserData and getUserData provide simple boxing
	 * around the userData field in the TreeIter struct.
	 * Throws: TreeIterError for unsuported types or a type mismatch.
	 * Example:
	 * ---
	 * Treeiter iter = new TreeIter();
	 *
	 * iter.setUserData(20);
	 * int i = iter.getUserData!(int)();
	 * ---
	 */
	public void setUserData(T)(T data)
	{
		IterData* itData = new IterData;
		itData.type = typeid(T);

		static if(is(T == int))
		{
			itData.dataInt = data;
		}
		else static if(is(T == long))
		{
			itData.dataLong = data;
		}
		else static if(is(T == float))
		{
			itData.dataFloat = data;
		}
		else static if(is(T == double))
		{
			itData.dataDouble = data;
		}
		else static if(is(T == string))
		{
			itData.dataString = data;
		}
		else static if(is(T == void*))
		{
			itData.dataUser = data;
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}

		gtkTreeIter.userData = itData;
	}

	/** Ditto */
	public T getUserData(T)()
	{
		IterData* itData = cast(IterData*)gtkTreeIter.userData;

		static if(is(T == int))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataInt;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: int");
			}
		}
		else static if(is(T == long))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataLong;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: long");
			}
		}
		else static if(is(T == float))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataFloat;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: float");
			}
		}
		else static if(is(T == double))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataDouble;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: double");
			}
		}
		else static if(is(T == string))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataString;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: string");
			}
		}
		else static if(is(T == void*))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataUser;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: void*");
			}
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}
	}
code: end
outFile: TreeIter


struct: GtkTreeRowReference
class: TreeRowReference
strictPrefix: Y
prefix: gtk_tree_row_reference_
import: gobject.ObjectG
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GObject* ObjectG
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath
structWrap: GtkTreeRowReference* TreeRowReference

array: gtk_tree_row_reference_reordered new_order

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered
outFile: TreeRowReference

file:
class: TreeIterError
extend: Exception
import(tango): tango.core.Exception

code: start
	/**
	 * A TreeIter error.
	 * thrown<br>
	 * - trying to access a method that requires a tree model and the tree model was never set
	 */
	public this(string method, string message)
	{
		super("TreeIter."~method~" : "~message);
	}
code: end
outFile: TreeIterError


file:
import: glib.Str
import: gobject.Type
import: gobject.ObjectG
import: gobject.Signals
import: gobject.Value
import: gtk.TreeIter
import: gtk.TreePath
import: gtk.TreeModelT
import: gtk.TreeModelIF
import: gtkc.gobject
import: gtkc.Loader
import: gtkc.paths

code: start
struct CustomTreeModelClass
{
	GObjectClass parentClass;
}

//We need this function for the interface implementation.
extern(C) GType function() c_gtk_tree_model_get_type;
alias c_gtk_tree_model_get_type gtk_tree_model_get_type;

/**
 */
public class TreeModel : ObjectG, TreeModelIF
{
	static GObjectClass* parentClass = null;
	
	mixin( _shared ~ "static this()
	{
		Linker.link(gtk_tree_model_get_type, \"gtk_tree_model_get_type\", LIBRARY.GTK);
	}");
	
	// Minimal implementation.
	mixin TreeModelT!(GtkTreeModel);
	
	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkTreeModel;
	}
	
	public this ()
	{
		auto p =  super(customTreeModelgetType(), null);
		gtkTreeModel = cast(GtkTreeModel*) p.getObjectGStruct();
		
		setDataFull("customTreeModel", cast(void*)this, cast(GDestroyNotify)&destroyNotify);
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkTreeModel* gtkTreeModel)
	{
		super(cast(GObject*)gtkTreeModel);
		this.gtkTreeModel = gtkTreeModel;
	}
	
	
	extern(C)
	{
		/*
		 *  here we register our new type and its interfaces
		 *  with the type system. If you want to implement
		 *  additional interfaces like GtkTreeSortable, you
		 *  will need to do it here.
		 */
		
		static GType customTreeModelgetType()
		{
			GType customTreeModelType = Type.fromName("CustomTreeModel");
			
			/* Some boilerplate type registration stuff */
			if (customTreeModelType == GType.INVALID)
			{
				static GTypeInfo customTreeModelInfo =
				{
					CustomTreeModelClass.sizeof,                   /* class size */
					null,                                          /* base_init */
					null,                                          /* base_finalize */
					cast(GClassInitFunc) &customTreeModelClassInit,/* class init function */
					null,                                          /* class finalize */
					null,                                          /* class_data */
					GObject.sizeof,                                /* instance size */
					0,                                             /* n_preallocs */
					//cast(GInstanceInitFunc) &customTreeModelInit   /* instance init */
					null
				};
				static GInterfaceInfo treeModelInfo =
				{
					cast(GInterfaceInitFunc) &customTreeModelInit,
					null,
					null
				};
				
				/* First register the new derived type with the GObject type system */
				customTreeModelType = Type.registerStatic (GType.OBJECT, "CustomTreeModel",
				&customTreeModelInfo, cast(GTypeFlags)0);
				
				/* Now register our GtkTreeModel interface with the type system */
				Type.addInterfaceStatic (customTreeModelType, gtk_tree_model_get_type() /*GTK_TYPE_TREE_MODEL*/, &treeModelInfo);
			}
			
			return customTreeModelType;
		}
		
		/*
		 *  boilerplate GObject/GType stuff.
		 *  Init callback for the type system,
		 *  called once when our new class is created.
		 */
		
		static void customTreeModelClassInit (void* klass)
		{
			GObjectClass* objectClass;
			
			parentClass = cast(GObjectClass*) Type.classPeekParent(klass);
			objectClass = cast(GObjectClass*) klass;
			
			objectClass.finalize = &customTreeModelFinalize;
		}
		
		/*
		 *  init callback for the interface registration
		 *  in customTreeModelGetType. Here we override
		 *  the GtkTreeModel interface functions that
		 *  we implement.
		 */
		
		static void customTreeModelInit (GtkTreeModelIface *iface)
		{
			iface.getFlags      = &customTreeModelGetFlags;
			iface.getNColumns   = &customTreeModelGetNColumns;
			iface.getColumnType = &customTreeModelGetColumnType;
			iface.getIter       = &customTreeModelGetIter;
			iface.getPath       = &customTreeModelGetPath;
			iface.getValue      = &customTreeModelGetValue;
			iface.iterNext      = &customTreeModelIterNext;
			iface.iterChildren  = &customTreeModelIterChildren;
			iface.iterHasChild  = &customTreeModelIterHasChild;
			iface.iterNChildren = &customTreeModelIterNChildren;
			iface.iterNthChild  = &customTreeModelIterNthChild;
			iface.iterParent    = &customTreeModelIterParent;
		}
		
		/*
		 *  this is called just before a custom list is
		 *  destroyed. Free dynamically allocated memory here.
		 */
		
		static void customTreeModelFinalize (GObject *object)
		{
			/* must chain up - finalize parent */
			parentClass.finalize(object);
		}
		
		static GtkTreeModelFlags customTreeModelGetFlags(GtkTreeModel *tree_model)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getFlags();
		}
		
		static int customTreeModelGetNColumns(GtkTreeModel *tree_model)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getNColumns();
		}
		
		static GType customTreeModelGetColumnType(GtkTreeModel *tree_model, int index)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getColumnType(index);
		}
		
		static gboolean customTreeModelGetIter(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getIter(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreePath)(gtk_tree_path_copy(path)));
		}
		
		static GtkTreePath* customTreeModelGetPath(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			TreePath path = tm.getPath(ObjectG.getDObject!(TreeIter)(iter));
			
			return (path is null) ? null : gtk_tree_path_copy(path.getTreePathStruct());
		}
		
		static void customTreeModelGetValue(GtkTreeModel *tree_model, GtkTreeIter *iter, int column, GValue *value)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			tm.getValue(ObjectG.getDObject!(TreeIter)(iter), column, ObjectG.getDObject!(Value)(value));
		}
		
		static gboolean customTreeModelIterNext(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNext(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static gboolean customTreeModelIterChildren(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterChildren(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(parent));
		}
		
		static gboolean customTreeModelIterHasChild(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterHasChild(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static int customTreeModelIterNChildren(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNChildren(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static gboolean customTreeModelIterNthChild(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, int n)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNthChild(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(parent), n);
		}
		
		static gboolean customTreeModelIterParent(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterParent(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(child));
		}
	}
}
code: end
outFile: TreeModel


file: GtkTreeSelection.html
struct: GtkTreeSelection
class: TreeSelection
prefix: gtk_tree_selection_

structWrap: GList* ListG
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath
structWrap: GtkTreeView* TreeView

import: gtk.TreeView
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreeIter
import: glib.ListG
import: gtk.TreePath

out: gtk_tree_selection_get_selected model
nocode: gtk_tree_selection_get_selected_rows

code: start
	/**
	 * Returns an TreeIter set to the currently selected node if selection
	 * is set to GTK_SELECTION_SINGLE or GTK_SELECTION_BROWSE.
	 * This function will not work if you use selection is GTK_SELECTION_MULTIPLE.
	 * Returns: A TreeIter for the selected node.
	 */
	public TreeIter getSelected()
	{
		TreeModelIF model;
		TreeIter iter = new TreeIter();
		
		if ( getSelected(model, iter) )
		{
			iter.setModel(model);
			return iter;
		}
		else
		{
			return null;
		}
	}

	/**
	 * Creates a list of path of all selected rows. Additionally, if you are
	 * planning on modifying the model after calling this function, you may
	 * want to convert the returned list into a list of GtkTreeRowReferences.
	 * To do this, you can use gtk_tree_row_reference_new().
	 * To free the return value, use:
	 * g_list_foreach (list, gtk_tree_path_free, NULL);
	 * g_list_free (list);
	 * Since 2.2
	 * Params:
	 *  model = A pointer to set to the GtkTreeModel, or NULL.
	 * Returns:
	 *  A GList containing a GtkTreePath for each selected row.
	 */
	TreePath[] getSelectedRows(out TreeModelIF model)
	{
		TreePath[] paths;
		GtkTreeModel* outmodel = null;
		GList* gList = gtk_tree_selection_get_selected_rows(gtkTreeSelection, &outmodel);
		if ( gList !is null )
		{  
			ListG list = new ListG(gList);
			for ( int i=0 ; i<list.length() ; i++ )
			{
				paths ~= new TreePath(cast(GtkTreePath*)list.nthData(i));
			}
		}
		model = new TreeModel(outmodel);

		return paths;
	}

code: end
outFile: TreeSelection

file: GtkTreeViewColumn.html
struct: GtkTreeViewColumn
class: TreeViewColumn
implements: CellLayoutIF
prefix: gtk_tree_view_column_
import: glib.Str
import: gtk.Button
import: gtk.CellArea
import: gtk.CellRenderer
import: gtk.TreeIter
import: gtk.TreeModelIF
import: gtk.TreeView
import: gtk.Widget
structWrap: GtkCellArea* CellArea
structWrap: GtkCellRenderer* CellRenderer
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkWidget* Widget

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

inout: gtk_tree_view_column_cell_get_size cell_area
out: gtk_tree_view_column_cell_get_size x_offset
out: gtk_tree_view_column_cell_get_size y_offset
out: gtk_tree_view_column_cell_get_size width
out: gtk_tree_view_column_cell_get_size height
out: gtk_tree_view_column_cell_get_position x_offset
out: gtk_tree_view_column_cell_get_position width

#These are also implemented in CellLayoutT
nocode: gtk_tree_view_column_pack_start
nocode: gtk_tree_view_column_pack_end
nocode: gtk_tree_view_column_clear
nocode: gtk_tree_view_column_add_attribute
nocode: gtk_tree_view_column_clear_attributes

nocode: gtk_tree_view_column_get_button
nocode: gtk_tree_view_column_get_tree_view
nocode: gtk_tree_view_column_new_with_attributes

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkTreeViewColumn);

	/**
	 * Creates a new Tree view column
	 * Params:
	 *  header = th column header text
	 *  renderer = the rederer for the column cells
	 *  type = the type of data to be displayed (shouldn't this be on the renderer?)
	 *  column = the column number
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string header, CellRenderer renderer, string type, int column)
	{
		auto p = gtk_tree_view_column_new_with_attributes(
				Str.toStringz(header), 
				renderer.getCellRendererStruct(), 
				Str.toStringz(type),
				column,
				null);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_view_column_new_with_attributes");
		}

		this(p);
	}

	/**
	 * Returns the button used in the treeview column header
	 * Returns: The button for the column header. [transfer none] Since 3.0
	 */
	public Button getButton()
	{
		// GtkWidget * gtk_tree_view_column_get_button (GtkTreeViewColumn *tree_column);
		auto p = gtk_tree_view_column_get_button(gtkTreeViewColumn);
		if(p is null)
		{
			return null;
		}
		return new Button(cast(GtkButton*) p);
	}

	/**
	 * Returns the GtkTreeView wherein tree_column has been inserted.
	 * If column is currently not inserted in any tree view, NULL is
	 * returned.
	 * Since 2.12
	 * Returns: The tree view wherein column has been inserted if any, NULL otherwise. [transfer none]
	 */
	public TreeView getTreeView()
	{
		// GtkWidget * gtk_tree_view_column_get_tree_view (GtkTreeViewColumn *tree_column);
		auto p = gtk_tree_view_column_get_tree_view(gtkTreeViewColumn);
		if(p is null)
		{
			return null;
		}
		return new TreeView(cast(GtkTreeView*) p);
	}
code: end
outFile: TreeViewColumn

file: GtkTreeView.html
struct: GtkTreeView
class: TreeView
implements: ScrollableIF
prefix: gtk_tree_view_
import: cairo.Surface
import: glib.Str
import: glib.ListG
import: gdk.Window
import: gtk.Adjustment
import: gtk.CellRenderer
import: gtk.Entry
import: gtk.Tooltip
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
import: gtk.TreeSelection
import: gtk.TreeViewColumn
structWrap: cairo_surface_t* Surface
structWrap: GList* ListG
structWrap: GdkWindow* Window
structWrap: GtkAdjustment* Adjustment
structWrap: GtkCellRenderer* CellRenderer
structWrap: GtkEntry* Entry
structWrap: GtkTooltip* Tooltip
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath
structWrap: GtkTreeSelection* TreeSelection
structWrap: GtkTreeViewColumn* TreeViewColumn

nocode: gtk_tree_view_get_hadjustment
nocode: gtk_tree_view_set_hadjustment
nocode: gtk_tree_view_get_vadjustment
nocode: gtk_tree_view_set_vadjustment

#imports for Scrollable Interface.
import: gtk.ScrollableT
import: gtk.ScrollableIF

out: gtk_tree_view_get_cursor path
out: gtk_tree_view_get_cursor focus_column
out: gtk_tree_view_get_path_at_pos path
out: gtk_tree_view_get_path_at_pos column
out: gtk_tree_view_get_path_at_pos cell_x
out: gtk_tree_view_get_path_at_pos cell_y
out: gtk_tree_view_is_blank_at_pos path
out: gtk_tree_view_is_blank_at_pos column
out: gtk_tree_view_is_blank_at_pos cell_x
out: gtk_tree_view_is_blank_at_pos cell_y
out: gtk_tree_view_get_cell_area rect
out: gtk_tree_view_get_background_area rect
out: gtk_tree_view_get_visible_rect visible_rect
out: gtk_tree_view_get_visible_range start_path
out: gtk_tree_view_get_visible_range end_path
out: gtk_tree_view_convert_bin_window_to_tree_coords tx
out: gtk_tree_view_convert_bin_window_to_tree_coords ty
out: gtk_tree_view_convert_bin_window_to_widget_coords wx
out: gtk_tree_view_convert_bin_window_to_widget_coords wy
out: gtk_tree_view_convert_tree_to_bin_window_coords bx
out: gtk_tree_view_convert_tree_to_bin_window_coords by
out: gtk_tree_view_convert_tree_to_widget_coords wx
out: gtk_tree_view_convert_tree_to_widget_coords wy
out: gtk_tree_view_convert_widget_to_bin_window_coords bx
out: gtk_tree_view_convert_widget_to_bin_window_coords by
out: gtk_tree_view_convert_widget_to_tree_coords tx
out: gtk_tree_view_convert_widget_to_tree_coords ty
array: gtk_tree_view_enable_model_drag_dest targets n_targets
array: gtk_tree_view_enable_model_drag_source targets n_targets
out: gtk_tree_view_get_drag_dest_row path
out: gtk_tree_view_get_drag_dest_row pos
out: gtk_tree_view_get_dest_row_at_pos path
out: gtk_tree_view_get_dest_row_at_pos pos
inout: gtk_tree_view_get_tooltip_context x
inout: gtk_tree_view_get_tooltip_context y 
out: gtk_tree_view_get_tooltip_context model
out: gtk_tree_view_get_tooltip_context path

code: start
	// add the Scrollable capabilities
	mixin ScrollableT!(GtkTreeView);

	/**
	 * Expands the row of the iter.
	 * Params:
	 *  iter =
	 *  openAll =
	 *  Returns =
	 */
	int expandRow(TreeIter iter, TreeModelIF model, int openAll)
	{
		return expandRow(model.getPath(iter), openAll);
	}

	/**
	 * gets the first selected iter or null if no rows are selected
	 */
	TreeIter getSelectedIter()
	{
		TreeIter iter = null;
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		if ( paths.length > 0 )
		{
			iter = new TreeIter();
			model.getIter(iter,paths[0]);
		}
		return iter;
	}

	/** */
	TreeIter[] getSelectedIters()
	{
		TreeIter[] iters;
		
		TreeIter iter = new TreeIter();
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		foreach ( TreePath p; selection.getSelectedRows(model) )
		{
			if ( model.getIter(iter,p) )
			{
				iters ~= iter;
				iter = new TreeIter();
			}
		}
		
		return iters;
	}

	/**
	 * Inserts a column and sets it's attributes
	 * Params:
	 *  position =
	 *  title =
	 *  renderer =
	 *  editable =
	 * Returns: number of columns including the new one
	 */
	gint insertEditableColumn(int position, string title, CellRenderer renderer, bool editable)
	{
		// OK, this is a trick because of my ignorance on how to pass variable argument lists
		if ( position < 0 )
		{
			position = getColumns().length();
		}
		int tot = gtk_tree_view_insert_column_with_attributes(
			gtkTreeView, 
			position, 
			Str.toStringz(title),
			renderer.getCellRendererStruct(),
			Str.toStringz("text"),position,
			Str.toStringz("editable"),2,0);
		return tot;
	}
code: end
outFile: TreeView

file: gtk3-GtkTreeView-drag-and-drop.html
struct: GtkTreeDragSource
class: TreeDragSourceT
template: TStruct
prefix: gtk_tree_drag_source_
prefix: gtk_tree_
noprefix: gtk_tree_drag_dest_
import: gtk.SelectionData
import: gtk.TreeModelIF
import: gtk.TreeModel
import: gtk.TreePath
structWrap: GtkSelectionData* SelectionData
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath

out: gtk_tree_get_row_drag_data tree_model
out: gtk_tree_get_row_drag_data path

interface: TreeDragSourceIF
outFile: TreeDragSourceT

struct: GtkTreeDragDest
class: TreeDragDestT
template: TStruct
prefix: gtk_tree_drag_dest_
strictPrefix: Y
import: gtk.SelectionData
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkSelectionData* SelectionData
structWrap: GtkTreePath* TreePath

interfaceCode: start
	/**
	 * Sets selection data of target type GTK_TREE_MODEL_ROW. Normally used
	 * in a drag_data_get handler.
	 * Params:
	 * selectionData =  some GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  a row in tree_model
	 * Returns: TRUE if the GtkSelectionData had the proper target type to allow us to set a tree row
	 */
	public static int setRowDragData(SelectionData selectionData, TreeModelIF treeModel, TreePath path);
	
	/**
	 * Obtains a tree_model and path from selection data of target type
	 * GTK_TREE_MODEL_ROW. Normally called from a drag_data_received handler.
	 * This function can only be used if selection_data originates from the same
	 * process that's calling this function, because a pointer to the tree model
	 * is being passed around. If you aren't in the same process, then you'll
	 * get memory corruption. In the GtkTreeDragDest drag_data_received handler,
	 * you can assume that selection data of type GTK_TREE_MODEL_ROW is
	 * in from the current process. The returned path must be freed with
	 * gtk_tree_path_free().
	 * Params:
	 * selectionData =  a GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  row in tree_model
	 * Returns: TRUE if selection_data had target type GTK_TREE_MODEL_ROW and is otherwise valid
	 */
	public static int getRowDragData(SelectionData selectionData, out TreeModelIF treeModel, out TreePath path);
interfaceCode: end
interface: TreeDragDestIF
outFile: TreeDragDestT

file: GtkCellView.html
struct: GtkCellView
class: CellView
implements: CellLayoutIF
implements: OrientableIF
prefix: gtk_cell_view_
import: glib.Str
import: gdk.Color
import: gdk.RGBA
import: gdk.Pixbuf
import: gtk.CellArea
import: gtk.CellAreaContext
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GdkColor* Color
structWrap: GdkRGBA* RGBA
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkCellArea* CellArea
structWrap: GtkCellAreaContext* CellAreaContext
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_cell_view_get_size_of_row requisition

nocode: gtk_cell_view_new_with_text
nocode: gtk_cell_view_new_with_markup

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkCellView);

	// add the Orientable capabilities
	mixin OrientableT!(GtkCellView);

	/**
	 * Creates a new GtkCellView widget, adds a GtkCellRendererText
	 * to it, and makes its show text.
	 * If markup is true the text can be marked up with the Pango text
	 * markup language.
	 * Since 2.6
	 * Params:
	 *  text = the text to display in the cell view
	 * Returns:
	 *  A newly created GtkCellView widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string text, bool markup=true)
	{
		GtkCellView* p;

		if ( markup )
		{
			// GtkWidget* gtk_cell_view_new_with_markup (const gchar *markup);
			p = cast(GtkCellView*)gtk_cell_view_new_with_markup(Str.toStringz(text));
		}
		else
		{
			// GtkWidget* gtk_cell_view_new_with_text (const gchar *text);
			p = cast(GtkCellView*)gtk_cell_view_new_with_text(Str.toStringz(text));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_cell_view_new_with_");
		}

		this(p);
	}
code: end
outFile: CellView

file: GtkIconView.html
struct: GtkIconView
class: IconView
implements: CellLayoutIF
implements: ScrollableIF
prefix: gtk_icon_view_
import: cairo.Surface
import: glib.ListG
import: gtk.CellArea
import: gtk.CellRenderer
import: gtk.Tooltip
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: cairo_surface_t* Surface
structWrap: GList* ListG
structWrap: GtkCellArea* CellArea
structWrap: GtkCellRenderer* CellRenderer
structWrap: GtkTooltip* Tooltip
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

#imports for Scrollable Interface.
import: gtk.ScrollableT
import: gtk.ScrollableIF

out: gtk_icon_view_get_item_at_pos path
out: gtk_icon_view_get_item_at_pos cell
out: gtk_icon_view_convert_widget_to_bin_window_coords bx
out: gtk_icon_view_convert_widget_to_bin_window_coords by
out: gtk_icon_view_get_cursor path
out: gtk_icon_view_get_cursor cell
out: gtk_icon_view_get_visible_range start_path
out: gtk_icon_view_get_visible_range end_path
inout: gtk_icon_view_get_tooltip_context x
inout: gtk_icon_view_get_tooltip_context y
out: gtk_icon_view_get_tooltip_context model
out: gtk_icon_view_get_tooltip_context path
array: gtk_icon_view_enable_model_drag_source targets n_targets
array: gtk_icon_view_enable_model_drag_dest targets n_targets
out: gtk_icon_view_get_drag_dest_item path
out: gtk_icon_view_get_drag_dest_item pos
out: gtk_icon_view_get_dest_item_at_pos path
out: gtk_icon_view_get_dest_item_at_pos pos
out: gtk_icon_view_get_cell_rect rect

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkIconView);

	// add the Scrollable capabilities
	mixin ScrollableT!(GtkIconView);
code: end
outFile: IconView

file: GtkTreeSortable.html
struct: GtkTreeSortable
class: TreeSortableT
template: TStruct
prefix: gtk_tree_sortable_
out: gtk_tree_sortable_get_sort_column_id sort_column_id
out: gtk_tree_sortable_get_sort_column_id order
interface: TreeSortableIF
outFile: TreeSortableT

file: GtkTreeModelSort.html
struct: GtkTreeModelSort
ctorStruct: GtkTreeModel
class: TreeModelSort
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeSortableIF
prefix: gtk_tree_model_sort_
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelSort);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelSort);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeModelSort);
cade: end
outFile: TreeModelSort

file: GtkTreeModelFilter.html
struct: GtkTreeModelFilter
ctorStruct: GtkTreeModel
class: TreeModelFilter
implements: TreeModelIF
implements: TreeDragSourceIF
prefix: gtk_tree_model_filter_
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkTreePath* TreePath

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

array: gtk_tree_model_filter_set_modify_func types n_columns

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelFilter);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelFilter);
cade: end
outFile: TreeModelFilter

file: GtkCellLayout.html
struct: GtkCellLayout
class: CellLayoutT
template: TStruct
prefix: gtk_cell_layout_
import: glib.Str
import: glib.ListG
import: gtk.CellArea
import: gtk.CellRenderer
structWrap: GList* ListG
structWrap: GtkCellArea* CellArea
structWrap: GtkCellRenderer* CellRenderer
interface: CellLayoutIF
outFile: CellLayoutT

file: GtkCellArea.html
struct: GtkCellArea
class: CellArea
implements: BuildableIF
implements: CellLayoutIF
prefix:  gtk_cell_area_
import: std.stdarg
import: cairo.Context
import: glib.Str
import: glib.ListG
import: gobject.ParamSpec
import: gobject.Value
import: gdk.Event
import: gtk.CellAreaContext
import: gtk.CellEditable
import: gtk.CellEditableIF
import: gtk.CellRenderer
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
import: gtk.Widget
structWrap: cairo_t* Context
structWrap: GList* ListG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GdkEvent* Event
structWrap: GtkCellAreaContext* CellAreaContext
structWrap: GtkCellEditable* CellEditableIF
structWrap: GtkCellRenderer* CellRenderer
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

inout: gtk_cell_area_foreach_alloc cell_area
inout: gtk_cell_area_foreach_alloc background_area
inout: gtk_cell_area_event cell_area
inout: gtk_cell_area_render cell_area
inout: gtk_cell_area_render background_area
inout: gtk_cell_area_get_cell_allocation cell_area
out: gtk_cell_area_get_cell_allocation allocation
inout: gtk_cell_area_get_cell_at_position cell_area
out: gtk_cell_area_get_cell_at_position alloc_area
out: gtk_cell_area_get_preferred_width minimum_width
out: gtk_cell_area_get_preferred_width natural_width
out: gtk_cell_area_get_preferred_height_for_width minimum_height
out: gtk_cell_area_get_preferred_height_for_width natural_height
out: gtk_cell_area_get_preferred_height minimum_height
out: gtk_cell_area_get_preferred_height natural_height
out: gtk_cell_area_get_preferred_width_for_height minimum_width
out: gtk_cell_area_get_preferred_width_for_height natural_width
array: gtk_cell_area_class_list_cell_properties Return n_properties
inout: gtk_cell_area_activate cell_area
inout: gtk_cell_area_activate_cell cell_area
inout: gtk_cell_area_inner_cell_area cell_area
out: gtk_cell_area_inner_cell_area inner_area
out: gtk_cell_area_request_renderer minimum_size
out: gtk_cell_area_request_renderer natural_size

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkCellArea);

	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkCellArea);
code: end
outFile: CellArea

file: GtkCellAreaBox.html
struct: GtkCellAreaBox
ctorStruct: GtkCellArea
class: CellAreaBox
implements: OrientableIF
prefix: gtk_cell_area_box_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkCellAreaBox);
code: end
outFile: CellAreaBox

file: GtkCellAreaContext.html
struct: GtkCellAreaContext
class: CellAreaContext
prefix: gtk_cell_renderer_accel_
import: gtk.CellArea
structWrap: GtkCellArea* CellArea

out: gtk_cell_area_context_get_preferred_width minimum_width
out: gtk_cell_area_context_get_preferred_width natural_width
out: gtk_cell_area_context_get_preferred_height minimum_height
out: gtk_cell_area_context_get_preferred_height natural_height
out: gtk_cell_area_context_get_preferred_height_for_width minimum_height
out: gtk_cell_area_context_get_preferred_height_for_width natural_height
out: gtk_cell_area_context_get_preferred_width_for_height minimum_width
out: gtk_cell_area_context_get_preferred_width_for_height natural_width
out: gtk_cell_area_context_get_allocation width
out: gtk_cell_area_context_get_allocation height

outFile: CellAreaContext

file: GtkCellRenderer.html
struct: GtkCellRenderer
class: CellRenderer
prefix: gtk_cell_renderer_
import: cairo.Context
import: glib.Str
import: gdk.Event
import: gtk.CellEditable
import: gtk.CellEditableIF
import: gtk.Widget
structWrap: cairo_t* Context
structWrap: GdkEvent* Event
structWrap: GtkCellEditable* CellEditableIF
structWrap: GtkWidget* Widget

inout: gtk_cell_renderer_get_aligned_area cell_area
out: gtk_cell_renderer_get_aligned_area aligned_area
out: gtk_cell_renderer_get_size x_offset
out: gtk_cell_renderer_get_size y_offset
out: gtk_cell_renderer_get_size width
out: gtk_cell_renderer_get_size height
inout: gtk_cell_renderer_render background_area
inout: gtk_cell_renderer_render cell_area
inout: gtk_cell_renderer_activate background_area
inout: gtk_cell_renderer_activate cell_area
inout: gtk_cell_renderer_start_editing background_area
inout: gtk_cell_renderer_start_editing cell_area
out: gtk_cell_renderer_get_fixed_size width
out: gtk_cell_renderer_get_fixed_size height
out: gtk_cell_renderer_get_alignment xalign
out: gtk_cell_renderer_get_alignment yalign
out: gtk_cell_renderer_get_padding xpad
out: gtk_cell_renderer_get_padding ypad
out: gtk_cell_renderer_get_preferred_height minimum_size
out: gtk_cell_renderer_get_preferred_height natural_size
out: gtk_cell_renderer_get_preferred_height_for_width minimum_height
out: gtk_cell_renderer_get_preferred_height_for_width natural_height
out: gtk_cell_renderer_get_preferred_size minimum_size
out: gtk_cell_renderer_get_preferred_size natural_size
out: gtk_cell_renderer_get_preferred_width minimum_size
out: gtk_cell_renderer_get_preferred_width natural_size
out: gtk_cell_renderer_get_preferred_width_for_height minimum_width
out: gtk_cell_renderer_get_preferred_width_for_height natural_width

outFile: CellRenderer

file: GtkCellEditable.html
struct: GtkCellEditable
class: CellEditableT
template: TStruct
prefix: gtk_cell_editable_
import: gdk.Event
structWrap: GdkEvent* Event
interface: CellEditableIF
outFile: CellEditableT

file:
class: CellEditable
extend: GObject
implements: CellEditableIF

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

code: start
	// Minimal implementation.
	mixin CellEditableT!(GtkCellEditable);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkCellEditable;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkCellEditable* gtkCellEditable)
	{
		super(cast(GObject*)gtkCellEditable);
		this.gtkCellEditable = gtkCellEditable;
	}
code: end
outFile: CellEditable

file: GtkCellRendererAccel.html
struct: GtkCellRendererAccel
ctorStruct: GtkCellRenderer
class: CellRendererAccel
prefix: gtk_cell_renderer_accel_
import: glib.Str
outFile: CellRendererAccel

file: GtkCellRendererCombo.html
struct: GtkCellRendererCombo
ctorStruct: GtkCellRenderer
class: CellRendererCombo
prefix: gtk_cell_renderer_combo_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: CellRendererCombo

file: GtkCellRendererPixbuf.html
struct: GtkCellRendererPixbuf
ctorStruct: GtkCellRenderer
class: CellRendererPixbuf
prefix: gtk_cell_renderer_pixbuf_
outFile: CellRendererPixbuf

file: GtkCellRendererProgress.html
struct:GtkCellRendererProgress
ctorStruct: GtkCellRenderer
class: CellRendererProgress
implements: OrientableIF
prefix: gtk_cell_renderer_progress_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkCellRenderer);
code: end
outFile: CellRendererProgress

file: GtkCellRendererSpin.html
struct: GtkCellRendererSpin
ctorStruct: GtkCellRenderer
class: CellRendererSpin
prefix: gtk_cell_renderer_spin_
outFile: CellRendererSpin

file: GtkCellRendererText.html
struct: GtkCellRendererText
ctorStruct: GtkCellRenderer
class: CellRendererText
prefix: gtk_cell_renderer_text_
import: glib.Str
outFile: CellRendererText

file: GtkCellRendererToggle.html
struct: GtkCellRendererToggle
ctorStruct: GtkCellRenderer
class: CellRendererToggle
prefix: gtk_cell_renderer_toggle_
import: glib.Str
outFile: CellRendererToggle

file: GtkCellRendererSpinner.html
struct: GtkCellRendererSpinner
ctorStruct: GtkCellRenderer
class: CellRendererSpinner
prefix: gtk_cell_renderer_spinner_
outFile: CellRendererSpinner

file:
code: start
	/**
	 * TreeNode interface
	 */
	public interface TreeNode
	{
		string getNodeValue(int column);
		int columnCount();
	}
code: end
outFile: TreeNode

file: GtkListStore.html
struct: GtkListStore
class: ListStore
implements: BuildableIF
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_list_store_
import: glib.Str
import: gobject.Value
import: gtk.TreeIter
import: gtk.TreeModel
structWrap: GValue* Value
structWrap: GtkTreeIter* TreeIter

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_list_store_newv types n_columns
array: gtk_list_store_set_column_types types n_columns
array: gtk_list_store_set_valuesv values n_values
array: gtk_list_store_set_valuesv columns n_values
array: gtk_list_store_insert_with_valuesv values n_values
array: gtk_list_store_insert_with_valuesv columns n_values
array: gtk_list_store_reorder new_order

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkListStore);

	// add the TreeModel capabilities
	mixin TreeModelT!(GtkListStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkListStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkListStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkListStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter()
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_list_store_append(getListStoreStruct(), iter);
		return new TreeIter(iter);
	}
	
	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int[] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** ditto */
	void set(TreeIter iter, int[] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/** */
	void setValue(TreeIter iter, int column, string value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
		//gtk_list_store_set_value(obj(), iter.getIter(), column, (GValue*)cChar(value));
	}

	/** */
	void setValue(TreeIter iter, int column, int value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}

code: end
outFile: ListStore

file: GtkTreeStore.html
struct: GtkTreeStore
class: TreeStore
implements: BuildableIF
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_tree_store_

structWrap: GValue* Value
structWrap: GtkTreeIter* TreeIter

import: glib.Str
import: gtk.TreeIter
import: gobject.Value
import: gtk.TreeNode
import: gdk.Pixbuf;
import: gobject.Value;

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_tree_store_newv types n_columns
array: gtk_tree_store_set_column_types types n_columns
array: gtk_tree_store_set_valuesv columns n_values
array: gtk_tree_store_set_valuesv values n_values
array: gtk_tree_store_insert_with_valuesv columns n_values
array: gtk_tree_store_insert_with_valuesv values n_values
array: gtk_tree_store_reorder new_order

nocode: gtk_tree_store_set

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkTreeStore);

	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkTreeStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter(TreeIter parent=null)
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_tree_store_append(getTreeStoreStruct(), iter, (parent is null) ? null : parent.getTreeIterStruct());
		return new TreeIter(iter);
	}
	
	/**
	 * Sets one value into one cells.
	 * \todo confirm we need to destroy the Value instance
	 * Params:
	 *  iter = the tree iteractor, effectivly the row
	 *  column = to column number to set
	 *  value = the value
	 */
	void setValue(TreeIter iter, int column, string value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, Str.toStringz(value) , -1);
	}

	/** ditto */
	void setValue(TreeIter iter, int column, int value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, value, -1);
	}

	/** ditto */
	//TODO: confirm we need to destroy the Value instance
	void setValue(TreeIter iter, int column, Pixbuf pixbuf)
	{
		Value v = new Value(pixbuf);
		gtk_tree_store_set_value(gtkTreeStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}

	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int[] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** ditto */
	void set(TreeIter iter, int[] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/**
	 * Sets an iteractor values from a tree node.
	 * This is the way to add a new row to the tree,
	 * the iteractor is either a top level iteractor created from createIter()
	 * or a nested iteractor created from append()
	 * Params:
	 *  iter = the iteractor to set
	 *  treeNode = the tree node
	 * See_Also: createIter(), append()
	 */
	void set(TreeIter iter, TreeNode treeNode)
	{
		int[] cols;
		string[] vals;
		for ( int i=0 ; i<treeNode.columnCount() ; i++ )
		{
			//printf(">>>>>>>>>>>>> requesting value for %d\n",i);
			cols ~= i;
			string value = treeNode.getNodeValue(i);
			if ( value  is  null )
			{
				vals ~= "";
			}
			else
			{
				vals ~= value;
			}
		}
		set(iter, cols, vals);				
	}


	/**
	 * Creates and prepends a new row to tree_store. If parent is non-NULL, then it will prepend
	 * the new row before the first child of parent, otherwise it will prepend a row
	 * to the top level. iter will be changed to point to this new row. The row
	 * will be empty after this function is called. To fill in values, you need to
	 * call gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter prepend(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_prepend (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_prepend(gtkTreeStore, iter.getTreeIterStruct(), (parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
	
	/**
	 * Creates and appends a new row to tree_store. If parent is non-NULL, then it will append the
	 * new row after the last child of parent, otherwise it will append a row to
	 * the top level. iter will be changed to point to this new row. The row will
	 * be empty after this function is called. To fill in values, you need to call
	 * gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter append(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_append (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_append(gtkTreeStore, 
			iter.getTreeIterStruct(), 
			(parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
code: end
outFile: TreeStore


###########################################################
### Menus, Combo Box, Toolbar #############################
###########################################################

file: GtkComboBox.html
struct: GtkComboBox
class: ComboBox
implements: CellLayoutIF
implements: CellEditableIF
prefix: gtk_combo_box_
import: atk.ObjectAtk
import: glib.Str
import: gdk.Device
import: gtk.CellArea
import: gtk.TreeIter
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: AtkObject* ObjectAtk
structWrap: GdkDevice* Device
structWrap: GtkCellArea* CellArea
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeModel* TreeModelIF

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

nocode: gtk_combo_box_new
nocode: gtk_combo_box_new_with_entry
nocode: gtk_combo_box_new_with_model
nocode: gtk_combo_box_new_with_model_and_entry
nocode: gtk_combo_box_new_with_area
nocode: gtk_combo_box_new_with_area_and_entry

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkComboBox);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkComboBox);

	/**
	 * Creates a new empty GtkComboBox.
	 * Params:
	 *   entry = If true, create an empty ComboBox with an entry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool entry=true)
	{
		GtkComboBox* p;
		if ( entry )
		{
			// GtkWidget* gtk_combo_box_new_text (void);
			p = cast(GtkComboBox*)gtk_combo_box_new_with_entry();
		}
		else
		{
			// GtkWidget* gtk_combo_box_new (void);
			p = cast(GtkComboBox*)gtk_combo_box_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}

	/**
	 * Creates a new GtkComboBox with the model initialized to model.
	 * Params:
	 *   model = A GtkTreeModel.
	 *   entry = If true, create an empty ComboBox with an entry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (TreeModelIF model, bool entry=true)
	{
		GtkComboBox* p;
		if ( entry )
		{
			// GtkWidget* gtk_combo_box_new_with_model_and_entry (GtkTreeModel *model);
			p = cast(GtkComboBox*)gtk_combo_box_new_with_model_and_entry((model is null) ? null : model.getTreeModelTStruct());
		}
		else
		{
			// GtkWidget* gtk_combo_box_new_with_model (GtkTreeModel *model);
			p = cast(GtkComboBox*)gtk_combo_box_new_with_model((model is null) ? null : model.getTreeModelTStruct());
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}

	/**
	 * Creates a new empty GtkComboBox using area to layout cells.
	 * Params:
	 *   area = the GtkCellArea to use to layout cell renderers.
	 *   entry = If true, create an empty ComboBox with an entry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (CellArea area, bool entry=true)
	{
		GtkComboBox* p;
		if ( entry )
		{
			// GtkWidget* gtk_combo_box_new_with_area_and_entry (GtkCellArea *area);
			p = cast(GtkComboBox*)gtk_combo_box_new_with_area_and_entry((area is null) ? null : area.getCellAreaStruct());
		}
		else
		{
			// GtkWidget* gtk_combo_box_new_with_area (GtkCellArea* area);
			p = cast(GtkComboBox*)gtk_combo_box_new_with_area((area is null) ? null : area.getCellAreaStruct());
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}
code: end
outFile: ComboBox

file: GtkComboBoxText.html
struct: GtkComboBoxText
class: ComboBoxText
prefix: gtk_combo_box_text_
import: glib.Str
import: gobject.Signals
import: gtk.TreeIter
import: gtk.TreeModelIF

override: removeAll

nocode: gtk_combo_box_text_new
nocode: gtk_combo_box_text_new_with_entry

code: start
	/**
	 * Creates a new ComboBoxText, which is a ComboBox just displaying strings.
	 * Params:
	 *   entry = If true, create an ComboBox with an entry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool entry=true)
	{
		GtkComboBoxText* p;
		if ( entry )
		{
			// GtkWidget* gtk_combo_box_text_new_with_entry (void);
			p = cast(GtkComboBoxText*)gtk_combo_box_text_new_with_entry();
		}
		else
		{
			// GtkWidget* gtk_combo_box_text_new (void);
			p = cast(GtkComboBoxText*)gtk_combo_box_text_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}

	/** */
	public void setActiveText(string text, bool insert=false)
	{
		int active = 0;
		setActive(0);
		while ( getActive >= 0 ) // returns -1 if end of list if reached
		{
			if( text == getActiveText() ) return;
			++active;
			setActive(active);
		}
		// was not found, the combo has now nothing selected
		if ( insert )
		{
			append("", text);
			setActive(active);
		}
	}
	
	/** */
	int getIndex(string text)
	{
		TreeIter iter = new TreeIter();
		TreeModelIF model = getModel();
		iter.setModel(model);
		int index = 0;
		bool found = false;
		bool end = false;
		if ( model.getIterFirst(iter) )
		{
			while ( !end && iter !is  null && !found )
			{
				found = iter.getValueString(0) == text;
				if ( !found )
				{
					end = !model.iterNext(iter);
					++index;
				}
			}
		}
		else
		{
			end = true;
		}
		return end ? -1 : index;
	}
	
	/** */
	void prependOrReplaceText(string text)
	{
		int index = getIndex(text);
		if ( index > 0 )
		{
			remove(index);
			prepend("", text);
		}
		else if ( index == -1 )
		{
			prepend("", text);
		}
	}
code: end
openFile: ComboBoxText

file: GtkComboBox.html
strictPrefix: Y
prefix: none
closeFile: ComboBoxText

file: GtkMenu.html
struct: GtkMenu
class: Menu
prefix: gtk_menu_
import: glib.Str
import: glib.ListG
import: gio.MenuModel
import: gdk.Device
import: gdk.Screen
import: gtk.AccelGroup
import: gtk.MenuItem
import: gtk.Widget
structWrap: GList* ListG
structWrap: GMenuModel* MenuModel
structWrap: GdkDevice* Device
structWrap: GdkScreen* Screen
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkWidget* Widget

code: start
	/**
	 * Popups up this menu
	 * Params:
	 *  button = you can pass a button number here
	 *  activateTime = you can pass the time from an event here
	 */
	void popup(guint button, guint32 activateTime)
	{
		popup(null, null, null, null, button, activateTime);
	}
	
	/**
	 * Creates and append a submenu to this menu.
	 * This menu item that actualy has the sub menu is also created.
	 * Params:
	 *  label = the sub menu item label
	 * Returns: the new menu
	 */
	Menu appendSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}

	/** */
	void appendSubmenu(string label, Menu submenu)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		item.setSubmenu(submenu);
	}

	/** */
	Menu prependSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		prepend(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}
code: end
outFile: Menu

file: GtkMenuBar.html
struct: GtkMenuBar
class: MenuBar
prefix: gtk_menu_bar_
import: gio.MenuModel
import: gtk.Menu
import: gtk.MenuItem
import: gtk.Widget
structWrap: GMenuModel* MenuModel

code: start
	/** */
	Menu append(string label, bool rightJustify=false)
	{
		MenuItem item = new MenuItem(label);
		super.append(item);
		item.setRightJustified(rightJustify);
		Menu menu= new Menu();
		item.setSubmenu(menu);
		return menu;
	}

	/** */
	public override void append(Widget widget) 
	{ 
		super.append(widget); 
	}
code: end
outFile: MenuBar

file: GtkMenuItem.html
struct: GtkMenuItem
class: MenuItem
implements: ActivatableIF
prefix: gtk_menu_item_
import: glib.Str
import: gtk.AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

nocode: gtk_menu_item_new_with_label
nocode: gtk_menu_item_new_with_mnemonic

alias: activate itemActivate

inout: gtk_menu_item_toggle_size_request requisition

code: start
	/** store the action code passed in by the applcation */
	private string actionLabel;

	// add the Activatable capabilities
	mixin ActivatableT!(GtkMenuItem);
	
	/** Gets the application set action code */
	public string getActionName()
	{
		if ( actionLabel is null )
		{
			actionLabel = "";
		}
		return actionLabel;
	}
	
	/**
	 * Creates a new menu item with a label and a listener and a action.
	 * used for backward compatibily with DUI.
	 */
	this(string label, void delegate(MenuItem)dlg, string action)
	{
		this(label);
		this.actionLabel = action;
		addOnActivate(dlg);
	}

	/**
	 * Creates a new Item associated with a "activate" delegate and with a action code
	 * and optionally accelGroup
	 */
	public this(void delegate(MenuItem) dlg, string label, string action, 
				bool mnemonic=true,
				AccelGroup accelGroup=null,
				char accelKey='\0',
				GdkModifierType modifierType=GdkModifierType.CONTROL_MASK,
				GtkAccelFlags accelFlags=GtkAccelFlags.VISIBLE
				)
	{
		this(label, mnemonic);
		this.actionLabel = action;
		addOnActivate(dlg);
		if ( accelGroup !is null && accelKey != '\0' )
		{
			addAccelerator("activate",accelGroup,accelKey,modifierType,accelFlags); 
		}
	}

	/**
	 * Creates a new Item associated with a "activate" delegate
	 */
	public this(void delegate(MenuItem) dlg, string label, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnActivate(dlg);
	}

	/**
	 * Creates a new GtkMenuItem whose child is a GtkLabel.
	 * Params:
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_item_new_with_");
		}

		this(p);

		setName(label);
	}	
code: end
outFile: MenuItem

file: GtkImageMenuItem.html
struct: GtkImageMenuItem
class: ImageMenuItem
prefix: gtk_image_menu_item_
import: glib.Str
import: gtk.AccelGroup
import: gtk.Widget
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkWidget* Widget

nocode: gtk_image_menu_item_new_with_label
nocode: gtk_image_menu_item_new_with_mnemonic
nocode: gtk_image_menu_item_new_from_stock

code: start
	/**
	 * Creates a new GtkImageMenuItem containing a label.
	 * If mnemonic it true the label will be created using
	 * gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * Params:
	 *  label = the text of the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkImageMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_image_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_image_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_with_");
		}

		this(p);
	}

	/**
	 * Creates a new GtkImageMenuItem containing the image and text from a
	 * stock item.
	 * If you want this menu item to have changeable accelerators, then pass in
	 * null for accelGroup. Next call setAccelPath() with an appropriate path
	 * for the menu item, use gtk.StockItem.StockItem.lookup() to look up the
	 * standard accelerator for the stock item, and if one is found, call
	 * gtk.AccelMap.AccelMap.addEntry() to register it.
	 * Params:
	 *   StockID    = the name of the stock item
	 *   accelGroup = the GtkAccelGroup to add the menu items accelerator to,
	 *                or NULL.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, AccelGroup accelGroup)
	{
		// GtkWidget* gtk_image_menu_item_new_from_stock (const gchar *stock_id,  GtkAccelGroup *accel_group);
		auto p = gtk_image_menu_item_new_from_stock(Str.toStringz(StockDesc[stockID]), (accelGroup is null) ? null : accelGroup.getAccelGroupStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_from_stock");
		}
		this(cast(GtkImageMenuItem*) p);
	}
code: end
outFile: ImageMenuItem

file: GtkRadioMenuItem.html
struct: GtkRadioMenuItem
class: RadioMenuItem
prefix: gtk_radio_menu_item_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioMenuItem* RadioMenuItem

nocode: gtk_radio_menu_item_new_with_label
nocode: gtk_radio_menu_item_new_with_mnemonic
nocode: gtk_radio_menu_item_new_with_mnemonic_from_widget
nocode: gtk_radio_menu_item_new_with_label_from_widget

code: start
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * The new GtkRadioMenuItem is added to the same group as group.
	 * If mnemonic is true the label will be
	 * created using gtk_label_new_with_mnemonic(), so underscores in label
	 * indicate the mnemonic for the menu item.
	 * Since 2.4
	 * Params:
	 *  group = an existing GtkRadioMenuItem
	 *  label = the text for the label
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioMenuItem radioMenuItem, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * Params:
	 *  group = the group to which the radio menu item is to be attached
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
code: end
outFile: RadioMenuItem

file: GtkCheckMenuItem.html
struct: GtkCheckMenuItem
class: CheckMenuItem
prefix: gtk_check_menu_item_
import: glib.Str

nocode: gtk_check_menu_item_new_with_label
nocode: gtk_check_menu_item_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckMenuItem with a label.
	 * Params:
	 *  label = the string to use for the label.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_menu_item_new_with_");
		}

		this(p);
	}
code: end
outFile: CheckMenuItem

file: GtkSeparatorMenuItem.html
struct: GtkSeparatorMenuItem
class: SeparatorMenuItem
prefix: gtk_separator_menu_item_
outFile: SeparatorMenuItem

file: GtkTearoffMenuItem.html
struct: GtkTearoffMenuItem
class: TearoffMenuItem
prefix: gtk_tearoff_menu_item_
outFile: TearoffMenuItem

file: GtkToolShell.html
struct: GtkToolShell
class: ToolShellT
template: TStruct
prefix: gtk_tool_shell_
import: gtk.SizeGroup
structWrap: GtkSizeGroup* SizeGroup
alias: getStyle getToolBarStyle
nocode: gtk_tool_shell_get_orientation
interfaceCode: start
	/**
	 * Retrieves the current orientation for the tool shell. Tool items must not
	 * call this function directly, but rely on gtk_tool_item_get_orientation()
	 * instead.
	 * Since 2.14
	 * Returns: the current orientation of shell
	 */
	public GtkOrientation getOrientation();
interfaceCode: end
interface: ToolShellIF
outFile: ToolShellT

file: GtkToolbar.html
struct: GtkToolbar
class: Toolbar
implements: OrientableIF
implements: ToolShellIF
prefix: gtk_toolbar_
import: glib.Str
import: gtk.Button
import: gtk.ToolItem
import: gtk.Widget
structWrap: GtkToolItem* ToolItem

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT
nocode: gtk_toolbar_set_orientation
nocode: gtk_toolbar_get_orientation

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT
nocode: gtk_toolbar_get_icon_size
nocode: gtk_toolbar_get_relief_style

alias: getStyle getToolbarStyle

nocode: gtk_toolbar_insert

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolbar);

	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolbar);

	/**
	 * Insert a GtkToolItem into the toolbar at position pos.
	 * If pos is 0 the item is prepended to the start of the toolbar. If pos is negative, the item is appended to the end of the toolbar.
	 * Since 2.4 
	 * Params:
	 * toolItem  = a GtkToolItem
	 * pos = the position of the new item
	 */
	public void insert(ToolItem toolItem, int pos=-1)
	{
		gtk_toolbar_insert(gtkToolbar, toolItem.getToolItemStruct(), pos);
	}
code: end
outFile: Toolbar

file: GtkToolItem.html
struct: GtkToolItem
class: ToolItem
implements: ActivatableIF
prefix: gtk_tool_item_
import: glib.Str
import: gtk.SizeGroup
import: gtk.Widget
structWrap: GtkSizeGroup* SizeGroup
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

override: setTooltipText
override: setTooltipMarkup

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkToolItem);
code: end
outFile: ToolItem

file: GtkToolPalette.html
struct: GtkToolPalette
ctorStruct: GtkWidget
class: ToolPalette
implements: OrientableIF
implements: ScrollableIF
prefix: gtk_tool_palette_
import: glib.Str
import: gtk.Adjustment
import: gtk.SelectionData
import: gtk.TargetEntry
import: gtk.ToolItem
import: gtk.ToolItemGroup
import: gtk.Widget
structWrap: GtkAdjustment* Adjustment
structWrap: GtkSelectionData* SelectionData
structWrap: GtkTargetEntry* TargetEntry
structWrap: GtkToolItem* ToolItem
structWrap: GtkToolItemGroup* ToolItemGroup
structWrap: GtkWidget* Widget

nocode: gtk_tool_palette_get_hadjustment
nocode: gtk_tool_palette_get_vadjustment

alias: getStyle getToolbarStyle

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

#imports for Scrollable Interface.
import: gtk.ScrollableIF
import: gtk.ScrollableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolPalette);

	// add the Scrollable capabilities
	mixin ScrollableT!(GtkToolPalette);
code: end
outFile: ToolPalette

file: GtkToolItemGroup.html
struct: GtkToolItemGroup
ctorStruct: GtkWidget
class: ToolItemGroup
implements: ToolShellIF
prefix: gtk_tool_item_group_
import: glib.Str
import: gtk.ToolItem
import: gtk.Widget
structWrap: GtkToolItem* ToolItem
structWrap: GtkWidget* Widget

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT

code: start
	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolItemGroup);

	/**
	 * Retrieves the current orientation for the tool shell. Tool items must not
	 * call this function directly, but rely on gtk_tool_item_get_orientation()
	 * instead.
	 * Since 2.14
	 * Returns: the current orientation of shell
	 */
	public GtkOrientation getOrientation()
	{
		// GtkOrientation gtk_tool_shell_get_orientation (GtkToolShell *shell);
		return gtk_tool_shell_get_orientation(getToolShellTStruct());
	}
code: end
outFile: ToolItemGroup

file: GtkSeparatorToolItem.html
struct: GtkSeparatorToolItem
ctorStruct: GtkToolItem
class: SeparatorToolItem
prefix: gtk_separator_tool_item_
outFile: SeparatorToolItem

file: GtkToolButton.html
struct: GtkToolButton
ctorStruct: GtkToolItem
class: ToolButton
implements: ActionableIF
prefix: gtk_tool_button_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Actionable Interface.
import: gtk.ActionableIF
import: gtk.ActionableT

code: start
	// add the Actionable capabilities
	mixin ActionableT!(GtkToolButton);

	/** */
	public this (StockID stockID)
	{
		this(StockDesc[stockID]);
	}
code: end
outFile: ToolButton

file: GtkMenuToolButton.html
struct: GtkMenuToolButton
ctorStruct: GtkToolItem
class: MenuToolButton
prefix: gtk_menu_tool_button_
import: glib.Str
import: gtk.Menu
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_menu_tool_button_get_menu

code: start
	/**
	 * Creates a new GtkMenuToolButton.
	 * The new GtkMenuToolButton will contain an icon and label from
	 * the stock item indicated by stockID.
	 * Since 2.6
	 * Params:
	 * stockID = the name of a stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(StockID stockId)
	{
		this(StockDesc[stockId]);
	}

	/**
	 * Gets the GtkMenu associated with GtkMenuToolButton.
	 * Since 2.6
	 * Params:
	 *  button = a GtkMenuToolButton
	 * Returns:
	 *  the GtkMenu associated with GtkMenuToolButton
	 */
	public Menu getMenu()
	{
		// GtkWidget* gtk_menu_tool_button_get_menu (GtkMenuToolButton *button);
		auto p =  gtk_menu_tool_button_get_menu(gtkMenuToolButton);
		if(p is null)
		{
			return null;
		}
		return new Menu(cast(GtkMenu*)p);
	}
code: end
outFile: MenuToolButton

file: GtkToggleToolButton.html
struct: GtkToggleToolButton
ctorStruct: GtkToolItem
class: ToggleToolButton
prefix: gtk_toggle_tool_button_
import: glib.Str

code: start
	/**
	 * Creates a new GtkToggleToolButton containing the image and text
	 * from a stock item.
	 */
	public this(StockID stockId)
	{
		this(StockDesc[stockId]);
	}
code: end
outFile: ToggleToolButton

file: GtkRadioToolButton.html
struct: GtkRadioToolButton
ctorStruct: GtkToolItem
class: RadioToolButton
prefix: gtk_radio_tool_button_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioToolButton* RadioToolButton
outFile: RadioToolButton

###########################################################
### Action-based menus and toolbars #######################
###########################################################

file: GtkUIManager.html
struct: GtkUIManager
class: UIManager
implements: BuildableIF
prefix: gtk_ui_manager_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: glib.ListSG
import: gtk.Action
import: gtk.ActionGroup
import: gtk.AccelGroup
import: gtk.Widget
structWrap: GList* ListG
structWrap: GSList* ListSG
structWrap: GtkAction* Action
structWrap: GtkActionGroup* ActionGroup
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

array: gtk_ui_manager_add_ui_from_string buffer length

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkUIManager);
code: end
outFile: UIManager

file: GtkActionGroup.html
struct: GtkActionGroup
class: ActionGroup
implements: BuildableIF
prefix: gtk_action_group_
import: glib.Str
import: glib.ListG
import: gtk.AccelGroup
import: gtk.Action
import: gtk.Widget
structWrap: GList* ListG
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkAction* Action
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

array: gtk_action_group_add_actions entries n_entries
array: gtk_action_group_add_actions_full entries n_entries
array: gtk_action_group_add_toggle_actions entries n_entries
array: gtk_action_group_add_toggle_actions_full entries n_entries
array: gtk_action_group_add_radio_actions entries n_entries
array: gtk_action_group_add_radio_actions_full entries n_entries

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkActionGroup);
code: end
outFile: ActionGroup

file: GtkAction.html
struct: GtkAction
class: Action
implements: BuildableIF
prefix: gtk_action_
import: glib.Str
import: gio.Icon
import: gio.IconIF
import: gobject.Closure
import: glib.ListSG
import: gtk.AccelGroup
import: gtk.Image
import: gtk.Menu
import: gtk.MenuItem
import: gtk.ToolItem
import: gtk.Widget
structWrap: GIcon* IconIF
structWrap: GClosure* Closure
structWrap: GSList* ListSG
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

nocode: gtk_action_get_stock_id
nocode: gtk_action_create_icon
nocode: gtk_action_create_menu_item
nocode: gtk_action_create_tool_item
nocode: gtk_action_create_menu

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkAction);

	/**
	 * Creates a new GtkAction object. To add the action to a
	 * GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * See the section called UI Definitions for information on allowed action
	 * names.
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockId =  the stock icon to display in widgets representing the
	 *  action.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId()
	{
		// const gchar * gtk_action_get_stock_id (GtkAction *action);
		string id = Str.toString(gtk_action_get_stock_id(gtkAction));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(StockID stockId)
	{
		setStockId(StockDesc[stockId]);
	}

	/**
	 * This function is intended for use by action implementations to
	 * create icons displayed in the proxy widgets.
	 * Since 2.4
	 * Params:
	 * iconSize = the size of the icon that should be created. [type int]
	 * Returns: a widget that displays the icon for this action.
	 */
	public Image createIcon(GtkIconSize iconSize)
	{
		// GtkWidget * gtk_action_create_icon (GtkAction *action,  GtkIconSize icon_size);
		auto p = gtk_action_create_icon(gtkAction, iconSize);
		if(p is null)
		{
			return null;
		}
		return new Image(cast(GtkImage*) p);
	}
	
	/**
	 * Creates a menu item widget that proxies for the given action.
	 * Since 2.4
	 * Returns: a menu item connected to the action.
	 */
	public MenuItem createMenuItem()
	{
		// GtkWidget * gtk_action_create_menu_item (GtkAction *action);
		auto p = gtk_action_create_menu_item(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new MenuItem(cast(GtkMenuItem*) p);
	}
	
	/**
	 * Creates a toolbar item widget that proxies for the given action.
	 * Since 2.4
	 * Returns: a toolbar item connected to the action.
	 */
	public ToolItem createToolItem()
	{
		// GtkWidget * gtk_action_create_tool_item (GtkAction *action);
		auto p = gtk_action_create_tool_item(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new ToolItem(cast(GtkToolItem*) p);
	}
	
	/**
	 * If action provides a GtkMenu widget as a submenu for the menu
	 * item or the toolbar item it creates, this function returns an
	 * instance of that menu.
	 * Since 2.12
	 * Returns: the menu item provided by the action, or NULL.
	 */
	public Menu createMenu()
	{
		// GtkWidget * gtk_action_create_menu (GtkAction *action);
		auto p = gtk_action_create_menu(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new Menu(cast(GtkMenu*) p);
	}
code: end
outFile: Action

file: GtkToggleAction.html
struct: GtkToggleAction
class: ToggleAction
prefix: gtk_toggle_action_
import: glib.Str

code: start
/**
	 * Creates a new GtkToggleAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for the action, or NULL
	 * stockId =  The stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}
code: end
outFile: ToggleAction

file: GtkRadioAction.html
struct: GtkRadioAction
class: RadioAction
prefix: gtk_radio_action_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG

code: start
	/**
	 * Creates a new GtkRadioAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for this action, or NULL
	 * stockId =  The stock icon to display in widgets representing this
	 *  action, or NULL
	 * value =  The value which gtk_radio_action_get_current_value() should
	 *  return if this action is selected.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId, int value)
	{
		this(name, label, tooltip, StockDesc[stockId], value);
	}
code: end
outFile: RadioAction

file: GtkRecentAction.html
struct: GtkRecentAction
ctorStruct: GtkAction
class: RecentAction
prefix: gtk_recent_action_
prefix: gtk_
import: glib.Str
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

code: start
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID)
	{
		this(name, label, tooltip, StockDesc[stockID]);
	}
	
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * manager =  a GtkRecentManager, or NULL for using the default
	 *  GtkRecentManager
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID, RecentManager manager)
	{
		this(name, label, tooltip, StockDesc[stockID], manager);
	}
code: end
outFile: RecentAction

file: GtkActivatable.html
struct: GtkActivatable
class: ActivatableT
template: TStruct
prefix: gtk_activatable_
import: gtk.Action
structWrap: GtkAction* Action
interface: ActivatableIF
outFile: ActivatableT

###########################################################
###  Selectors (File/Font/Color/Input Devices) ############
###########################################################

file: GtkColorChooser.html
struct: GtkColorChooser
class: ColorChooserT
template: TStruct
prefix: gtk_color_chooser_
import: gdk.RGBA
structWrap: GdkRGBA* RGBA

nocode: gtk_color_chooser_add_palette
interfaceCode: start
	/**
	 * Adds a palette to the color chooser. If orientation is horizontal,
	 * the colors are grouped in rows, with colorsPerPine colors
	 * in each row. If horizontal is false, the colors are grouped
	 * in columns instead.
	 * 
	 * The default color palette of ColorChooserWidget has
	 * 27 colors, organized in columns of 3 colors. The default gray
	 * palette has 9 grays in a single row.
	 * 
	 * The layout of the color chooser widget works best when the
	 * palettes have 9-10 columns.
	 * 
	 * Calling this function for the first time has the
	 * side effect of removing the default color and gray palettes
	 * from the color chooser.
	 * 
	 * If colors is null, removes all previously added palettes.
	 * 
	 * Params:
	 *     orientation   = Orientation.HORIZONTAL if the palette should
	 *                     be displayed in rows, Orientation.VERTICAL for columns
	 *     colorsPerLine = the number of colors to show in each row/column
	 *     colors        = the colors of the palette, or null.
	 * Since 3.4
	 */
	public void addPalette(GtkOrientation orientation, int colorsPerLine, RGBA[] colors);	
interfaceCode: end
code: start
	/**
	 * Adds a palette to the color chooser. If orientation is horizontal,
	 * the colors are grouped in rows, with colorsPerPine colors
	 * in each row. If horizontal is false, the colors are grouped
	 * in columns instead.
	 * 
	 * The default color palette of ColorChooserWidget has
	 * 27 colors, organized in columns of 3 colors. The default gray
	 * palette has 9 grays in a single row.
	 * 
	 * The layout of the color chooser widget works best when the
	 * palettes have 9-10 columns.
	 * 
	 * Calling this function for the first time has the
	 * side effect of removing the default color and gray palettes
	 * from the color chooser.
	 * 
	 * If colors is null, removes all previously added palettes.
	 * 
	 * Params:
	 *     orientation   = Orientation.HORIZONTAL if the palette should
	 *                     be displayed in rows, Orientation.VERTICAL for columns
	 *     colorsPerLine = the number of colors to show in each row/column
	 *     colors        = the colors of the palette, or null.
	 * Since 3.4
	 */
	public void addPalette(GtkOrientation orientation, int colorsPerLine, RGBA[] colors)
	{
		GdkRGBA*[] cColors = new GdkRGBA*[colors.length];

		foreach( i, color; colors )
		{
			cColors[i] = color.getRGBAStruct();
		}

		// void gtk_color_chooser_add_palette (GtkColorChooser *chooser,  GtkOrientation orientation,  gint colors_per_line,  gint n_colors,  GdkRGBA *colors);
		gtk_color_chooser_add_palette(getColorChooserTStruct(), orientation, colorsPerLine, cast(int) colors.length, cColors[0]);
	}
code: end
interface: ColorChooserIF
outFile: ColorChooserT

file: GtkColorButton.html
struct: GtkColorButton
class: ColorButton
implements: ColorChooserIF
prefix: gtk_color_button_
import: glib.Str
import: gdk.Color
import: gdk.RGBA
structWrap: GdkColor* Color
structWrap: GdkRGBA* RGBA

nocode: gtk_color_button_set_rgba
nocode: gtk_color_button_get_rgba
nocode: gtk_color_button_set_use_alpha
nocode: gtk_color_button_get_use_alpha

#imports for ColorChooser Interface.
import: gtk.ColorChooserIF
import: gtk.ColorChooserT

code: start
	// add the ColorChooser capabilities
	mixin ColorChooserT!(GtkColorButton);
code: end
outFile: ColorButton

file: GtkColorChooserWidget.html
struct: GtkColorChooserWidget
class: ColorChooserWidget
implements: ColorChooserIF
prefix: gtk_color_chooser_widget_

#imports for ColorChooser Interface.
import: gtk.ColorChooserIF
import: gtk.ColorChooserT

code: start
	// add the ColorChooser capabilities
	mixin ColorChooserT!(GtkColorChooserWidget);
code: end
outFile: ColorChooserWidget

file: GtkColorChooserDialog.html
struct: GtkColorChooserDialog
class: ColorChooserDialog
implements: ColorChooserIF
prefix: gtk_color_chooser_dialog_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window

#imports for ColorChooser Interface.
import: gtk.ColorChooserIF
import: gtk.ColorChooserT

code: start
	// add the ColorChooser capabilities
	mixin ColorChooserT!(GtkColorChooserDialog);
code: end
outFile: ColorChooserDialog

file: GtkColorSelection.html
struct: GtkColorSelection
class: ColorSelection
prefix: gtk_color_selection_
import: glib.Str
import: gdk.Color
import: gdk.RGBA
structWrap: GdkColor* Color
structWrap: GdkRGBA* RGBA

out: gtk_color_selection_palette_from_string colors
array: gtk_color_selection_palette_from_string colors n_colors
array: gtk_color_selection_palette_to_string colors n_colors
outFile: ColorSelection

file: GtkColorSelectionDialog.html
struct: GtkColorSelectionDialog
class: ColorSelectionDialog
prefix: gtk_color_selection_dialog_
import: glib.Str
import: gtk.ColorSelection

nocode: gtk_color_selection_dialog_get_color_selection

code: start
	/**
	 * Retrieves the GtkColorSelection widget embedded in the dialog.
	 * Since 2.14
	 * Returns: the embedded GtkColorSelection
	 */
	public ColorSelection getColorSelection()
	{
		// GtkWidget* gtk_color_selection_dialog_get_color_selection  (GtkColorSelectionDialog *colorsel);
		auto p = gtk_color_selection_dialog_get_color_selection(gtkColorSelectionDialog);
		if(p is null)
		{
			return null;
		}
		return new ColorSelection(cast(GtkColorSelection*) p);
	}
code: end
outFile: ColorSelectionDialog

file: GtkHSV.html
struct: GtkHSV
class: HSV
prefix: gtk_hsv_
prefix: gtk_

out: gtk_hsv_get_color h
out: gtk_hsv_get_color s
out: gtk_hsv_get_color v
out: gtk_hsv_get_metrics size
out: gtk_hsv_get_metrics ring_width
out: gtk_hsv_to_rgb r
out: gtk_hsv_to_rgb g
out: gtk_hsv_to_rgb b
out: gtk_rgb_to_hsv h
out: gtk_rgb_to_hsv s
out: gtk_rgb_to_hsv v

outFile: HSV

file: GtkFileChooser.html
struct: GtkFileChooser
class: FileChooserT
template: TStruct
prefix: gtk_file_chooser_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.File
import: glib.ListSG
import: gtk.FileFilter
import: gtk.Widget
structWrap: GFile* File
structWrap: GSList* ListSG
structWrap: GtkFileFilter* FileFilter
structWrap: GtkWidget* Widget

alias: setAction setFileChooserAction
alias: getAction getFileChooserAction

interface: FileChooserIF
outFile: FileChooserT

file: GtkFileChooserButton.html
struct: GtkFileChooserButton
class: FileChooserButton
implements: FileChooserIF
prefix: gtk_file_chooser_button_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserButton);
cade: end
outFile: FileChooserButton

file: GtkFileChooserDialog.html
struct: GtkFileChooserDialog
class: FileChooserDialog
implements: FileChooserIF
prefix: gtk_file_chooser_dialog_
import: glib.Str
import: gtk.Window

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

nocode: gtk_file_chooser_dialog_new

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserDialog);

	/**
	 * Creates a new GtkFileChooserDialog. This function is analogous to
	 * gtk_dialog_new_with_buttons().
	 * Since 2.4
	 * Params:
	 *  title = Title of the dialog, or NULL
	 *  parent = Transient parent of the dialog, or NULL
	 *  action = Open or save mode for the dialog
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string title, Window parent, FileChooserAction action,  string[] buttonsText=null, ResponseType[] responses=null)
	{
		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.OK;
			responses ~= ResponseType.CANCEL;
		}

		auto p = gtk_file_chooser_dialog_new(
				Str.toStringz(title),
				(parent is null) ? null : parent.getWindowStruct(),
				action,
				null,
				0);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_file_chooser_dialog_new");
		}

		this(cast(GtkFileChooserDialog*) p);

		addButtons(buttonsText, responses);
	}
code: end
outFile: FileChooserDialog

file: GtkFileChooserWidget.html
struct: GtkFileChooserWidget
class: FileChooserWidget
implements: FileChooserIF
prefix: gtk_file_chooser_widget_
import: glib.Str

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserWidget);
cade: end
outFile: FileChooserWidget

file: GtkFileFilter.html
struct:  GtkFileFilter
class: FileFilter
implements: BuildableIF
prefix: gtk_file_filter_
import: glib.Str

# imports for Buildable Interface
import: gtk.BuildableT
import: gtk.BuildableIF

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkFileFilter);
cade: end
outFile: FileFilter

file: GtkFontChooser.html
struct: GtkFontChooser
class: FontChooserT
template: TStruct
prefix: gtk_font_chooser_
import: glib.Str
import: pango.PgFontDescription
import: pango.PgFontFace
import: pango.PgFontFamily
structWrap: PangoFontDescription* PgFontDescription
structWrap: PangoFontFace* PgFontFace
structWrap: PangoFontFamily* PgFontFamily
interface: FontChooserIF
outFile: FontChooserT

file: GtkFontButton.html
struct: GtkFontButton
class: FontButton
implements: FontChooserIF
prefix: gtk_font_button_
import: glib.Str

# imports for FontChooser Interface
import: gtk.FontChooserT
import: gtk.FontChooserIF

code: start
	// add the FontChooser capabilities
	mixin FontChooserT!(GtkFontButton);
cade: end
outFile: FontButton

file: GtkFontChooserWidget.html
struct: GtkFontChooserWidget
class: FontChooserWidget
implements: FontChooserIF
prefix: gtk_font_chooser_widget_
import: glib.Str

# imports for FontChooser Interface
import: gtk.FontChooserT
import: gtk.FontChooserIF

code: start
	// add the FontChooser capabilities
	mixin FontChooserT!(GtkFontChooserWidget);
cade: end
outFile: FontChooserWidget

file: GtkFontChooserDialog.html
struct: GtkFontChooserDialog
class: FontChooserDialog
implements: FontChooserIF
prefix: gtk_font_chooser_dialog_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window

# imports for FontChooser Interface
import: gtk.FontChooserT
import: gtk.FontChooserIF

code: start
	// add the FontChooser capabilities
	mixin FontChooserT!(GtkFontChooserDialog);
cade: end
outFile: FontChooserDialog

file: GtkFontSelection.html
struct: GtkFontSelection
class: FontSelection
prefix: gtk_font_selection_
import: glib.Str
import: gtk.Widget
import: pango.PgFontFace
import:  pango.PgFontFamily
structWrap: GtkWidget* Widget
structWrap: PangoFontFace* PgFontFace
structWrap: PangoFontFamily* PgFontFamily
outFile: FontSelection

file: GtkFontSelectionDialog.html
struct: GtkFontSelectionDialog
class: FontSelectionDialog
prefix: gtk_font_selection_dialog_
import: glib.Str
import: gtk.FontSelection
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_font_selection_dialog_get_font_selection

code: start
	/**
	 * Retrieves the GtkFontSelection widget embedded in the dialog.
	 * Since 2.22
	 * Returns: the embedded GtkFontSelection
	 */
	public FontSelection getFontSelection()
	{
		// GtkWidget * gtk_font_selection_dialog_get_font_selection  (GtkFontSelectionDialog *fsd);
		auto p = gtk_font_selection_dialog_get_font_selection(gtkFontSelectionDialog);
		if(p is null)
		{
			return null;
		}
		return new FontSelection(cast(GtkFontSelection*) p);
	}
code: end
outFile: FontSelectionDialog

###########################################################
### Layout Containers #####################################
###########################################################

file: GtkGrid.html
struct: GtkGrid
class: Grid
implements: OrientableIF
prefix: gtk_grid_
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkGrid);
code: end
outFile: Grid

file: GtkAlignment.html
struct: GtkAlignment
class: Alignment
prefix: gtk_alignment_
import: gtk.Widget

out: gtk_alignment_get_padding padding_top
out: gtk_alignment_get_padding padding_bottom
out: gtk_alignment_get_padding padding_left
out: gtk_alignment_get_padding padding_right

code: start
	/** */
	public static Alignment center(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment north(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment south(Widget widget)
	{
		Alignment a = new Alignment(0.5, 1.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment east(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
	/** */
	public static Alignment west(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment northWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment northEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 1.0, 0, 0);
		a.add(widget);
		return a;
	}
code: end
outFile: Alignment

file: GtkAspectFrame.html
struct: GtkAspectFrame
class: AspectFrame
prefix: gtk_aspect_frame_
import: glib.Str
outFile: AspectFrame

file: GtkBox.html
struct: GtkBox
class: Box
implements: OrientableIF
prefix: gtk_box_
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_box_query_child_packing expand
out: gtk_box_query_child_packing fill
out: gtk_box_query_child_packing padding
out: gtk_box_query_child_packing pack_type

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkBox);
code: end
outFile: Box

file: GtkHBox.html
struct: GtkHBox
class: HBox
prefix: gtk_hbox_
outFile: HBox

file: GtkVBox.html
struct: GtkVBox
class: VBox
prefix: gtk_vbox_
outFile: VBox

file: GtkButtonBox.html
struct: GtkButtonBox
class: ButtonBox
prefix: gtk_button_box_
import: gtk.Button
import: gtk.HButtonBox
import: gtk.VButtonBox
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_button_box_get_child_size min_width
out: gtk_button_box_get_child_size min_height
out: gtk_button_box_get_child_ipadding ipad_x
out: gtk_button_box_get_child_ipadding ipad_y

code: start
	/** */
	static ButtonBox createActionBox(
			void delegate(Button) onClicked, 
			StockID[] stocks, 
			string[] actions,
			bool vertical=false
		)
	{
		ButtonBox bBox;
		if ( vertical )
		{
			bBox = VButtonBox.createActionBox();
		}
		else
		{
			bBox = HButtonBox.createActionBox();
		}

		Button button;
		for( int i=0 ; i<stocks.length && i<actions.length ; i++)
		{
			button =  new Button(stocks[i]);
			bBox.packEnd(button, false, false, 7);
			button.setActionName(actions[i]);
			button.addOnClicked(onClicked);
		}
		return bBox;
	}

	/** */
	static ButtonBox createOkBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK];
		string[] actions;
		actions ~= "action.ok";
		return createActionBox(onClicked, stocks, actions);
	}

	/** */
	static ButtonBox createOkCancelBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK, StockID.CANCEL];
		string[] actions;
		actions ~= "action.ok";
		actions ~= "action.cancel";
		return createActionBox(onClicked, stocks, actions);
	}
code: end
outFile: ButtonBox

file: GtkHButtonBox.html
struct: GtkHButtonBox
class: HButtonBox
prefix: gtk_hbutton_box_

code: start
	/**
	 * Creates a new HButtonBox and sets comon parameters
	 */
	static HButtonBox createActionBox()
	{
		HButtonBox bBox = new HButtonBox();
		bBox.setLayout(ButtonBoxStyle.END);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
code: end
outFile: HButtonBox

file: GtkVButtonBox.html
struct: GtkVButtonBox
class: VButtonBox
prefix: gtk_vbutton_box_
code: start
    /**
     * Creates a new vertical button box and sets standart values for it's comon parameters
     * Returns: a new vertical button box
     */
	static VButtonBox createActionBox()
	{
		VButtonBox bBox = new VButtonBox();
		bBox.setLayout(ButtonBoxStyle.START);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
code: end
outFile: VButtonBox

file: GtkFixed.html
struct: GtkFixed
class: Fixed
prefix: gtk_fixed_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Fixed

file: GtkPaned.html
struct: GtkPaned
class: Paned
implements: OrientableIF
prefix: gtk_paned_
import: gdk.Window
import: gtk.Widget
structWrap: GdkWindow* Window
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkPaned);

	/** */
	public void add(Widget child1, Widget child2)
	{
		add1(child1);
		add2(child2);
	}
code: end
outFile: Paned

file: GtkHPaned.html
struct: GtkHPaned
class: HPaned
prefix: gtk_hpaned_
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: HPaned

file: GtkVPaned.html
struct: GtkVPaned
class: VPaned
prefix: gtk_vpaned_
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: VPaned

file: GtkLayout.html
struct: GtkLayout
class: Layout
implements: ScrollableIF
prefix: gtk_layout_
import: gdk.Window
import: gtk.Adjustment
import: gtk.Widget
structWrap: GdkWindow* Window
structWrap: GtkAdjustment* Adjustment
structWrap: GtkWidget* Widget

nocode: gtk_layout_get_hadjustment
nocode: gtk_layout_get_vadjustment
nocode: gtk_layout_set_hadjustment
nocode: gtk_layout_set_vadjustment

#imports for Scrollable Interface.
import: gtk.ScrollableIF
import: gtk.ScrollableT

out: gtk_layout_get_size width
out: gtk_layout_get_size height

code: start
	// add the Scrollable capabilities
	mixin ScrollableT!(GtkLayout);
code: end
outFile: Layout

file: GtkNotebook.html
struct: GtkNotebook
class: Notebook
prefix: gtk_notebook_
import: glib.Str
import: gtk.Label
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start
	/**
	 * Append a page with a widget and a text for a label
	 */
	public int appendPage(Widget child, string tabLabel)
	{
		return appendPage(child, new Label(tabLabel));
	}

	/** */
	void setCurrentPage(Widget child)
	{
		gtk_notebook_set_current_page(gtkNotebook,gtk_notebook_page_num(gtkNotebook, child.getWidgetStruct()));
	}
code: end
outFile: Notebook

file: GtkTable.html
struct: GtkTable
class: Table
prefix: gtk_table_
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_table_get_size rows
out: gtk_table_get_size columns

nocode: gtk_table_new

code: start
	int row;
	int col;
	int maxRows;
	int maxCols;

	public AttachOptions defaultXOption = AttachOptions.SHRINK;
	public AttachOptions defaultYOption = AttachOptions.SHRINK;
	
	/**
	 * Removes all children and resizes the table to 1,1
	 */
	override void removeAll()
	{
		super.removeAll();
		resize(1,1);

		row = 0;
		col = 0;
		maxRows = 1;
		maxCols = 1;
	}
	
	/**
	 * Used to create a new table widget. An initial size must be given by
	 * specifying how many rows and columns the table should have, although
	 * this can be changed later with gtk_table_resize(). rows and columns
	 * must both be in the range 0 .. 65535.
	 * Params:
	 *  rows = The number of rows the new table should have.
	 *  columns = The number of columns the new table should have.
	 *  homogeneous = If set to TRUE, all table cells are resized to the size of the cell
	 *  containing the largest widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (uint rows, uint columns, int homogeneous)
	{
		// GtkWidget* gtk_table_new (guint rows,  guint columns,  gboolean homogeneous);
		auto p = gtk_table_new(rows, columns, homogeneous);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_table_new");
		}

		this(cast(GtkTable*) p);

		row = 0;
		col = 0;
		maxRows = rows;
		maxCols = columns;
	}
	

	/**
	 * Attach a new widget creating a new row if necessary
	 */
	void attach(Widget child)
	{
		attach(child, col, col + 1, row, row + 1,
				defaultXOption, defaultYOption,
				getDefaultColSpacing(), getDefaultRowSpacing());
		++col;
		if (col >= maxCols)
		{
			col = 0;
			++row;
		}
	}
code: end
outFile: Table

file: GtkExpander.html
struct: GtkExpander
class: Expander
prefix: gtk_expander_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_expander_new
nocode: gtk_expander_new_with_mnemonic

code: start
	/**
	 * Creates a new expander using label as the text of the label.
	 * Since 2.4
	 * Params:
	 *  label = the text of the label
	 *  mnemonic = if true characters in label that are preceded by an underscore,
	 *  are underlined.
	 *  If you need a literal underscore character in a label, use '__' (two
	 *  underscores). The first underlined character represents a keyboard
	 *  accelerator called a mnemonic.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkExpander* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_expander_new_with_mnemonic (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_expander_new (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_expander_new");
		}

		this(p);
	}
code: end
outFile: Expander

file: GtkOverlay.html
struct: GtkOverlay
class: Overlay
prefix: gtk_overlay_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Overlay

file: gtk3-Orientable.html
struct: GtkOrientable
class: OrientableT
template: TStruct
prefix: gtk_orientable_
interface: OrientableIF
outFile: OrientableT

###########################################################
### Ornaments #############################################
###########################################################

file: GtkFrame.html
struct: GtkFrame
class: Frame
prefix: gtk_frame_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_frame_get_label_align xalign
out: gtk_frame_get_label_align yalign

code: start
	/**
	 * Creates frame with label and set it's child widget
	 */
	public this(Widget widget, string label)
	{
		this(label);
		add(widget);
	}
code: end
outFile: Frame

file: GtkSeparator.html
struct: GtkSeparator
class: Separator
implements: OrientableIF
prefix: gtk_separator_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkSeparator);
code: end
outFile: Separator

file: GtkHSeparator.html
struct: GtkHSeparator
class: HSeparator
prefix: gtk_hseparator_
outFile: HSeparator

file: GtkVSeparator.html
struct: GtkVSeparator
class: VSeparator
prefix: gtk_vseparator_
outFile: VSeparator

###########################################################
### Scrolling #############################################
###########################################################

file: GtkScrollbar.html
struct: GtkScrollbar
class: Scrollbar
prefix: gtk_scrollbar_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Scrollbar

file: GtkHScrollbar.html
struct: GtkHScrollbar
class: HScrollbar
prefix: gtk_hscrollbar_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScrollbar

file: GtkVScrollbar.html
struct: GtkVScrollbar
class: VScrollbar
prefix: gtk_vscrollbar_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScrollbar

file: GtkScrolledWindow.html
struct: GtkScrolledWindow
class: ScrolledWindow
prefix: gtk_scrolled_window_
import: gtk.Adjustment
import: gtk.Widget
structWrap: GtkAdjustment* Adjustment
structWrap: GtkWidget* Widget

out: gtk_scrolled_window_get_policy hscrollbar_policy
out: gtk_scrolled_window_get_policy vscrollbar_policy

code: start
	/** */
	public this()
	{
		this(null, null);
	}

	/** */
	public this(Widget widget)
	{
		this();
		add(widget);
	}
	
	/**
	 * Creates a new Scrolled window and set the policy type
	 * Params:
	 *  hPolicy = the horizontal policy
	 *  vPolicy = the vertical policy
	 */
	this(PolicyType hPolicy, PolicyType vPolicy)
	{
		this();
		setPolicy(hPolicy, vPolicy);
	}
code: end
outFile: ScrolledWindow

file: GtkScrollable.html
struct: GtkScrollable
class: ScrollableT
template: TStruct
prefix: gtk_scrollable_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
interface: ScrollableIF
outFile: ScrollableT

###########################################################
### Printing ##############################################
###########################################################

file: gtk3-High-level-Printing-API.html
struct: GtkPrintOperation
class: PrintOperation
implements: PrintOperationPreviewIF
prefix: gtk_print_operation_
noprefix: gtk_print_operation_preview_
nosignal: got-page-size 
nosignal: ready
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.PageSetup
import: gtk.PrintContext
import: gtk.PrintSettings
import: gtk.Widget
import: gtk.Window
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrintContext* PrintContext
structWrap: GtkPrintSettings* PrintSettings
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window

#imports for PrintOperationPreview Interface.
import: gtk.PrintOperationPreviewT
import: gtk.PrintOperationPreviewIF

code: start
	// add the PrintOperationPreview capabilities
	mixin PrintOperationPreviewT!(GtkPrintOperation);
code: end
outFile: PrintOperation

struct: GtkPrintOperationPreview
class: PrintOperationPreviewT
template: TStruct
strictPrefix: Y
prefix: gtk_print_operation_preview_
nosignal: begin-print
nosignal: create-custom-widget
nosignal: custom-widget-apply
nosignal: done
nosignal: draw-page
nosignal: end-print
nosignal: paginate
nosignal: preview
nosignal: request-page-setup 
nosignal: status-changed
nosignal: update-custom-widget
import: gtk.PageSetup
import: gtk.PrintContext
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrintContext* PrintContext
interface: PrintOperationPreviewIF
outFile: PrintOperationPreviewT

file: GtkPrintContext.html
struct: GtkPrintContext
class: PrintContext
prefix: gtk_print_context_
import: cairo.Context
import: pango.PgContext
import: pango.PgLayout
import: pango.PgFontMap
import: gtk.PageSetup
structWrap: cairo_t* Context
structWrap: GtkPageSetup* PageSetup
structWrap: PangoContext* PgContext
structWrap: PangoLayout* PgLayout
structWrap: PangoFontMap* PgFontMap

out: gtk_print_context_get_hard_margins top
out: gtk_print_context_get_hard_margins bottom
out: gtk_print_context_get_hard_margins left
out: gtk_print_context_get_hard_margins right
outFile: PrintContext

file: GtkPrintSettings.html
struct: GtkPrintSettings
class: PrintSettings
prefix: gtk_print_settings_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
import: gtk.PaperSize
structWrap: GKeyFile* KeyFile
structWrap: GtkPaperSize* PaperSize
structWrap: GtkPrintSettings* PrintSettings

array: gtk_print_settings_get_page_ranges Return num_ranges
array: gtk_print_settings_set_page_ranges page_ranges num_ranges
outFile: PrintSettings

file: GtkPageSetup.html
struct: GtkPageSetup
class: PageSetup
prefix: gtk_page_setup_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
import: gtk.PaperSize
structWrap: GKeyFile* KeyFile
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPaperSize* PaperSize
outFile: PageSetup

file: GtkPaperSize.html
struct: GtkPaperSize
class: PaperSize
prefix: gtk_paper_size_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: glib.KeyFile
structWrap: GList* ListG
structWrap: GKeyFile* KeyFile
structWrap: GtkPaperSize* PaperSize
outFile: PaperSize

file: GtkPrinter.html
struct: GtkPrinter
class: Printer
prefix: gtk_printer_
prefix: gtk_
import: glib.Str
import: glib.ListG
import: gtk.PageSetup
structWrap: GList* ListG
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrinter* Printer

out: gtk_printer_get_hard_margins top
out: gtk_printer_get_hard_margins bottom
out: gtk_printer_get_hard_margins left
out: gtk_printer_get_hard_margins right
outFile: Printer

file: GtkPrintJob.html
struct: GtkPrintJob
class: PrintJob
prefix: gtk_print_job_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: cairo.Surface
import: gtk.PageSetup
import: gtk.Printer
import: gtk.PrintSettings
structWrap: cairo_surface_t* Surface
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrinter* Printer
structWrap: GtkPrintSettings* PrintSettings

array: gtk_print_job_get_page_ranges Return n_ranges
array: gtk_print_job_set_page_ranges ranges n_ranges
outFile: PrintJob

file: GtkPrintUnixDialog.html
struct: GtkPrintUnixDialog
class: PrintUnixDialog
prefix: gtk_print_unix_dialog_
import: glib.Str
import: gtk.PageSetup
import: gtk.Printer
import: gtk.PrintSettings
import: gtk.Widget
import: gtk.Window
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrinter* Printer
structWrap: GtkPrintSettings* PrintSettings
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window

alias: setSettings setPrintSettings
alias: getSettings getPrintSettings
outFile: PrintUnixDialog

file: GtkPageSetupUnixDialog.html
struct: GtkPageSetupUnixDialog
class: PageSetupUnixDialog
prefix: gtk_page_setup_unix_dialog_
import: glib.Str
import: gtk.PageSetup
import: gtk.PrintSettings
import: gtk.Widget
import: gtk.Window
structWrap: GtkPageSetup* PageSetup
structWrap: GtkPrintSettings* PrintSettings
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window
outFile: PageSetupUnixDialog

###########################################################
### Miscellaneous #########################################
###########################################################

file: GtkAdjustment.html
struct: GtkAdjustment
class: Adjustment
prefix: gtk_adjustment_
outFile: Adjustment

file: GtkArrow.html
struct: GtkArrow
class: Arrow
prefix: gtk_arrow_
outFile: Arrow

file: GtkCalendar.html
struct: GtkCalendar
class: Calendar
prefix: gtk_calendar_

out: gtk_calendar_get_date year
out: gtk_calendar_get_date month
out: gtk_calendar_get_date day

outFile: Calendar

file: GtkDrawingArea.html
struct: GtkDrawingArea
class: DrawingArea
prefix: gtk_drawing_area_

code: start
	/**
	 * Create a new DrawingArea and sets the SizeRequest
	 * Params:
	 *    	width = 	
	 *    	height =
	 */
	this(int width, int height)
	{
		this();
		setSizeRequest(width, height);
	}
code: end
outFile: DrawingArea

file: GtkEventBox.html
struct: GtkEventBox
class: EventBox
prefix: gtk_event_box_
outFile: EventBox

file: GtkHandleBox.html
struct: GtkHandleBox
class: HandleBox
prefix: gtk_handle_box_
outFile: HandleBox

file: GtkIMContextSimple.html
struct: GtkIMContextSimple
ctorStruct: GtkIMContext
class: IMContextSimple
prefix: gtk_im_context_simple_
array: gtk_im_context_simple_add_table data n_seqs
outFile: IMContextSimple

file: GtkIMMulticontext.html
struct: GtkIMMulticontext
ctorStruct: GtkIMContext
class: IMMulticontext
prefix: gtk_im_multicontext_
import: glib.Str
import: gtk.MenuShell
structWrap: GtkMenuShell* MenuShell
outFile: IMMulticontext

file: GtkSizeGroup.html
struct: GtkSizeGroup
class: SizeGroup
implements: BuildableIF
prefix: gtk_size_group_
import: glib.ListSG
import: gtk.Widget
structWrap: GSList* ListSG
structWrap: GtkWidget* Widget

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkSizeGroup);
code: end
outFile: SizeGroup

file: GtkTooltip.html
struct: GtkTooltip
class: Tooltip
prefix: gtk_tooltip_
import: glib.Str
import: gio.IconIF
import: gdk.Display
import: gdk.Pixbuf
import: gtk.Widget
structWrap: GIcon* IconIF
structWrap: GdkDisplay* Display
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkWidget* Widget

inout: gtk_tooltip_set_tip_area rect

code: start
	/**
	 * Sets the icon of the tooltip (which is in front of the text) to be
	 * the stock item indicated by stockID with the size indicated by size.
	 */
	void setIcon(StockID stockID, GtkIconSize size)
	{
		setIconFromStock(StockDesc[stockID], size);
	}
code: end
outFile: Tooltip

file: GtkViewport.html
struct: GtkViewport
class: Viewport
implements: ScrollableIF
prefix: gtk_viewport_
import: gdk.Window
import: gtk.Adjustment
structWrap: GdkWindow* Window
structWrap: GtkAdjustment* Adjustment

nocode: gtk_viewport_get_hadjustment
nocode: gtk_viewport_get_vadjustment
nocode: gtk_viewport_set_hadjustment
nocode: gtk_viewport_set_vadjustment

#imports for Scrollable Interface.
import: gtk.ScrollableT
import: gtk.ScrollableIF

code: start
	// add the Scrollable capabilities
	mixin ScrollableT!(GtkViewport);
code: end
outFile: Viewport

file: GtkAccessible.html
struct: GtkAccessible
class: Accessible
prefix: gtk_accessible_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Accessible

###########################################################
### Abstract Base Classes #################################
###########################################################

file: GtkWidget.html
struct: GtkWidget
nostruct: GtkWidgetClass
nostruct: GtkRequisition
class: Widget
implements: BuildableIF
prefix: gtk_widget_
prefix: gtk_
noprefix: gtk_requisition_

import: std.conv
import: atk.ObjectAtk
import: cairo.Context
import: cairo.Region
import: glib.ListG
import: glib.Str
import: gobject.ParamSpec
import: gobject.Type
import: gobject.Value
import: gio.ActionGroupIF
import: gdk.Color
import: gdk.Cursor
import: gdk.Device
import: gdk.Display
import: gdk.DragContext
import: gdk.Event
import: gdk.FrameClock
import: gdk.Pixbuf
import: gdk.RGBA
import: gdk.Screen
import: gdk.Visual
import: gdk.Window
import: gtk.AccelGroup
import: gtk.Clipboard
import: gtk.RcStyle
import: gtk.SelectionData
import: gtk.Settings
import: gtk.Style
import: gtk.StyleContext
import: gtk.Tooltip
import: gtk.WidgetPath
import: pango.PgContext
import: pango.PgFontDescription
import: pango.PgLayout
structWrap: AtkObject* ObjectAtk
structWrap: cairo_t* Context
structWrap: CairoContext* Context
structWrap: cairo_region_t* Region
structWrap: GList* ListG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GActionGroup* ActionGroupIF
structWrap: GdkColor* Color
structWrap: GdkDevice* Device
structWrap: GdkDisplay* Display
structWrap: GdkDragContext* DragContext
structWrap: GdkEvent* Event
structWrap: GdkFrameClock* FrameClock
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkRGBA* RGBA
structWrap: GdkScreen* Screen
structWrap: GdkVisual* Visual
structWrap: GdkWindow* Window
structWrap: GtkAccelGroup* AccelGroup
structWrap: GtkClipboard* Clipboard
structWrap: GtkRcStyle* RcStyle
structWrap: GtkSelectionData* SelectionData
structWrap: GtkSettings* Settings
structWrap: GtkStyle* Style
structWrap: GtkStyleContext* StyleContext
structWrap: GtkTooltip* Tooltip
structWrap: GtkWidget* Widget
structWrap: GtkWidgetPath* WidgetPath
#TODO: conflicts with GdkWindow
#structWrap: GtkWindow* Window
structWrap: PangoContext* PgContext
structWrap: PangoFontDescription* PgFontDescription
structWrap: PangoLayout* PgLayout

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

inout: gtk_widget_destroyed widget_pointer
out: gtk_widget_size_request requisition
out: gtk_widget_get_child_requisition requisition
inout: gtk_widget_size_allocate allocation
inout: gtk_widget_intersect area
out: gtk_widget_intersect intersection
out: gtk_widget_get_pointer x
out: gtk_widget_get_pointer y
out: gtk_widget_translate_coordinates dest_x
out: gtk_widget_translate_coordinates dest_y
out: gtk_widget_path path_length
out: gtk_widget_path path
out: gtk_widget_path path_reversed
out: gtk_widget_class_path path_length
out: gtk_widget_class_path path
out: gtk_widget_class_path path_reversed
array: gtk_widget_class_list_style_properties Return n_properties
out: gtk_widget_get_size_request width
out: gtk_widget_get_size_request height
out: gtk_widget_get_allocation allocation
inout: gtk_widget_set_allocation allocation
out: gtk_widget_get_requisition requisition
out: gtk_widget_get_preferred_height minimum_height
out: gtk_widget_get_preferred_height natural_height
out: gtk_widget_get_preferred_width minimum_width
out: gtk_widget_get_preferred_width natural_width
out: gtk_widget_get_preferred_height_for_width minimum_height
out: gtk_widget_get_preferred_height_for_width natural_height
out: gtk_widget_get_preferred_width_for_height minimum_width
out: gtk_widget_get_preferred_width_for_height natural_width
out: gtk_widget_get_preferred_size minimum_size
out: gtk_widget_get_preferred_size natural_size
array: gtk_distribute_natural_allocation sizes n_requested_sizes

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkWidget);

	public GtkWidgetClass* getWidgetClass()
	{
		return Type.getInstanceClass!(GtkWidgetClass)(this);
	}

	/** */
	public int getWidth()
	{
		int width;
		gtk_widget_get_size_request(gtkWidget, &width, null);
		return width;
	}

	/** */
	public int getHeight()
	{
		int height;
		gtk_widget_get_size_request(gtkWidget, null, &height);
		return height;
	}

	/**
	 * Sets  the cursor.
	 * Params:
	 *  cursor = the new cursor
	 * Bugs: the cursor changes to the parent widget also
	 */
	void setCursor(Cursor cursor)
	{
		getWindow().setCursor(cursor);
	}
	
	/**
	 * Resets the cursor.
	 * don't know if this is implemented by GTK+. Seems that it's not
	 * Bugs: does nothing
	 */
	public void resetCursor()
	{
		getWindow().setCursor(null);
	}

	/**
	 * Modifies the font for this widget.
	 * This just calls modifyFont(new PgFontDescription(PgFontDescription.fromString(family ~ " " ~ size)));
	 */
	public void modifyFont(string family, int size)
	{
		if ( size < 0 ) size = -size;	// hack to workaround leds bug - TO BE REMOVED

		version(Tango)
		{
			char[10] s;
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ tango.text.convert.Integer.itoa(s,size)
				)
			);
		}
		else version(D_Version2)
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ to!(string)(size)
				)
			);
		}
		else
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ std.string.toString(size)
				)
			);
		}
	}
	
	
	/** */
	public bool onEvent(GdkEvent* event)
	{
		return getWidgetClass().event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonPressEvent(GdkEventButton* event)
	{
		return getWidgetClass().button_press_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonReleaseEvent(GdkEventButton* event)
	{
		return getWidgetClass().button_release_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onScrollEvent(GdkEventScroll* event)
	{
		return getWidgetClass().scroll_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMotionNotifyEvent(GdkEventMotion* event)
	{
		return getWidgetClass().motion_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onDeleteEvent(GdkEventAny* event)
	{
		return getWidgetClass().delete_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onDestroyEvent(GdkEventAny* event)
	{
		return getWidgetClass().destroy_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyPressEvent(GdkEventKey* event)
	{
		return getWidgetClass().key_press_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyReleaseEvent(GdkEventKey* event)
	{
		return getWidgetClass().key_release_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onEnterNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().enter_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onLeaveNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().leave_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onConfigureEvent(GdkEventConfigure* event)
	{
		return getWidgetClass().configure_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusInEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focus_in_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusOutEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focus_out_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMapEvent(GdkEventAny* event)
	{
		return getWidgetClass().map_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onUnmapEvent(GdkEventAny* event)
	{
		return getWidgetClass().unmap_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onPropertyNotifyEvent(GdkEventProperty* event)
	{
		return getWidgetClass().property_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionClearEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selection_clear_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionRequestEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selection_request_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionNotifyEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selection_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityInEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximity_in_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityOutEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximity_out_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onVisibilityNotifyEvent(GdkEventVisibility* event)
	{
		return getWidgetClass().visibility_notify_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onWindowStateEvent(GdkEventWindowState* event)
	{
		return getWidgetClass().window_state_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onDamageEvent(GdkEventExpose* event)
	{
		return getWidgetClass().damage_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onGrabBrokenEvent(GdkEventGrabBroken* event)
	{
		return getWidgetClass().grab_broken_event(getWidgetStruct(), event) == 0 ? false : true;
	}

	alias cairo_t CairoContext;
code: end
outFile: Widget

struct: GtkRequisition
class: Requisition
prefix: gtk_requisition_
strictPrefix: Y
import: gtkc.Loader
import: gtkc.paths
structWrap: GtkRequisition* Requisition

nosignal: accel-closures-changed
nosignal: button-press-event
nosignal: button-release-event
nosignal: can-activate-accel
nosignal: child-notify
nosignal: composited-changed
nosignal: configure-event
nosignal: damage-event
nosignal: delete-event
nosignal: destroy
nosignal: destroy-event
nosignal: direction-changed
nosignal: drag-begin
nosignal: drag-data-delete
nosignal: drag-data-get
nosignal: drag-data-received
nosignal: drag-drop
nosignal: drag-end
nosignal: drag-failed
nosignal: drag-leave
nosignal: drag-motion
nosignal: draw
nosignal: enter-notify-event
nosignal: event 
nosignal: event-after
nosignal: focus
nosignal: focus-in-event
nosignal: focus-out-event
nosignal: grab-broken-event
nosignal: grab-focus
nosignal: grab-notify
nosignal: hide
nosignal: hierarchy-changed
nosignal: key-press-event
nosignal: key-release-event
nosignal: keynav-failed
nosignal: leave-notify-event
nosignal: map
nosignal: map-event
nosignal: mnemonic-activate
nosignal: motion-notify-event
nosignal: move-focus
nosignal: parent-set
nosignal: popup-menu
nosignal: property-notify-event
nosignal: proximity-in-event
nosignal: proximity-out-event
nosignal: query-tooltip
nosignal: realize
nosignal: screen-changed
nosignal: scroll-event
nosignal: selection-clear-event
nosignal: selection-get
nosignal: selection-notify-event
nosignal: selection-received
nosignal: selection-request-event
nosignal: show
nosignal: show-help
nosignal: size-allocate
nosignal: state-changed
nosignal: state-flags-changed
nosignal: style-set
nosignal: style-updated
nosignal: unmap
nosignal: unmap-event
nosignal: unrealize
nosignal: visibility-notify-event
nosignal: window-state-event
nosignal: touch-event

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkRequisition !is null )
		{
			gtk_requisition_free(gtkRequisition);
		}
	}
code: end
outFile: Requisition

file: GtkContainer.html
struct: GtkContainer
class: Container
prefix: gtk_container_
import: cairo.Context
import: glib.Str
import: glib.ListG
import: gobject.ParamSpec
import: gobject.Value
import: gtk.Adjustment
import: gtk.Widget
import: gtk.WidgetPath
structWrap: cairo_t* Context
structWrap: GList* ListG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GtkAdjustment* Adjustment
structWrap: GtkWidget* Widget
structWrap: GtkWidgetPath* WidgetPath

out: gtk_container_get_focus_chain focusable_widgets
array: gtk_container_class_list_child_properties Return n_properties

code: start
	/**
	 * Removes all widgets from the container
	 */
	void removeAll()
	{
		GList* gList = gtk_container_get_children(getContainerStruct());
		if ( gList !is null )
		{
			ListG children = new ListG(gList);
			for ( int i=children.length()-1 ; i>=0 ; i-- )
			{
				gtk_container_remove(getContainerStruct(), cast(GtkWidget*)children.nthData(i));
			}
		}
	}
code: end
outFile: Container

file: GtkBin.html
struct: GtkBin
class: Bin
prefix: gtk_bin_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Bin

file: GtkMenuShell.html
struct: GtkMenuShell
class: MenuShell
prefix: gtk_menu_shell_
import: glib.Str
import: gio.MenuModel
import: gtk.Widget
structWrap: GMenuModel* MenuModel
structWrap: GtkWidget* Widget
outFile: MenuShell

file: GtkMisc.html
struct: GtkMisc
class: Misc
prefix: gtk_misc_

out: gtk_misc_get_alignment xalign
out: gtk_misc_get_alignment yalign
out: gtk_misc_get_padding xpad
out: gtk_misc_get_padding ypad

outFile: Misc

file: GtkRange.html
struct: GtkRange
class: Range
implements: OrientableIF
prefix: gtk_range_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_range_get_range_rect range_rect
out: gtk_range_get_slider_range slider_start
out: gtk_range_get_slider_range slider_end

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkRange);
code: end
outFile: Range

file: GtkIMContext.html
struct: GtkIMContext
class: IMContext
prefix: gtk_im_context_
import: glib.Str
import: gdk.Window
import: pango.PgAttributeList
structWrap: GdkWindow* Window
structWrap: PangoAttrList* PgAttributeList

out: gtk_im_context_get_preedit_string str
out: gtk_im_context_get_preedit_string attrs
out: gtk_im_context_get_preedit_string cursor_pos
inout: gtk_im_context_set_cursor_location area
array: gtk_im_context_set_surrounding text len
out: gtk_im_context_get_surrounding text
out: gtk_im_context_get_surrounding cursor_index

outFile: IMContext

###########################################################
### Cross-process Embedding ###############################
###########################################################

file: GtkPlug.html
struct: GtkPlug
class: Plug
prefix: gtk_plug_
import: gdk.Display
#import: gdk.Window
structWrap: GdkDisplay* Display
#structWrap: GdkWindow* Window
alias: Window gulong
outFile: Plug

file: GtkSocket.html
struct: GtkSocket
class: Socket
prefix: gtk_socket_
#import: gdk.Window
#structWrap: GdkWindow* Window
alias: Window gulong
outFile: Socket

###########################################################
### Recently Used Documents ###############################
###########################################################

file: GtkRecentManager.html
struct: GtkRecentManager
class: RecentManager
prefix: gtk_recent_manager_
noprefix: gtk_recent_info_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gtk.RecentInfo
structWrap: GList* ListG
structWrap: GtkRecentInfo* RecentInfo
structWrap: GtkRecentManager* RecentManager
outFile: RecentManager

struct: GtkRecentInfo
class: RecentInfo
strictPrefix: Y
nosignal: changed
prefix: gtk_recent_info_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AppInfo
import: gio.Icon
import: gio.IconIF
import: gdk.Pixbuf
import: gtkc.Loader
import: gtkc.paths
structWrap: GAppInfo* AppInfo
structWrap: GIcon* IconIF
structWrap: GdkPixbuf* Pixbuf
structWrap: GtkRecentInfo* RecentInfo

out: gtk_recent_info_get_application_info app_exec
out: gtk_recent_info_get_application_info count
out: gtk_recent_info_get_application_info time_
array: gtk_recent_info_get_applications Return length
array: gtk_recent_info_get_groups Return length

code: start
	~this ()
	{
		if (  Linker.isLoaded(LIBRARY.GTK) && gtkRecentInfo !is null )
		{
			gtk_recent_info_unref(gtkRecentInfo);
		}
	}
code: end
outFile: RecentInfo

file: GtkRecentChooser.html
struct: GtkRecentChooser
class: RecentChooserT
template: TStruct
prefix: gtk_recent_chooser_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: glib.ListSG
import: gtk.RecentInfo
import: gtk.RecentFilter
structWrap: GList* ListG
structWrap: GSList* ListSG
structWrap: GtkRecentInfo* RecentInfo
structWrap: GtkRecentFilter* RecentFilter

alias: setShowNumbers recentChooserSetShowNumbers
alias: getShowNumbers recentChooserGetShowNumbers
array: gtk_recent_chooser_get_uris Return length

interface: RecentChooserIF
outFile: RecentChooserT

file: GtkRecentChooserDialog.html
struct: GtkRecentChooserDialog
class: RecentChooserDialog
implements: RecentChooserIF
prefix: gtk_recent_chooser_dialog_
import: glib.Str
import: gtk.Window
import: gtk.RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

nocode: gtk_recent_chooser_dialog_new
nocode: gtk_recent_chooser_dialog_new_for_manager

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserDialog);

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  string[] buttonsText=null, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  stockIDs = stockIDs of the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  StockID[] stockIDs, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(stockIDs, responses);
	}
code: end
outFile: RecentChooserDialog

file: GtkRecentChooserMenu.html
struct: GtkRecentChooserMenu
class: RecentChooserMenu
implements: ActivatableIF
implements: RecentChooserIF
prefix: gtk_recent_chooser_menu_
import: glib.Str
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkRecentChooserMenu);

	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserMenu);
code: end
outFile: RecentChooserMenu

file: GtkRecentChooserWidget.html
struct: GtkRecentChooserWidget
class: RecentChooserWidget
implements: RecentChooserIF
prefix: gtk_recent_chooser_widget_
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserWidget);
code: end
outFile: RecentChooserWidget

file: GtkRecentFilter.html
struct: GtkRecentFilter
class: RecentFilter
prefix: gtk_recent_filter_
import: glib.Str
outFile: RecentFilter

###########################################################
### Choosing from installed applications ##################
###########################################################

file: GtkAppChooser.html
struct: GtkAppChooser
class: AppChooserT
template: TStruct
prefix: gtk_app_chooser_
import: glib.Str
import: gio.AppInfo
structWrap: GAppInfo* AppInfo
interface: AppChooserIF
outFile: AppChooserT

file: GtkAppChooserButton.html
struct: GtkAppChooserButton
class: AppChooserButton
implements: AppChooserIF
prefix: gtk_app_chooser_button_
import: glib.Str
import: gio.IconIF
structWrap: GIcon* IconIF

#imports for AppChooser interface
import: gtk.AppChooserIF
import: gtk.AppChooserT

code: start
	// add the AppChooser capabilities
	mixin AppChooserT!(GtkAppChooserButton);
code: end
outFile: AppChooserButton

file: GtkAppChooserDialog.html
struct: GtkAppChooserDialog
class: AppChooserDialog
implements: AppChooserIF
prefix: gtk_app_chooser_dialog_
import: glib.Str
import: gio.File
import: gtk.Widget
import: gtk.Window
structWrap: GFile* File
structWrap: GtkWidget* Widget
structWrap: GtkWindow* Window

#imports for AppChooser interface
import: gtk.AppChooserIF
import: gtk.AppChooserT

code: start
	// add the AppChooser capabilities
	mixin AppChooserT!(GtkAppChooserDialog);
code: end
outFile: AppChooserDialog

file: GtkAppChooserWidget.html
struct: GtkAppChooserWidget
class: AppChooserWidget
implements: AppChooserIF
prefix: gtk_app_chooser_widget_
import: glib.Str
import: gio.AppInfo
import: gtk.Menu
structWrap: GAppInfo* AppInfo
structWrap: GtkMenu* Menu

#imports for AppChooser interface
import: gtk.AppChooserIF
import: gtk.AppChooserT

code: start
	// add the AppChooser capabilities
	mixin AppChooserT!(GtkAppChooserWidget);
code: end
outFile: AppChooserWidget

###########################################################
### Interface builder #####################################
###########################################################

file: GtkBuildable.html
struct: GtkBuildable
class: BuildableT
template: TStruct
prefix: gtk_buildable_
import: glib.Str
import: gobject.ObjectG
import: gobject.Value
import: gtk.Builder
structWrap: GObject* ObjectG
structWrap: GValue* Value
structWrap: GtkBuilder* Builder

alias: setName buildableSetName
alias: getName buildableGetName

interface: BuildableIF
outFile: BuildableT

file: GtkBuilder.html
struct: GtkBuilder
class: Builder
prefix: gtk_builder_
import: glib.ErrorG
import: glib.GException
import: glib.ListSG
import: glib.Str
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
import: std.string
import: gtkc.glib;
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GSList* ListSG
structWrap: GValue* Value

nocode: gtk_builder_get_object
nocode: gtk_builder_get_objects

#imports for gtk_builder_real_get_type_from_name_override
import: gtkc.gobject
import: gtkc.paths
import: glib.Module
import: gobject.Type

array: gtk_builder_add_objects_from_file object_ids
array: gtk_builder_add_objects_from_string object_ids
array: gtk_builder_add_objects_from_resource object_ids

nocode: gtk_builder_new
code: start
	private struct GtkBuilderClass
	{
		GObjectClass parentClass;
		extern(C) GType function( GtkBuilder*, char* ) get_type_from_name;
		
		/* Padding for future expansion */
		extern(C) void  function()  _gtk_reserved1;
		extern(C) void  function()  _gtk_reserved2;
		extern(C) void  function()  _gtk_reserved3;
		extern(C) void  function()  _gtk_reserved4;
		extern(C) void  function()  _gtk_reserved5;
		extern(C) void  function()  _gtk_reserved6;
		extern(C) void  function()  _gtk_reserved7;
		extern(C) void  function()  _gtk_reserved8;
	}

	/**
	 * Creates a new builder object.
	 * Since 2.12
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this ()
	{
		// GtkBuilder* gtk_builder_new (void);
		auto p = gtk_builder_new();
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_builder_new()");
		}
		this(cast(GtkBuilder*) p);

		GtkBuilderClass* klass = Type.getInstanceClass!(GtkBuilderClass)( this );
		klass.get_type_from_name = &gtk_builder_real_get_type_from_name_override;
	}

	/**
	 * This function is a modification of _gtk_builder_resolve_type_lazily from "gtk/gtkbuilder.c".
	 * It is needed because it assumes we are linking at compile time to the gtk libs.
	 * specifically the NULL in g_module_open( NULL, 0 );
	 * It replaces the default function pointer "get_type_from_name" in GtkBuilderClass.
	 */
	extern(C) private static GType gtk_builder_real_get_type_from_name_override ( GtkBuilder* builder, char *name )
	{
		GType gtype;
		gtype = g_type_from_name( name );
		if (gtype != GType.INVALID)
		{
			return gtype;
		}
		
		/*
		 * Try to map a type name to a _get_type function
		 * and call it, eg:
		 *
		 * GtkWindow -> gtk_window_get_type
		 * GtkHBox -> gtk_hbox_get_type
		 * GtkUIManager -> gtk_ui_manager_get_type
		 *
		 */
		char   c;
		string symbol_name;

		for (int i = 0; name[i] != '\0'; i++)
		{
			c = name[i];
			/* skip if uppercase, first or previous is uppercase */
			if ((c == Str.asciiToupper (c) &&
			   i > 0 && name[i-1] != Str.asciiToupper (name[i-1])) ||
			  (i > 2 && name[i]   == Str.asciiToupper (name[i]) &&
			   name[i-1] == Str.asciiToupper (name[i-1]) &&
			   name[i-2] == Str.asciiToupper (name[i-2]))
			   )

			symbol_name ~= '_';
			symbol_name ~= Str.asciiTolower (c);
		}
		symbol_name ~=  "_get_type" ;

		/* scan linked librarys for function symbol */
		foreach ( lib; importLibs )
		{
			GType function() func;
			Module mod = Module.open( lib, GModuleFlags.BIND_LAZY );
			if( mod is null )
				continue;
			
			scope(exit) mod.close();

			if ( mod.symbol( symbol_name, cast(void**) &func ) ) {
				return func();
			}
		}

		return GType.INVALID;
	}

	/**
	 * Gets the object named name. Note that this function does not
	 * increment the reference count of the returned object.
	 * Since 2.12
	 * Params:
	 * name = name of object to get
	 * Returns: the object named name or NULL if it could not be found in the object tree.. transfer none.
	 */
	public ObjectG getObject(string name)
	{
		// GObject* gtk_builder_get_object (GtkBuilder *builder,  const gchar *name);
		return newFromObject( gtk_builder_get_object(gtkBuilder, Str.toStringz(name)) );
	}

	/**
	 * Gets all objects that have been constructed by builder.
	 * Since 2.12
	 * Returns: an array containing all the objects constructed by the GtkBuilder instance.
	 */
	public ObjectG[] getObjects()
	{
		ObjectG[] objects;

		// GSList* gtk_builder_get_objects (GtkBuilder *builder);
		GSList* list = gtk_builder_get_objects(gtkBuilder);

		while ( list.next !is null )
		{
			objects ~= newFromObject( cast(GObject*)list.data );
			list = list.next;
		}

		g_slist_free(list);

		return objects;
	}

	/**
	 * This function creates an D object corresponding to the Struct pointer passed in.
	 */
	public ObjectG newFromObject(GObject* cobj)
	{
		version(LDC)
		{
			version(D_Version2)
			{
				alias ClassInfo.find findClassInfo;
			}
		}
		else
		{
			alias ClassInfo.find findClassInfo;
		}

		if(cobj is null)
		{
			return null;
		}

		void* dObj = g_object_get_data(cobj, Str.toStringz("GObject"));

		if ( dObj !is null )
		{
			return cast(ObjectG)dObj;
		}

		string type = convertClassName(Type.name((cast(GTypeInstance*)cobj).gClass.gType));
		ClassInfo ci = cast(ClassInfo)findClassInfo(type);

		//Gobject and Gio types both start with g, so try both.
		if(ci is null && startsWith(type, "gobject"))
		{
				ci = cast(ClassInfo)findClassInfo("gio"~ type[7..$]);
		}

		if(ci is null)
		{
			return null;
		}

		ObjectG obj = cast(ObjectG)_d_newclass(ci);

		version(D_Version2)
		{
			obj.__ctor(cobj);
		}
		else
		{
			obj._ctor(cobj);
		}

		return obj;
	}

	/**
	 * Turn the name of a C Type in to the name of the corresponding D type.
	 * Note: If the prefix of the type is "G" this always usses "gobject" as
	 *     the prefix, extra care should be taken for types from GIO.
	 */
	private string convertClassName(string gName)
	{
		string conv;
		string prefix;

		version(Tango)
		{
			alias toUpper toupper;
			alias toLower tolower;
		}
		version(D_Version2)
		{
			alias toUpper toupper;
			alias toLower tolower;
		}

		if      ( startsWith(gName, "GtkSource" ) ) prefix = "Gsv";
		else if ( startsWith(gName, "Gtk") )        prefix = "Gtk";
		else if ( startsWith(gName, "Gdk") )        prefix = "Gdk";
		else if ( startsWith(gName, "Gst") )        prefix = "Gst";
		else if ( startsWith(gName, "Gda") )        prefix = "Gda";
		else if ( startsWith(gName, "Atk") )        prefix = "Atk";
		else if ( startsWith(gName, "G") )          prefix = "G";
		else if ( startsWith(gName, "Pango") )      prefix = "Pg";
		else if ( startsWith(gName, "cairo") )      prefix = "cairo";

		conv = gName[prefix.length..gName.length];

		if ( conv == "Object" ) conv ~= prefix;
		if ( prefix == "Pg" )   conv = "Pg" ~ gName[5..gName.length];
		if ( prefix == "cairo") conv = toupper(gName[6..7]) ~ gName[7..gName.length - 2];

		prefix = tolower(prefix);

		if( prefix == "gst") prefix = "gstreamer";
		if( prefix == "g")   prefix = "gobject";
		if( prefix == "pg" ) prefix = "pango";

		return prefix ~"."~ conv ~"."~ conv;
	}

	private bool startsWith(string str, string prefix)
	{
		return str.length >= prefix.length && str[0..prefix.length] == prefix;
	}

	version(LDC)
	{
		//version( !D_Version2 )
		version(D_Version2) {} else
		{
			private Object _d_newclass(ClassInfo ci)
			{
				void* p = cast(void*)_d_allocclass(ci);
				(cast(byte*) p)[0 .. ci.init.length] = ci.init[];
			
				return cast(Object) p;
			}

			private ClassInfo findClassInfo(string classname)
			{
				foreach ( m; ModuleInfo )
				{
					foreach ( c; m.localClasses )
					{
						if ( c.name == classname )
						return c;
					}
				}

				return null;
			}
		}
	}
code: end
outFile: Builder

###########################################################
### Application support ###################################
###########################################################

file: GtkApplication.html
struct: GtkApplication
class: Application
extend: GioApplication
prefix: gtk_application_
import: glib.Str
import: glib.ListG
import: glib.Variant
import: gio.Application : GioApplication = Application
import: gio.MenuModel
import: gtk.Window
structWrap: GList* ListG
structWrap: GVariant* Variant
structWrap: GMenuModel* MenuModel
structWrap: GtkWindow* Window
outFile: Application

file: GtkApplicationWindow.html
struct: GtkApplicationWindow
class: ApplicationWindow
implements: ActionGroupIF
implements: ActionMapIF
prefix: gtk_application_window_
import: gtk.Application
structWrap: GtkApplication* Application

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

#imports for ActionMap Interface.
import: gio.ActionMapIF
import: gio.ActionMapT

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GtkApplicationWindow);

	// add the ActionMap capabilities
	mixin ActionMapT!(GtkApplicationWindow);
code: end
outFile: ApplicationWindow

file: GtkActionable.html
struct: GtkActionable
class: ActionableT
template: TStruct
prefix: gtk_actionable_
import: glib.Str
import: glib.Variant
structWrap: GVariant* Variant
interface: ActionableIF
outFile: ActionableT

