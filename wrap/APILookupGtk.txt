#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping Gtk
#####
###
#

# must start with wrap



addTypedefs: start
public import gtkc.cairotypes;
public import gtkc.glibtypes;
public import gtkc.gobjecttypes;
public import gtkc.giotypes;
public import gtkc.pangotypes;
public import gtkc.atktypes;
public import gtkc.gdkpixbuftypes;
public import gtkc.gdktypes;

version(LLVM) 
{
	extern (C) Object _d_allocclass(ClassInfo ci);
}
else
{
	extern(C) Object _d_newclass(ClassInfo ci);
}

alias void GtkAccelGroupEntry;
alias void GtkContainerClass;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start

struct GtkObjectClass
{
	GObjectClass parentClass;
	void function(GtkObject*, GtkArg*, uint) setArg;
	void function(GtkObject*, GtkArg *, uint) getArg;
	void function(GtkObject*) destroy;
}

public struct GtkWidgetClass
{
	/* The object class structure needs to be the first
	 * element inn the widget class structure inn order for
	 * the class mechanism to work correctly. This allows a
	 * GtkWidgetClass pointer to be cast to a GtkObjectClass
	 * pointer.
	 */
	GtkObjectClass parentClass;
	/**/
	uint activateSignal;
	uint setScrollAdjustmentsSignal;
	/**/
	/* seldomly overidden */
	extern(C) void  function(GtkWidget *widget,uint nPspecs,GParamSpec **pspecs) dispatchChildPropertiesChanged;
	/* basics */
	extern(C) void  function(GtkWidget *widget)  show;
	extern(C) void  function(GtkWidget *widget)  showAll;
	extern(C) void  function(GtkWidget *widget)  hide;
	extern(C) void  function(GtkWidget *widget)  hideAll;
	extern(C) void  function(GtkWidget *widget)  map;
	extern(C) void  function(GtkWidget *widget)  unmap;
	extern(C) void  function(GtkWidget *widget)  realize;
	extern(C) void  function(GtkWidget *widget)  unrealize;
	extern(C) void  function(GtkWidget *widget,GtkRequisition *requisition)  sizeRequest;
	extern(C) void  function(GtkWidget *widget,GtkAllocation *allocation)  sizeAllocate;
	extern(C) void  function(GtkWidget *widget,GtkStateType previousState)  stateChanged;
	extern(C) void  function(GtkWidget *widget,GtkWidget *previousParent)  parentSet;
	extern(C) void  function(GtkWidget *widget,GtkWidget *previousToplevel)  hierarchyChanged;
	extern(C) void  function(GtkWidget *widget,GtkStyle *previousStyle)  styleSet;
	extern(C) void  function(GtkWidget *widget,GtkTextDirection previousDirection)  directionChanged;
	extern(C) void  function(GtkWidget *widget,int wasGrabbed)  grabNotify;
	extern(C) void  function(GtkWidget *widget,GParamSpec *pspec)  childNotify;
	/* Mnemonics */
	extern(C) int  function(GtkWidget *widget,int groupCycling)  mnemonicActivate;
	/* explicit focus */
	extern(C) void  function(GtkWidget *widget)  grabFocus;
	extern(C) int  function(GtkWidget *widget,GtkDirectionType direction)  focus;
	/* events */
	extern(C) int  function(GtkWidget *widget,GdkEvent *event)  event;
	extern(C) int  function(GtkWidget *widget,GdkEventButton *event)  buttonPressEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventButton *event)  buttonReleaseEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventScroll *event)  scrollEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventMotion *event)  motionNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  deleteEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  destroyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventExpose *event)  exposeEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventKey *event)  keyPressEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventKey *event)  keyReleaseEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventCrossing *event)  enterNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventCrossing *event)  leaveNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventConfigure *event)  configureEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventFocus *event)  focusInEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventFocus *event)  focusOutEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  mapEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  unmapEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProperty *event)  propertyNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionClearEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionRequestEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProximity *event)  proximityInEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProximity *event)  proximityOutEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventVisibility *event)  visibilityNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventClient *event)  clientEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  noExposeEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventWindowState *event)  windowStateEvent;
	/* selection */
	extern(C) void  function(GtkWidget *widget,GtkSelectionData *selectionData,uint info,uint time)  selectionGet;
	extern(C) void  function(GtkWidget *widget,GtkSelectionData *selectionData,uint time)  selectionReceived;
	/* Source side drag signals */
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragBegin;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragEnd;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,GtkSelectionData *selectionData,uint info,uint time)  dragDataGet;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragDataDelete;
	/* Target side drag signals */
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,uint time)  dragLeave;
	extern(C) int  function(GtkWidget *widget,GdkDragContext *context,int x,int y,uint time)  dragMotion;
	extern(C) int  function(GtkWidget *widget,GdkDragContext *context,int x,int y,uint time)  dragDrop;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,int x,int y,GtkSelectionData *selectionData,uint info,uint time)  dragDataReceived;
	/* Signals used only for keybindings */
	extern(C) int  function(GtkWidget *widget)  popupMenu;
	/* If a widget has multiple tooltips/whatsthis, it should show the
	 * one for the current focus location, or if that doesn't make
	 * sense, should cycle through them showing each tip alongside
	 * whatever piece of the widget it applies to.
	*/
	extern(C) int  function(GtkWidget *widget,GtkWidgetHelpType helpType)  showHelp;
	/* accessibility support
	*/
	extern(C) AtkObject*  function(GtkWidget *widget) getAccessible;
	extern(C) void  function(GtkWidget *widget,GdkScreen *previousScreen) screenChanged;
	extern(C) int  function(GtkWidget *widget,uint signalId) canActivateAccel;
	/* Sent when a grab is broken. */
	extern(C) int  function(GtkWidget *widget,GdkEventGrabBroken *event) grabBrokenEvent;
	extern(C) void  function(GtkWidget *widget)  compositedChanged;
	extern(C) int  function(GtkWidget *widget,int x,int y,int keyboardTooltip,GtkTooltip *tooltip)  queryTooltip;
	/* Padding for future expansion */
	extern(C) void  function() _GtkReserved5;
	extern(C) void  function() _GtkReserved6;
	extern(C) void  function() _GtkReserved7;
}

struct GtkTextIter
{
	/* GtkTextIter is an opaque datatype; ignore all these fields.
	* Initialize the iter with gtk_text_buffer_get_iter_*
	* functions
	*/
	/*< private >*/
	gpointer dummy1;
	gpointer dummy2;
	gint dummy3;
	gint dummy4;
	gint dummy5;
	gint dummy6;
	gint dummy7;
	gint dummy8;
	gpointer dummy9;
	gpointer dummy10;
	gint dummy11;
	gint dummy12;
	/* padding */
	gint dummy13;
	gpointer dummy14;
}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end



wrap: gtk

###########################################################
### Core Reference ########################################
###########################################################


file: gtk-General.html

#struct: 
class: Main
#prefix: 
prefix: gtk_main_
prefix: gtk_
noprefix: gtk_true
noprefix: gtk_false
noprefix: gtk_timeout_
noprefix: gtk_idle_
#import: g.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.ErrorG
import: glib.GException
#import: g.OptionGroup
#structWrap: GOptionGroup* OptionGroup
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
import:  pango.PgLanguage
structWrap: PangoLanguage* PgLanguage
import: glib.Str
import: gtkc.gtk
import: gthread.Thread
import: gdk.Threads

inout: gtk_parse_args argv
array: gtk_parse_args argv argc
inout: gtk_init_check argv
array: gtk_init_check argv argc
inout: gtk_init_with_args argv
array: gtk_init_with_args argv argc
array: gtk_init_with_args entries
out: gtk_get_current_event_state state

alias: main run

code: start

	/**
	 * Call this function before using any other GTK+ functions in your GUI applications.
	 */
	public static void init(string[] args)
	{
		char** argv = (new char*[args.length]).ptr;
		int argc = 0;
		foreach (string p; args)
		{
			argv[argc++] = cast(char*)p;
		}
		
		init(&argc,&argv);
	}
	
	/**
	 * This initiates GtkD to supports multi threaded programs.
	 * read full documantation at http://gtk.org/faq/#AEN482
	 * from the FAQ:
	 * "There is a single global lock that you must acquire with 
	 * gdk_threads_enter() before making any GDK calls, 
	 * and release with gdk_threads_leave() afterwards throughout your code."
	 * This is to be used on any call to GDK not executed from the main thread.
	 */
	public static void initMultiThread(string[] args)
	{
		Thread.init(null);
		gdkThreadsInit();
		init(args);
	}
	
code: end
outFile: Main

class: Timeout
prefix: gtk_timeout_
strictPrefix: Y
code: start
	/** Holds all timeout delegates */
	bool delegate()[] timeoutListeners;
	/** our gtk timeout ID */
	uint timeoutID;

	 
	/**
	 * Creates a new timeout cycle.
	 * Params:
	 *    	interval = 	the timeout in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(uint interval, bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = gtk_timeout_add(interval, cast(GtkFunction)&timeoutCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( timeoutID > 0 )
		{
			gtk_timeout_remove(timeoutID);
		}
		timeoutListeners.length = 0;
	}
	
	/**
	 * Removes the timeout from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this timeout cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = timeoutListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	timeout = 	
	 * Returns: 
	 */
	extern(C) static bool timeoutCallback(Timeout timeout)
	{
		return timeout.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<timeoutListeners.length )
		{
			if ( !timeoutListeners[i]() )
			{
				timeoutListeners = timeoutListeners[0..i] ~ timeoutListeners[i+1..timeoutListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Timeout

class: Idle
prefix: gtk_idle_
strictPrefix: Y
code: start
	/** Holds all idle delegates */
	bool delegate()[] idleListeners;
	/** our gtk idle ID */
	uint idleID;

	/**
	 * Creates a new idle cycle.
	 * Params:
	 *    	interval = the idle in milieconds
	 *    	dlg = the delegate to be executed
	 *    	fireNow = When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		idleID = gtk_idle_add(cast(GtkFunction)&idleCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( idleID > 0 )
		{
			gtk_idle_remove(idleID);
		}
		idleListeners.length = 0;
	}
	
	/**
	 * Removes the idle from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this idle cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = idleListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	idle = 	
	 * Returns: 
	 */
	extern(C) static bool idleCallback(Idle idle)
	{
		return idle.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<idleListeners.length )
		{
			if ( !idleListeners[i]() )
			{
				idleListeners = idleListeners[0..i] ~ idleListeners[i+1..idleListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Idle


file: gtk-Keyboard-Accelerators.html
struct:  GtkAccelGroup
class: AccelGroup
prefix: gtk_accel_group_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
#import: gtk.AccelGroupEntry
#structWrap: GtkAccelGroupEntry* AccelGroupEntry
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListSG
structWrap: GSList* ListSG
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType

array: gtk_accel_group_query Return n_entries
out: gtk_accelerator_parse accelerator_key
out: gtk_accelerator_parse accelerator_mods

outFile: AccelGroup

file: gtk-Accelerator-Maps.html
struct:  GtkAccelMap
class: AccelMap
prefix: gtk_accel_map_
prefix: gtk_
import: glib.Str
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
import: glib.ScannerG
structWrap: GScanner* ScannerG
import: gtk.AccelMap
structWrap: GtkAccelMap* AccelMap
out: gtk_accel_map_lookup_entry key
outFile: AccelMap

file: gtk-Clipboards.html
struct: GtkClipboard
class: Clipboard
prefix: gtk_clipboard_
prefix: gtk_
import: glib.Str
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData

array: gtk_clipboard_set_with_data targets n_targets
array: gtk_clipboard_set_with_owner targets n_targets
out: gtk_clipboard_wait_for_rich_text format
array: gtk_clipboard_wait_for_rich_text Return length
out: gtk_clipboard_wait_for_targets targets
array: gtk_clipboard_wait_for_targets targets n_targets
array: gtk_clipboard_set_can_store targets n_targets

outFile: Clipboard

file: gtk-Drag-and-Drop.html
struct: GdkDragContext
class: DragAndDrop
prefix: gtk_drag_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.DragContext
structWrap: GdkDragContext* DragContext
import: gtk.TargetList
structWrap: GtkTargetList* TargetList
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
outFile: DragAndDrop

array: gtk_drag_dest_set targets n_targets
array: gtk_drag_source_set targets n_targets

file: GtkIconTheme.html

struct: GtkIconTheme
class: IconTheme
prefix: gtk_icon_theme_
noprefix: gtk_icon_info_
prefix: gtk_
import: glib.Str
import: gio.IconIF
structWrap: GIcon* IconIF
structWrap: GtkIconTheme* IconTheme
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.ErrorG
import: glib.GException
import: glib.ListG
structWrap: GList* ListG
outFile: IconTheme

struct: GtkIconInfo
class: IconInfo
prefix: gtk_icon_info_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gtk.IconTheme
structWrap: GtkIconTheme* IconTheme
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

out: gtk_icon_info_get_embedded_rect rectangle
out: gtk_icon_info_get_attach_points points
array: gtk_icon_info_get_attach_points points n_points

outFile: IconInfo

file: gtk-Stock-Items.html
struct: GtkStockItem
class: StockItem
prefix: gtk_stock_
prefix: gtk_
import: glib.Str
import: gtk.StockItem
structWrap: GtkStockItem* StockItem
import: glib.ListSG
structWrap: GSList* ListSG
outFile: StockItem

file: gtk-Themeable-Stock-Images.html
struct: GtkIconSource
class: IconSource
prefix: gtk_icon_source_
#prefix: gtk_
noprefix: gtk_icon_factory_
noprefix: gtk_icon_set_
noprefix: gtk_icon_size_

import: glib.Str
structWrap: GtkIconSource* IconSource
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
outFile: IconSource

struct: GtkIconFactory
class: IconFactory
prefix: gtk_icon_factory_
strictPrefix: Y
import: glib.Str
structWrap: GtkIconFactory* IconFactory
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
outFile: IconFactory

struct: GtkIconSet
class: IconSet
prefix: gtk_icon_set_
strictPrefix: Y
import: glib.Str
structWrap: GtkIconSet* IconSet
import: gtk.IconSource
structWrap: GtkIconSource* IconSource
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
out: gtk_icon_set_get_sizes sizes
array: gtk_icon_set_get_sizes sizes n_sizes
outFile: IconSet

class: IconSize
prefix: gtk_icon_size_
strictPrefix: Y
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings

out: gtk_icon_size_lookup width
out: gtk_icon_size_lookup height
out: gtk_icon_size_lookup_for_settings width
out: gtk_icon_size_lookup_for_settings height

outFile: IconSize

file: gtk-Resource-Files.html
struct: GtkRcStyle
class: RcStyle
prefix: gtk_rc_
prefix: gtk_
import: glib.ScannerG
structWrap: GScanner* ScannerG
import: glib.Str
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Color
structWrap: GdkColor* Color
#import: gtk.StateType
#structWrap: GtkStateType* StateType
#import: gtk.PathPriorityType
#structWrap: GtkPathPriorityType* PathPriorityType
structWrap: GtkRcStyle* RcStyle

array: gtk_rc_set_default_files filenames
out: gtk_rc_parse_state state
out: gtk_rc_parse_priority priority

outFile: RcStyle

file: GtkSettings.html
struct: GtkSettings
class: Settings
prefix: gtk_settings_
prefix: gtk_
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: glib.StringG
structWrap: GString* StringG
import: gobject.Value
structWrap: GValue* Value
#import: gtk.SettingsValue
#structWrap: GtkSettingsValue* SettingsValue
outFile: Settings

file: gtk-Bindings.html
struct: GtkBindingSet
class: BindingSet
prefix: gtk_binding_set_
prefix: gtk_bindings_
prefix: gtk_
import: glib.Str
import: gtk.BindingSet
structWrap: GtkBindingSet* BindingSet
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: glib.ListSG
structWrap: GSList* ListSG
import: glib.ScannerG
structWrap: GScanner* ScannerG
outFile: BindingSet

file: gtk-Standard-Enumerations.html
#struct: 
class: StandardEnumerations
#prefix: 
#prefix: gtk_
outFile: StandardEnumerations

file: gtk-Graphics-Contexts.html
#struct: 
class: GCs
prefix: gtk_gc_
prefix: gtk_
import: gdk.GC
structWrap: GdkGC* GC
import: gdk.Colormap
structWrap: GdkColormap* Colormap
#import: gdk.GCValues
#structWrap: GdkGCValues* GCValues
outFile: GCs

file: GtkStyle.html
struct: GtkStyle
class: Style
prefix: gtk_style_
prefix: gtk_
noprefix: gtk_border_
import: glib.Str
structWrap: GtkStyle* Style
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.IconSource
structWrap: GtkIconSource* IconSource
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Font
structWrap: GdkFont* Font
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gobject.Value
structWrap: GValue* Value
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
nocode: gtk_style_ref
nocode: gtk_style_unref

array: gtk_draw_polygon points npoints
array: gtk_paint_polygon points npoints

outFile: Style

struct: GtkBorder
class: Border
prefix: gtk_border_
structWrap: GtkBorder* Border
strictPrefix: Y
outFile: Border

file: gtk-Selections.html
struct: GtkTargetList
class: TargetList
prefix: gtk_target_list_
noprefix: gtk_selection_
#import: gdk.Atom
#structWrap: GdkAtom* Atom
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTargetList* TargetList

array: gtk_target_list_new targets ntargets
array: gtk_target_list_add_table targets ntargets
out: gtk_target_list_find info
array: gtk_target_table_free targets ntargets
array: gtk_target_table_new_from_list Return n_targets
array: gtk_targets_include_image targets n_targets
array: gtk_targets_include_text targets n_targets
array: gtk_targets_include_uri targets n_targets
array: gtk_targets_include_rich_text targets n_targets

outFile: TargetList

#struct: 
class: Selections
prefix: gtk_selection_
strictPrefix: Y
import: glib.Str
import: gdk.Display
structWrap: GdkDisplay* Display
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer

array: gtk_selection_add_targets targets ntargets
array: gtk_selection_data_set data length
array: gtk_selection_data_set_uris uris
out: gtk_selection_data_get_targets targets
array: gtk_selection_data_get_targets targets n_atoms

outFile: Selections

file: gtk-Feature-Test-Macros.html
#struct: 
class: Version
prefix: gtk_
import: glib.Str
import: gtkc.Loader
import: gtkc.paths

code: start
	/*
	 * The major version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 2.)
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int major()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_major_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}

	/*
	 * The minor version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 12.) 
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int minor()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_minor_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}

	/*
	 * The micro version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 4.) 
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int micro()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_micro_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}
code: end
outFile: Version

file: gtk-Signals.html
#struct: 
class: Signals
prefix: gtk_signal_
prefix: gtk_
import: glib.Str
#import: gtk.Type
#structWrap: GtkType* Type
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gtk.Arg
#structWrap: GtkArg* Arg

array: gtk_signal_newv args n_args
array: gtk_signal_emitv args
array: gtk_signal_emitv_by_name args

outFile: Signals

file: gtk-Types.html
struct: GtkType
class: Types
prefix: gtk_type_
prefix: gtk_
import: glib.Str
#import: gtk.TypeInfo
#structWrap: GtkTypeInfo* TypeInfo
#import: gtk.EnumValue
#structWrap: GtkEnumValue* EnumValue
#import: gtk.FlagValue
#structWrap: GtkFlagValue* FlagValue
outFile: Types

file: gtk-Testing.html
class: Testing
prefix: gtk_test_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.SpinButton
structWrap: GtkSpinButton* SpinButton

code: start
	/**
	 * This function is used to initialize a GTK+ test program.
	 * It will in turn call g_test_init() and gtk_init() to
	 * properly initialize the testing framework and graphical toolkit.
	 * It'll also set the program's locale to "C" and prevent loading of
	 * rc files and Gtk+ modules. This is done to make tets program environments as deterministic as possible.
	 * Like gtk_init() and g_test_init(), any known arguments will be processed and stripped from argc and argv.
	 * Params:
	 *  argvp = Address of the argv parameter of main(). Any parameters understood by g_test_init() or gtk_init() are stripped before return. 
	 */
	public static void testInit(ref string[] argv)
	{
		// void gtk_test_init(int *argcp, char ***argvp, ...);
		char** outargv = Str.toStringzArray(argv);
		int argc = cast(int) argv.length;
		
		gtk_test_init(&argc, &outargv, null);
		
		argv = Str.toStringArray(outargv);
	}
code: end
outFile: Testing

file: gtk-Filesystem-utilities.html
struct: GtkMountOperation
ctorStruct: GMountOperation
class: MountOperation
extend: GioMountOperation
prefix: gtk_mount_operation_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.Window
structWrap: GtkWindow* Window
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gio.MountOperation : GioMountOperation = MountOperation
outFile: MountOperation

###########################################################
### Windows ###############################################
###########################################################

file: GtkDialog.html
struct: GtkDialog
class: Dialog
prefix: gtk_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.HButtonBox
import: gtk.VBox

array: gtk_dialog_set_alternative_button_order_from_array new_order n_params

# Make these return the correct class.
nocode: gtk_dialog_get_action_area
nocode: gtk_dialog_get_content_area

code: start
	/**
	 * Both title and parent can be null.
	 */
	this(string title, Window parent, GtkDialogFlags flags, string[] buttonsText, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(buttonsText[0]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(buttonsText[1 .. $], responses[1 .. $]);
	}
	
	/** ditto */
	this(string title, Window parent, GtkDialogFlags flags, StockID[] stockIDs, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(StockDesc[stockIDs[0]]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(stockIDs[1 .. $], responses[1 .. $]);
	}

	/** */
	public Widget addButton(StockID stockID, int responseId)
	{
		return addButton(StockDesc[stockID], responseId);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	//Return the corect class instead of Widget
	/**
	 * Returns the action area of dialog.
	 * Since 2.14
	 * Returns: the action area.
	 */
	public HButtonBox getActionArea()
	{
		// GtkWidget* gtk_dialog_get_action_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_action_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new HButtonBox(cast(GtkHButtonBox*) p);
	}
	
	//Return the corect class instead of Widget
	/**
	 * Returns the content area of dialog.
	 * Since 2.14
	 * Returns: the content area GtkVBox.
	 */
	public VBox getContentArea()
	{
		// GtkWidget* gtk_dialog_get_content_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_content_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new VBox(cast(GtkVBox*) p);
	}
code: end
outFile: Dialog

file: GtkInvisible.html
struct: GtkInvisible
class: Invisible
prefix: gtk_invisible_
prefix: gtk_
import: gdk.Screen
structWrap: GdkScreen* Screen

override: getScreen

outFile: Invisible

file: GtkMessageDialog.html
struct: GtkMessageDialog
class: MessageDialog
prefix: gtk_message_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_message_dialog_new
nocode: gtk_message_dialog_new_with_markup

code: start
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text the
	 * user may want to see. When the user clicks a button a "response"
	 * signal is emitted with response IDs from GtkResponseType. See
	 * GtkDialog for more details.
	 * Params:
	 *    	parent = transient parent, or NULL for none
	 *    	flags = flags
	 *    	type = type of message
	 *    	buttons= set of buttons to use
	 *    	messageFormat = printf()-style format string, or NULL
	 *    	message = the message - should be null, any formatting should be done prior to call this constructor
	 *  arguments for message_format
	 * Returns:
	 *  a new GtkMessageDialog
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, string messageFormat, string message=null )
	{
		this(parent, flags, type, buttons, false, messageFormat, message );
	}
	
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text which
	 * is marked up with the Pango text markup language.
	 * When the user clicks a button a "response" signal is emitted with
	 * response IDs from GtkResponseType. See GtkDialog for more details.
	 * 
	 * If Markup is true special XML characters in the printf() arguments passed to this
	 * function will automatically be escaped as necessary.
	 * (See g_markup_printf_escaped() for how this is implemented.)
	 * Usually this is what you want, but if you have an existing
	 * Pango markup string that you want to use literally as the
	 * label, then you need to use gtk_message_dialog_set_markup()
	 * instead, since you can't pass the markup string either
	 * as the format (it might contain '%' characters) or as a string
	 * argument.
	 * Since 2.4
	 * Examples:
	 * --------------------
	 *  GtkWidget *dialog;
	 *  dialog = gtk_message_dialog_new (main_application_window,
	 *  GTK_DIALOG_DESTROY_WITH_PARENT,
	 *  GTK_MESSAGE_ERROR,
	 *  GTK_BUTTONS_CLOSE,
	 *  NULL);
	 *  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog),
	 *  markup);
	 * --------------------
	 * Params:
	 *  parent = transient parent, or NULL for none
	 *  flags = flags
	 *  type = type of message
	 *  buttons = set of buttons to use
	 *  messageFormat = printf()-style format string, or NULL
	 *  message = the message - should be null, any formatting should be done prior to call this constructor
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, bool markup, string messageFormat, string message=null )
	{
		GtkMessageDialog* p;

		if ( markup )
		{
			// GtkWidget* gtk_message_dialog_new_with_markup  (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new_with_markup(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}
		else
		{
			// GtkWidget* gtk_message_dialog_new (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new()");
		}

		this(p);
	}
	
code: end

outFile: MessageDialog

file: 
class: PopupBox
import: gtk.MessageDialog;
import: gtk.Window;

code: start
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(string message, string title)
	{
		information(null, message, title);
	}
	
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.INFO,
										ButtonsType.OK ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-info",GtkResponseType.GTK_RESPONSE_OK);
		d.run();
		d.destroy();
	}
	
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(string message, string title)
	{
		error(null, message, title);
	}
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.ERROR,
										ButtonsType.CANCEL ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-error",ResponseType.GTK_RESPONSE_CANCEL);
		d.run();
		d.destroy();
	}
	
	
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(string message, string title)
	{
		return yesNo(null, message, title);
	}
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.GTK_RESPONSE_NO);
		d.addButton("gtk-yes",ResponseType.GTK_RESPONSE_YES);
		int responce = d.run();
		d.destroy();
		return responce == ResponseType.GTK_RESPONSE_YES;
	}

	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(string message, string title)
	{
		return yesNoCancel(null, message, title);
	}
	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.GTK_RESPONSE_NO);
		d.addButton("gtk-yes",ResponseType.GTK_RESPONSE_YES);
		d.addButton("gtk-cancel",ResponseType.GTK_RESPONSE_CANCEL);
		ResponseType responce = cast(ResponseType)d.run();
		d.destroy();
		return responce;
	}
code: end
outFile: PopupBox

file: GtkWindow.html
struct: GtkWindow
class: Window
prefix: gtk_window_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gdk.Geometry
#structWrap: GdkGeometry* Geometry
structWrap: GtkWindow* Window
import: gtk.WindowGroup
structWrap: GtkWindowGroup* WindowGroup
import: gdk.Screen
structWrap: GdkScreen* Screen
import: glib.ListG
structWrap: GList* ListG
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

override: getScreen

out: gtk_window_get_size width
out: gtk_window_get_size height
out: gtk_window_get_default_size width
out: gtk_window_get_default_size height
out: gtk_window_get_frame_dimensions left
out: gtk_window_get_frame_dimensions top
out: gtk_window_get_frame_dimensions right
out: gtk_window_get_frame_dimensions bottom
out: gtk_window_get_position root_x
out: gtk_window_get_position root_y

code: start
	/**
	 * Creates a top level window with a title
	 * Params:
	 * 		title = The Window title
	 */
	public this(string title)
	{
		this(GtkWindowType.TOPLEVEL);
		setTitle(title);
	}

	/**
	 * Move the window to an absolute position.
	 * just calls move(int, int).
	 * convinience because GdkEvent structs return the position coords as doubles
	 */
	public void move(double x, double y)
	{
		move(cast(int)x, cast(int)y);
	}
code: end
outFile: Window

file: 
import: gtk.Widget
import: gtk.Window
import: gtk.Main
import: gdk.Event
	

code: start

/**
 * A top Level window that will stop the main event cycle when it's closed.
 * Closing the last of the windows of class "MainWindow" will end the application.
 */
public class MainWindow : Window
{

	private static int countTotalMainWindows = 0;

	/**
	 * Creates a new MainWindow with a title
	 */
	public this(string title)
	{
		super(title);
		countTotalMainWindows++;
		//printf("MainWindows.this count = %d\n", countTotalMainWindows);
		addOnDelete(&windowDelete);
	}
	
	/**
	 * Executed when the user tries to close the window
	 * Returns: true to refuse to close the window
	 */
	protected bool windowDelete(Event event, Widget widget)
	{
		--countTotalMainWindows;
		//printf("MainWindows.windowDelete count = %d\n", countTotalMainWindows);
		if ( exit(0, false) || countTotalMainWindows==0 )
		{
			Main.quit();
			return false;
		}
		return false;
	}
	
	/**
	 * Allows the application to close and decide if it can exit
	 * Params:
	 *  code = the code reason to exit
	 *  force = if true the application must expect to be closed even against it's will
	 * Returns: false to refuse to exit
	 */
	protected bool exit(int code, bool force)
	{
		return force;
	}
}

code: end
outFile: MainWindow

file: GtkWindowGroup.html
struct: GtkWindowGroup
class: WindowGroup
prefix: gtk_window_group_
prefix: gtk_
import: glib.ListG
structWrap: GList* ListG
import: gtk.Window
structWrap: GtkWindow* Window
outFile: WindowGroup

file: GtkAboutDialog.html
struct: GtkAboutDialog
class: AboutDialog
prefix: gtk_about_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Window
structWrap: GtkWindow* Window

override: getName
override: setName

array: gtk_about_dialog_set_authors authors
array: gtk_about_dialog_set_artists artists
array: gtk_about_dialog_set_documenters documenters

outFile: AboutDialog

file: GtkAssistant.html
struct: GtkAssistant
class: Assistant
prefix: gtk_assistant_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Assistant

file: GtkOffscreenWindow.html
struct: GtkOffscreenWindow
class: OffscreenWindow
prefix: gtk_offscreen_window_
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: OffscreenWindow

###########################################################
### Display Widgets #######################################
###########################################################

file: GtkAccelLabel.html
struct: GtkAccelLabel
class: AccelLabel
prefix: gtk_accel_label_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgAttributeList
structWrap: PangoAttrList* PgAttributeList
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
outFile: AccelLabel

file: GtkImage.html
struct: GtkImage
class: Image
prefix: gtk_image_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdkpixbuf.PixbufAnimation
structWrap: GdkPixbufAnimation* PixbufAnimation
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap

out: gtk_image_get_icon_set icon_set
out: gtk_image_get_icon_set size
out: gtk_image_get_image gdk_image
out: gtk_image_get_image mask
out: gtk_image_get_pixmap pixmap
out: gtk_image_get_pixmap mask
out: gtk_image_get_stock stock_id
out: gtk_image_get_stock size
out: gtk_image_get_icon_name icon_name
out: gtk_image_get_icon_name size
out: gtk_image_get_gicon gicon
out: gtk_image_get_gicon size
out: gtk_image_get val
out: gtk_image_get mask

nocode: gtk_image_new_from_stock
nocode: gtk_image_new_from_icon_name

code: start
// this will be an enum 
	/**
	 * Creates a GtkImage displaying a stock icon. Sample stock icon
	 * names are GTK_STOCK_OPEN, GTK_STOCK_EXIT. Sample stock sizes
	 * are GTK_ICON_SIZE_MENU, GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
	 * icon name isn't known, the image will be empty.
	 * You can register your own stock icon names, see
	 * gtk_icon_factory_add_default() and gtk_icon_factory_add().
	 * Params:
	 *  StockID = a stock icon name
	 *  size = a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the stock icon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_stock (const gchar *stock_id,  GtkIconSize size);
		auto p = gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size)");
		}
		this(cast(GtkImage*)p);
	}
	
	/**
	 * Creates a GtkImage displaying an icon from the current icon theme.
	 * If the icon name isn't known, a "broken image" icon will be
	 * displayed instead. If the current icon theme is changed, the icon
	 * will be updated appropriately. Since 2.6
	 * Params:
	 *  iconName = an icon name
	 *  size = a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the themed icon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string iconName, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_icon_name (const gchar *icon_name,  GtkIconSize size);
		auto p = gtk_image_new_from_icon_name(Str.toStringz(iconName), size);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_new_from_icon_name(Str.toStringz(iconName), size)");
		}
		this(cast(GtkImage*)p);
	}
	
code: end

outFile: Image

file: GtkLabel.html
struct: GtkLabel
class: Label
prefix: gtk_label_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgAttributeList
structWrap: PangoAttrList* PgAttributeList
import: pango.PgLayout
structWrap: PangoLayout* PgLayout

out: gtk_label_get str
out: gtk_label_get_layout_offsets x
out: gtk_label_get_layout_offsets y
out: gtk_label_get_selection_bounds start
out: gtk_label_get_selection_bounds end

nocode: gtk_label_new
nocode: gtk_label_new_with_mnemonic
code: start
	/**
	 * Creates a new GtkLabel, containing the text in str.
	 * If characters in str are preceded by an underscore, they are
	 * underlined. If you need a literal underscore character in a label, use
	 * '__' (two underscores). The first underlined character represents a 
	 * keyboard accelerator called a mnemonic. The mnemonic key can be used 
	 * to activate another widget, chosen automatically, or explicitly using
	 * gtk_label_set_mnemonic_widget().
	 * If gtk_label_set_mnemonic_widget()
	 * is not called, then the first activatable ancestor of the GtkLabel
	 * will be chosen as the mnemonic widget. For instance, if the
	 * label is inside a button or menu item, the button or menu item will
	 * automatically become the mnemonic widget and be activated by
	 * the mnemonic.
	 * Params:
	 *  str = The text of the label, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = when false uses the literal text passed in without mnemonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string str, bool mnemonic=true)
	{
		GtkLabel* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_label_new_with_mnemonic (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new_with_mnemonic(Str.toStringz(str));
		}
		else
		{
			// GtkWidget* gtk_label_new (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new(Str.toStringz(str));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_label_new");
		}

		this(p);
	}
code: end
outFile: Label

file: GtkProgressBar.html
struct: GtkProgressBar
class: ProgressBar
prefix: gtk_progress_bar_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: ProgressBar

file: GtkStatusbar.html
struct: GtkStatusbar
class: Statusbar
import: glib.Str
prefix: gtk_statusbar_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Statusbar

file: GtkInfoBar.html
struct: GtkInfoBar
ctorStruct: GtkWidget
class: InfoBar
import: glib.Str
prefix:  gtk_info_bar_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.HBox;
import: gtk.VButtonBox

nocode: gtk_info_bar_get_action_area
nocode: gtk_info_bar_get_content_area

code: start
	/** */
	public this(string[] buttonsText, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}

	/** */
	public this(StockID[] stockIDs, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/** */
	public Widget addButton(StockID stockID, int responseId)
	{
		return addButton(StockDesc[stockID], responseId);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/**
	 * Returns the action area of info_bar.
	 * Since 2.18
	 * Returns: the action area.
	 */
	public VButtonBox getActionArea()
	{
		// GtkWidget * gtk_info_bar_get_action_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_action_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new VButtonBox(cast(GtkVButtonBox*) p);
	}
	
	/**
	 * Returns the content area of info_bar.
	 * Since 2.18
	 * Returns: the content area.
	 */
	public HBox getContentArea()
	{
		// GtkWidget * gtk_info_bar_get_content_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_content_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new HBox(cast(GtkHBox*) p);
	}
code: end
outFile: InfoBar

file: GtkStatusIcon.html
struct: GtkStatusIcon
class: StatusIcon
prefix: gtk_status_icon_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.Menu
structWrap: GtkMenu* Menu
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip

out: gtk_status_icon_position_menu x
out: gtk_status_icon_position_menu y
out: gtk_status_icon_position_menu push_in
out: gtk_status_icon_get_geometry screen
out: gtk_status_icon_get_geometry area
out: gtk_status_icon_get_geometry orientation

nocode: gtk_status_icon_new_from_stock
nocode: gtk_status_icon_new_from_file
nocode: gtk_status_icon_new_from_icon_name
#new_from_icon_name conflicts with new_from_file.

code: start
	/**
	 * Creates a status icon displaying a stock icon. Sample stock icon
	 * names are StockID.OPEN, StockID.QUIT. You can register your
	 * own stock icon names, see gtk_icon_factory_add_default() and
	 * gtk_icon_factory_add().
	 * Since 2.10
	 * Params:
	 *  stock_id = a stock icon id
	 * Returns:
	 *  a new GtkStatusIcon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID)
	{
		// GtkStatusIcon* gtk_status_icon_new_from_stock (const gchar *stock_id);
		auto p = gtk_status_icon_new_from_stock(Str.toStringz(StockDesc[stockID]));
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_stock");
		}
		this(cast(GtkStatusIcon*)p);
	}

	/**
	 * Creates a status icon displaying an icon from the current icon theme.
	 * If the current icon theme is changed, the icon will be updated
	 * appropriately.
	 * Since 2.10
	 * Params:
	 *  iconName =  an icon name
	 *  loadFromFile = treat iconName as a filename and load that image
	 *  with gtk_status_icon_new_from_file.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string iconName, bool loadFromFile = false)
	{
		//TODO: look at a better way to do this.
		GtkStatusIcon* p;

		if(loadFromFile)
		{
			// GtkStatusIcon* gtk_status_icon_new_from_file (const gchar *filename);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_file(Str.toStringz(iconName));
		}
		else
		{
			// GtkStatusIcon* gtk_status_icon_new_from_icon_name (const gchar *icon_name);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_icon_name(Str.toStringz(iconName));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_");
		}

		this(p);
	}
code: end
outFile: StatusIcon

file: GtkSpinner.html
struct: GtkSpinner
ctorStruct: GtkWidget
class: Spinner
prefix: gtk_spinner_
outFile: Spinner

###########################################################
### Buttons and Toggles ###################################
###########################################################

file: GtkButton.html
struct: GtkButton
class: Button
implements: ActivatableIF
prefix: gtk_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Image

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

out: gtk_button_get_alignment xalign
out: gtk_button_get_alignment yalign

nocode: gtk_button_new_with_mnemonic
nocode: gtk_button_new_with_label
nocode: gtk_button_new_from_stock

code: start
	private static IconSize currentIconSize = IconSize.BUTTON;

	/** An arbitrary string to be used by the application */
	private string action;

	// add the Activatable capabilities
	mixin ActivatableT!(GtkButton);

	/** */
	public static void setIconSize(IconSize iconSize)
	{
		currentIconSize = iconSize;
	}

	/** */
	public static IconSize getIconSize()
	{
		return currentIconSize;
	}

	/** */
	public void setActionName(string action)
	{
		this.action = action;
	}

	/** */
	public string getActionName()
	{
		return action;
	}

	/**
	 * Creates a new GtkButton containing a label.
	 * If characters in label are preceded by an underscore, they are underlined.
	 * If you need a literal underscore character in a label, use '__' (two
	 * underscores). The first underlined character represents a keyboard
	 * accelerator called a mnemonic.
	 * Pressing Alt and that key activates the button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Returns:
	 *  a new GtkButton
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_button_new_with_label (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new_with_label");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkButton containing the image and text from a stock item.
	 * Some stock ids have preprocessor macros like GTK_STOCK_OK and
	 * GTK_STOCK_APPLY.
	 * If stock_id is unknown, then it will be treated as a mnemonic
	 * label (as for gtk_button_new_with_mnemonic()).
	 * Params:
	 *  StockID = the name of the stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, bool hideLabel=false)
	{
		// GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
		if ( hideLabel )
		{
			this();
			Image image = new Image(stockID,currentIconSize);
			add(image);
		}
		else
		{
			auto p = gtk_button_new_from_stock(Str.toStringz(StockDesc[stockID]));

			if(p is null)
			{
				throw new ConstructionException("null returned by gtk_button_new_from_stock");
			}

			this(cast(GtkButton*) p);
		}
		
	}
	
	/** */
	public this(StockID stockID, void delegate(Button) dlg, bool hideLabel=false)
	{
		this(stockID, hideLabel);
		addOnClicked(dlg);
	}
	
	/** */
	public this(string label, void delegate(Button) dlg, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(dlg);
	}

	/** */
	public this(string label, void delegate(Button) dlg, string action)
	{
		this(label);
		setActionName(action);
		addOnClicked(dlg);
	}
	

code: end
outFile: Button

file: GtkCheckButton.html
struct: GtkCheckButton
class: CheckButton
import: glib.Str
import: gtk.Button
prefix: gtk_check_button_
prefix: gtk_

nocode: gtk_check_button_new_with_label
nocode: gtk_check_button_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckButton with a GtkLabel to the right of it.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the check button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_button_new_with_label (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_button_new_");
		}

		this(p);
	}

	/** */
	public this(string label, void delegate(CheckButton) onClicked, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(cast(void delegate(Button))onClicked);
	}
	
code: end

outFile: CheckButton

file: GtkRadioButton.html
struct: GtkRadioButton
class: RadioButton
prefix: gtk_radio_button_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioButton* RadioButton

nocode: gtk_radio_button_new_with_label
nocode: gtk_radio_button_new_with_mnemonic
nocode: gtk_radio_button_new_with_label_from_widget
nocode: gtk_radio_button_new_with_mnemonic_from_widget

code: start
	/**
	 * Creates a new RadioButton with a text label.
	 * Params:
	 *  group = an existing radio button group.
	 *  label = the text label to display next to the radio button.
	 *  mnemonic = if true the label will be created using
	 *  gtk_label_new_with_mnemonic(), so underscores in label indicate the
	 *  mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}
	
	/**
	 * Creates a new RadioButton with a text label, adding it to the same group
	 * as group.
	 * Params:
	 *  radioButton = an existing RadioButton.
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioButton radioButton, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic_from_widget(
						radioButton.getRadioButtonStruct(),
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label_from_widget(
						radioButton.getRadioButtonStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}

	/**
	 * Creates a new RadioButton with a text label,
	 * and creates a new group.
	 * Params:
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		this(cast(ListSG)null, label, mnemonic);
	}
code: end
outFile: RadioButton

file: GtkToggleButton.html
struct: GtkToggleButton
class: ToggleButton
prefix: gtk_toggle_button_
prefix: gtk_
import: glib.Str

nocode: gtk_toggle_button_new_with_label
nocode: gtk_toggle_button_new_with_mnemonic

code: start
	/**
	 * Creates a new toggle button with a text label.
	 * Params:
	 *  label = a string containing the message to be placed in the toggle button.
	 *  mnemonic =  if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkToggleButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_toggle_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_toggle_button_new_with_label  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_toggle_button_new_");
		}

		this(p);
	}
code: end

outFile: ToggleButton

file: GtkLinkButton.html
struct: GtkLinkButton
class: LinkButton
prefix: gtk_link_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: LinkButton

file: GtkScaleButton.html
struct: GtkScaleButton
class: ScaleButton
implements: OrientableIF
prefix: gtk_scale_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

nocode: gtk_scale_button_set_orientation
nocode: gtk_scale_button_get_orientation

array: gtk_scale_button_new icons
array: gtk_scale_button_set_icons icons

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkScaleButton);
code: end
outFile: ScaleButton

file: GtkVolumeButton.html
struct: GtkVolumeButton
class: VolumeButton
prefix: gtk_volume_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: VolumeButton

###########################################################
### numeric/text Data Entry ###############################
###########################################################

file: GtkEntry.html
struct: GtkEntry
class: Entry
implements: EditableIF
implements: CellEditableIF
prefix: gtk_entry_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.Border
structWrap: GtkBorder* Border
import: gtk.EntryBuffer
structWrap: GtkEntryBuffer* EntryBuffer
import: gtk.EntryCompletion
structWrap: GtkEntryCompletion* EntryCompletion
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
#Deprecated since 2.0 also shadowed setEditable in EditableIF
nocode: gtk_entry_select_region
nocode: gtk_entry_set_position
nocode: gtk_entry_set_editable

# imports for TreeModel Interface
import: gtk.EditableT
import: gtk.EditableIF

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

out: gtk_entry_get_layout_offsets x
out: gtk_entry_get_layout_offsets y

code: start
	// add the Editable capabilities
	mixin EditableT!(GtkEntry);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkEntry);

	/** */
	public this (string text)
	{
		this();
		setText(text);
	}

	/** */	
	public this (string text, int max)
	{
		this(max);
		setText(text);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId(GtkEntryIconPosition iconPos)
	{
		// const gchar* gtk_entry_get_icon_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos);
		string id = Str.toString(gtk_entry_get_icon_stock(gtkEntry, iconPos));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(GtkEntryIconPosition iconPos, StockID stockId)
	{
		// void gtk_entry_set_icon_from_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *stock_id);
		gtk_entry_set_icon_from_stock(gtkEntry, iconPos, Str.toStringz(StockDesc[stockId]));
	}
code: end

outFile: Entry

file: GtkEntryBuffer.html
struct: GtkEntryBuffer
class: EntryBuffer
prefix: gtk_entry_buffer_
import: glib.Str
array: gtk_entry_buffer_new initial_chars n_initial_chars
array: gtk_entry_buffer_set_text chars n_chars
array: gtk_entry_buffer_insert_text chars n_chars
array: gtk_entry_buffer_emit_inserted_text chars n_chars
outFile: EntryBuffer

file: GtkEntryCompletion.html
struct: GtkEntryCompletion
class: EntryCompletion
implements: CellLayoutIF
prefix: gtk_entry_completion_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkEntryCompletion);
code: end
outFile: EntryCompletion

file: GtkHScale.html
struct: GtkHScale
class: HScale
prefix: gtk_hscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScale

file: GtkVScale.html
struct: GtkVScale
class: VScale
prefix: gtk_vscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScale

file: GtkSpinButton.html
struct: GtkSpinButton
class: SpinButton
prefix: gtk_spin_button_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_spin_button_get_increments step
out: gtk_spin_button_get_increments page
out: gtk_spin_button_get_range min
out: gtk_spin_button_get_range max

outFile: SpinButton

file: GtkEditable.html
struct: GtkEditable
class: EditableT
template: TStruct
prefix: gtk_editable_
prefix: gtk_
import: glib.Str

inout: gtk_editable_insert_text position
out: gtk_editable_get_selection_bounds start
out: gtk_editable_get_selection_bounds end

interface: EditableIF
outFile: EditableT

###########################################################
### Multiline Text Editor #################################
###########################################################

file: gtk-GtkTextIter.html
struct: GtkTextIter
class: TextIter
nostruct: GtkTextIter
prefix: gtk_text_iter_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTextIter* TextIter
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: pango.PgLanguage
structWrap: PangoLanguage* PgLanguage

code: start
	/** */
	public this()
	{
		this(new GtkTextIter);
	}
	
code: end
outFile: TextIter

file: GtkTextMark.html
struct: GtkTextMark
class: TextMark
prefix: gtk_text_mark_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
outFile: TextMark

file: GtkTextBuffer.html
struct: GtkTextBuffer
class: TextBuffer
prefix: gtk_text_buffer_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gtk.TextTagTable
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gtk.TargetList
structWrap: GtkTargetList* TargetList
import: std.stdarg

array: gtk_text_buffer_deserialize data length
array: gtk_text_buffer_get_deserialize_formats Return n_formats
array: gtk_text_buffer_get_serialize_formats Return n_formats
array: gtk_text_buffer_serialize Return length

nocode: gtk_text_buffer_set_text
nocode: gtk_text_buffer_insert_with_tags
nocode: gtk_text_buffer_insert_with_tags_by_name
nocode: gtk_text_buffer_create_tag

code: start

	/**
	 * Deletes current contents of buffer, and inserts text instead. If
	 * len is -1, text must be nul-terminated. text must be valid UTF-8.
	 * Params:
	 *  text = UTF-8 text to insert
	 */
	public void setText(string text)
	{
		// void gtk_text_buffer_set_text (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_set_text(gtkTextBuffer, Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Inserts len bytes of text at position iter. If len is -1,
	 * text must be nul-terminated and will be inserted in its
	 * entirety. Emits the "insert_text" signal; insertion actually occurs
	 * in the default handler for the signal. iter is invalidated when
	 * insertion occurs (because the buffer contents change), but the
	 * default signal handler revalidates it to point to the end of the
	 * inserted text.
	 * Params:
	 *  iter = a position in the buffer
	 *  text = UTF-8 format text to insert
	 */
	public void insert(TextIter iter, string text)
	{
		// void gtk_text_buffer_insert (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len);
		gtk_text_buffer_insert(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Simply calls gtk_text_buffer_insert(), using the current
	 * cursor position as the insertion point.
	 * Params:
	 *  text = some text in UTF-8 format
	 */
	public void insertAtCursor(string text)
	{
		// void gtk_text_buffer_insert_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_insert_at_cursor(gtkTextBuffer, Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Like gtk_text_buffer_insert(), but the insertion will not occur if
	 * iter is at a non-editable location in the buffer. Usually you
	 * want to prevent insertions at ineditable locations if the insertion
	 * results from a user action (is interactive).
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * Params:
	 *  iter = a position in buffer
	 *  text = some UTF-8 text
	 *  defaultEditable = default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractive(TextIter iter, string text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, defaultEditable);
	}
	
	/**
	 * Calls gtk_text_buffer_insert_interactive() at the cursor
	 * position.
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * Params:
	 *  text = text in UTF-8 format
	 *  defaultEditable = default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractiveAtCursor(string text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive_at_cursor(gtkTextBuffer, Str.toStringz(text), cast(int) text.length, defaultEditable);
	}

	/**
	 * Inserts text into buffer at iter, applying the list of tags to
	 * the newly-inserted text. The last tag specified must be NULL to
	 * terminate the list. Equivalent to calling gtk_text_buffer_insert(),
	 * then gtk_text_buffer_apply_tag() on the inserted text;
	 * gtk_text_buffer_insert_with_tags() is just a convenience function.
	 * Params:
	 *  iter = an iterator in buffer
	 *  text = UTF-8 text
	 *  ... = NULL-terminated list of tags to apply
	 */
	//version(Tango){} else -- still doesn't work on tango, but it compiles now
	public void insertWithTags(TextIter iter, string text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(TextTag)); i++)
		{
			TextTag tag = va_arg!(TextTag)(_argptr);
			// void gtk_text_buffer_insert_with_tags  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  GtkTextTag *first_tag,  ...);
			gtk_text_buffer_insert_with_tags(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, (tag is null) ? null : tag.getTextTagStruct(), null);
		}
	}
	
	/**
	 * Same as gtk_text_buffer_insert_with_tags(), but allows you
	 * to pass in tag names instead of tag objects.
	 * Params:
	 *  iter = position in buffer
	 *  text = UTF-8 text
	 *  ... = more tag names
	 */
 	// version(Tango){} else  -- still doesn't work on tango, but it compiles now 
 	public void insertWithTagsByName(TextIter iter, string text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(string)); i++)
		{
			string tagName = va_arg!(string)(_argptr);
			// void gtk_text_buffer_insert_with_tags_by_name  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  const gchar *first_tag_name,  ...);
			gtk_text_buffer_insert_with_tags_by_name(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, Str.toStringz(tagName), null);
		}
	}
	
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */ 
	TextTag createTag(string tagName, string propertyName, int propertyValue, 
									   string propertyName1, string propertyValue1)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer,
				Str.toStringz(tagName), 
				Str.toStringz(propertyName),propertyValue,
				Str.toStringz(propertyName1),
				Str.toStringz(propertyValue1),
					null)
		);
			
	}
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, int propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, 
				Str.toStringz(tagName),
				Str.toStringz(propertyName),propertyValue,null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, double propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue,null)
		);
			
	}
	
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 *  propertyName2=
	 *  propertyValue2=
	 */
	TextTag createTag(string tagName, string propertyName, int propertyValue, string propertyName2, int propertyValue2)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, null)
		);
	}

	/** Create a new tag for this buffer */
	TextTag createTag(string tagName, string propertyName, int propertyValue, string propertyName2, int propertyValue2, string propertyName3, int propertyValue3, string propertyName4, int propertyValue4, string propertyName5, int propertyValue5)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, Str.toStringz(propertyName3), propertyValue3, Str.toStringz(propertyName4), propertyValue4, Str.toStringz(propertyName5), propertyValue5, null)
		);
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, string propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),Str.toStringz(propertyValue),null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName = can be null for no name
	 *  propertyName=
	 *  propertyValue= 
	 */
	TextTag createTag(string tagName, string propertyName, Bitmap propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue.getBitmapStruct(),null)
		);
			
	}

	/**
	 * Obtain the entire text 
	 * Returns: The text string
	 */
	string getText()
	{
		TextIter start = new TextIter();
		TextIter end = new TextIter();
		getBounds(start,end);
		return Str.toString(gtk_text_buffer_get_slice(gtkTextBuffer, start.getTextIterStruct(), end.getTextIterStruct(), true));
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 *  propertyName2=
	 *  propertyValue2=
	 */
	TextTag createTag(string tagName, 
			string propertyName, string propertyValue, 
			string propertyName2, int propertyValue2)
	{
		return new TextTag(
		gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), 
			Str.toStringz(propertyName), Str.toStringz(propertyValue), 
			Str.toStringz(propertyName2), propertyValue2, null)
		);
	}
	

code: end

outFile: TextBuffer

file: GtkTextTag.html

struct: GtkTextTag
class: TextTag
prefix: gtk_text_tag_
noprefix: gtk_text_attributes_
prefix: gtk_
import: glib.Str
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
outFile: TextTag

struct: GtkTextAttributes
class: TextAttributes
prefix: gtk_text_attributes_
strictPrefix: Y
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
outFile: TextAttributes

file: GtkTextTagTable.html
struct: GtkTextTagTable
class: TextTagTable
prefix: gtk_text_tag_
prefix: gtk_
import: glib.Str
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
outFile: TextTagTable

file: GtkTextView.html

struct: GtkTextView
class: TextView
prefix: gtk_text_view_
prefix: gtk_
noprefix: gtk_text_child_anchor_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: glib.ListG
structWrap: GList* ListG

out: gtk_text_view_get_line_at_y line_top
out: gtk_text_view_get_line_yrange y
out: gtk_text_view_get_line_yrange height
out: gtk_text_view_get_iter_at_position trailing
out: gtk_text_view_buffer_to_window_coords window_x
out: gtk_text_view_buffer_to_window_coords window_y
out: gtk_text_view_window_to_buffer_coords buffer_x
out: gtk_text_view_window_to_buffer_coords buffer_y

code: start

	/**
	 * Get the text line at the pixel y
	 */
	string getLineTextAt(gint y)
	{
		
		TextIter iter = new TextIter();
		int windowX;
		int windowY;
		bufferToWindowCoords(TextWindowType.TEXT, 0, y, windowX, windowY);

		gtk_text_view_get_line_at_y(gtkTextView, iter.getTextIterStruct(), y+y-windowY, null);
		
		TextIter iterEnd = new TextIter();
		TextBuffer buffer = getBuffer();
		buffer.getIterAtOffset(iterEnd, iter.getOffset()+iter.getCharsInLine());
		return buffer.getText(iter, iterEnd, false);
	}

	/**
	 * Simply appends some on the cursor position
	 * Params:
	 *  text = the text to append
	 */
	void insertText(string text)
	{
		TextBuffer buf = getBuffer();
		buf.insertAtCursor(text);
	}

	/**
	 * Simply appends some text to this view
	 * Params:
	 *  text = the text to append
	 */
	void appendText(string text, bool ensureVisible=true)
	body
	{
		TextBuffer buf = getBuffer();
		TextIter iter = new TextIter();
		buf.getEndIter(iter);
		buf.insert(iter, text);
		if ( ensureVisible )
		{
			gdouble within_margin = 0.0;
			bool use_align = false;
			gdouble xalign = 0.0;
			gdouble yalign = 0.0;
			scrollToMark(buf.createMark("",iter,true), within_margin, use_align, xalign, yalign);
		}
	}


code: end

outFile: TextView

struct: GtkTextChildAnchor
class: TextChildAnchor
import: glib.Str
prefix: gtk_text_child_anchor_
strictPrefix: Y
import: glib.ListG
structWrap: GList* ListG
outFile: TextChildAnchor

###########################################################
### Tree, List and Icon Grid Widgets ######################
###########################################################

file: GtkTreeModel.html

struct: GtkTreePath
class: TreePath
strictPrefix: Y
prefix: gtk_tree_path_
#prefix: gtk_
import: glib.Str
structWrap: GtkTreePath* TreePath

array: gtk_tree_path_get_indices Return getDepth()

override: toString

nocode: gtk_tree_path_new
nocode: gtk_tree_path_new_first

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * Creates a new GtkTreePath. This structure refers to a row.
	 * Params:
	 * firstRow = if true this is the string representation of this path is "0"
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool firstRow=false)
	{
		GtkTreePath* p;

		if ( firstRow )
		{
			// GtkTreePath* gtk_tree_path_new_first (void);
			p = cast(GtkTreePath*)gtk_tree_path_new_first();
		}
		else
		{
			// GtkTreePath* gtk_tree_path_new (void);
			p = cast(GtkTreePath*)gtk_tree_path_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_path_new()");
		}

		this(p);
	}
code: end
outFile: TreePath

struct: GtkTreeModel
class: TreeModelT
template: TStruct
prefix: gtk_tree_model_
noprefix: gtk_tree_row_reference_
noprefix: gtk_tree_path_
noprefix: gtk_tree_iter_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.Value
structWrap: GValue* Value
nocode: gtk_tree_model_get_value

array: gtk_tree_model_rows_reordered new_order

interfaceCode: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column);

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column);

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path);

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null);
interfaceCode: end

nocode: gtk_tree_model_get_iter

code: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getString();
	}

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getInt();
	}

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path)
	{
		// gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,  GtkTreeIter *iter,  GtkTreePath *path);
		iter.setModel(this);
		return gtk_tree_model_get_iter(
				getTreeModelTStruct(), 
				(iter is null) ? null : iter.getTreeIterStruct(), 
				(path is null) ? null : path.getTreePathStruct());
	}

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null)
	{
		if ( value is null )
			value = new Value();

		// void gtk_tree_model_get_value (GtkTreeModel *tree_model,  GtkTreeIter *iter,  gint column,  GValue *value);
		gtk_tree_model_get_value(getTreeModelTStruct(), (iter is null) ? null : iter.getTreeIterStruct(), column, (value is null) ? null : value.getValueStruct());

		return value;
	}
code: end

interface: TreeModelIF
outFile: TreeModelT


struct: GtkTreeIter
class: TreeIter
strictPrefix: Y
prefix: gtk_tree_iter_
#prefix: gtk_
import: glib.Str
structWrap: GtkTreeIter* TreeIter
import: gtk.TreeModelIF
import: gtk.TreePath
import: gtk.TreeIterError
import: gobject.Value

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * this will be set only when the iter
	 * is created from the model.
	 */
	GtkTreeModel* gtkTreeModel; 

	/** */
	public void setModel(GtkTreeModel* gtkTreeModel)
	{
		this.gtkTreeModel = gtkTreeModel;
	}

	/** */       
	public void setModel(TreeModelIF treeModel)
	{
		this.gtkTreeModel = treeModel.getTreeModelTStruct();
	}

	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, string treePath)
	{
		this(treeModel, new TreePath(treePath));
	}
	   
	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, TreePath treePath)
	{
		this();
		setModel(treeModel);
		if ( !gtk_tree_model_get_iter_from_string(
				treeModel.getTreeModelTStruct(),
				getTreeIterStruct(), Str.toStringz(treePath.toString())) )
		{
			throw new ConstructionException("null returned by gtk_tree_model_get_iter_from_string");
		}
	}
	
	/**
	* creates a new tree iteractor.
	* used TreeView.createIter and TreeView.append() to create iteractor for a tree or list
	*/
	this()
	{
		this(new GtkTreeIter);
	}

	/**
	 * Get Value
	 * Params:
	 *  column =
	 *  value =
	 */
	void getValue(int column, Value value)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValue","Tree model not set");
		}
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
	}

	/**
	 * Get the value of a column as a string
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	string getValueString(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueString","Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		//printf("TreeIter.getValuaString = %.*s\n", value.getString().toString());
		return value.getString();
	}

	/**
	 * Get the value of a column as an int
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	int getValueInt(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueInt", "Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		return value.getInt();
	}

	/** */
	TreePath getTreePath()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getTreePath","Tree model not set");
		}
		return new TreePath(gtk_tree_model_get_path(gtkTreeModel, gtkTreeIter));
	}

	/**
	 * This return the path visible to the user.
	 */
	string getVisiblePath(string separator)
	{
		string vPath;
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getVisiblePath", "Tree model not set");
		}

		vPath = getValueString(0);
		TreeIter parent = getParent();
		while ( parent !is  null )
		{
			//printf("TreeIter.getVisiblePath parent = %.*s\n",parent.getValueString(0).toString());
			vPath = parent.getValueString(0) ~ separator ~ vPath;
			parent = parent.getParent();
		}
		
		//printf("TreeIter.getVisiblePath = %.*s\n", vPath.toString());
		
		return vPath;
	}
	
	/**
	 * Gets the parent of this iter
	 * Returns: the parent iter or null if can't get parent or an error occured
	 */
	TreeIter getParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getParent", "Tree model not set");
		}
		TreeIter parent = new TreeIter();
		bool gotParent = gtk_tree_model_iter_parent(gtkTreeModel, parent.getTreeIterStruct(), gtkTreeIter) == 0 ? false : true;
		if ( !gotParent )
		{
			return null;
		}
		parent.setModel(gtkTreeModel);
		return parent;
	}

	/** */
	TreeIter getGrandParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getGrandParent", "Tree model not set");
		}
		TreeIter grandParent = this;
		TreeIter parent = grandParent.getParent();
		while ( parent !is null )
		{
			grandParent = parent;
			parent = grandParent.getParent();
		}
		
		return grandParent;
	}

	/** A unique stamp to catch invalid iterators */
	public int stamp()
	{
		return gtkTreeIter.stamp;
	}

	/** Ditto */
	public void stamp(int stamp)
	{
		gtkTreeIter.stamp = stamp;
	}

	/** Model specific data */
	public void* userData()
	{
		return gtkTreeIter.userData;
	}

	/** Ditto */
	public void userData(void* data)
	{
		gtkTreeIter.userData = data;
	}

	public struct IterData
	{
		/// Data fields.
		union
		{
			int     dataInt;
			long    dataLong;
			double  dataFloat;
			double  dataDouble;
			string  dataString;

			void*   dataUser;
		}

		TypeInfo type = typeid(void);
	}

	/**
	 * setUserData and getUserData provide simple boxing
	 * around the userData field in the TreeIter struct.
	 * Throws: TreeIterError for unsuported types or a type mismatch.
	 * Example:
	 * ---
	 * Treeiter iter = new TreeIter();
	 *
	 * iter.setUserData(20);
	 * int i = iter.getUserData!(int)();
	 * ---
	 */
	public void setUserData(T)(T data)
	{
		IterData* itData = new IterData;
		itData.type = typeid(T);

		static if(is(T == int))
		{
			itData.dataInt = data;
		}
		else static if(is(T == long))
		{
			itData.dataLong = data;
		}
		else static if(is(T == float))
		{
			itData.dataFloat = data;
		}
		else static if(is(T == double))
		{
			itData.dataDouble = data;
		}
		else static if(is(T == string))
		{
			itData.dataString = data;
		}
		else static if(is(T == void*))
		{
			itData.dataUser = data;
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}

		gtkTreeIter.userData = itData;
	}

	/** Ditto */
	public T getUserData(T)()
	{
		IterData* itData = cast(IterData*)gtkTreeIter.userData;

		static if(is(T == int))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataInt;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: int");
			}
		}
		else static if(is(T == long))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataLong;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: long");
			}
		}
		else static if(is(T == float))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataFloat;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: float");
			}
		}
		else static if(is(T == double))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataDouble;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: double");
			}
		}
		else static if(is(T == string))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataString;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: string");
			}
		}
		else static if(is(T == void*))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataUser;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: void*");
			}
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}
	}
code: end
outFile: TreeIter


struct: GtkTreeRowReference
class: TreeRowReference
strictPrefix: Y
prefix: gtk_tree_row_reference_
#prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeRowReference* TreeRowReference

array: gtk_tree_row_reference_reordered new_order

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

outFile: TreeRowReference

file:
class: TreeIterError
extend: Exception
import(tango): tango.core.Exception

code: start
	/**
	 * A TreeIter error.
	 * thrown<br>
	 * - trying to access a method that requires a tree model and the tree model was never set
	 */
	public this(string method, string message)
	{
		super("TreeIter."~method~" : "~message);
	}

code: end
outFile: TreeIterError



file:
import: glib.Str
import: gobject.Type
import: gobject.ObjectG
import: gobject.Signals
import: gobject.Value
import: gtk.TreeIter
import: gtk.TreePath
import: gtk.TreeModelT
import: gtk.TreeModelIF
import: gtkc.gobject
import: gtkc.Loader
import: gtkc.paths

code: start
struct CustomTreeModelClass
{
	GObjectClass parentClass;
}

//We need this function for the interface implementation.
extern(C) typedef GType function()c_gtk_tree_model_get_type;
c_gtk_tree_model_get_type gtk_tree_model_get_type;

/**
 */
public class TreeModel : ObjectG, TreeModelIF
{
	static GObjectClass* parentClass = null;
	
	static this()
	{
		Linker.link(gtk_tree_model_get_type, "gtk_tree_model_get_type", LIBRARY.GTK);
	}
	
	// Minimal implementation.
	mixin TreeModelT!(GtkTreeModel);
	
	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkTreeModel;
	}
	
	public this ()
	{
		auto p =  super(customTreeModelgetType(), null);
		gtkTreeModel = cast(GtkTreeModel*) p.getObjectGStruct();
		
		setDataFull("customTreeModel", cast(void*)this, cast(GDestroyNotify)&destroyNotify);
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkTreeModel* gtkTreeModel)
	{
		if(gtkTreeModel is null)
		{
			this = null;
			return;
		}
		
		//Check if there already is a D object for this gtk struct
		void* ptr = g_object_get_data(cast(GObject*) gtkTreeModel, Str.toStringz("customTreeModel"));
		if( ptr !is null )
		{
			this = cast(TreeModel)ptr;
			return;
		}
		
		super(cast(GObject*)gtkTreeModel);
		this.gtkTreeModel = gtkTreeModel;
	}
	
	
	extern(C)
	{
		/*
		 *  here we register our new type and its interfaces
		 *  with the type system. If you want to implement
		 *  additional interfaces like GtkTreeSortable, you
		 *  will need to do it here.
		 */
		
		static GType customTreeModelgetType()
		{
			GType customTreeModelType = Type.fromName("CustomTreeModel");
			
			/* Some boilerplate type registration stuff */
			if (customTreeModelType == GType.INVALID)
			{
				static GTypeInfo customTreeModelInfo =
				{
					CustomTreeModelClass.sizeof,                   /* class size */
					null,                                          /* base_init */
					null,                                          /* base_finalize */
					cast(GClassInitFunc) &customTreeModelClassInit,/* class init function */
					null,                                          /* class finalize */
					null,                                          /* class_data */
					GObject.sizeof,                                /* instance size */
					0,                                             /* n_preallocs */
					//cast(GInstanceInitFunc) &customTreeModelInit   /* instance init */
					null
				};
				static GInterfaceInfo treeModelInfo =
				{
					cast(GInterfaceInitFunc) &customTreeModelInit,
					null,
					null
				};
				
				/* First register the new derived type with the GObject type system */
				customTreeModelType = Type.registerStatic (GType.OBJECT, "CustomTreeModel",
				&customTreeModelInfo, cast(GTypeFlags)0);
				
				/* Now register our GtkTreeModel interface with the type system */
				Type.addInterfaceStatic (customTreeModelType, gtk_tree_model_get_type() /*GTK_TYPE_TREE_MODEL*/, &treeModelInfo);
			}
			
			return customTreeModelType;
		}
		
		/*
		 *  boilerplate GObject/GType stuff.
		 *  Init callback for the type system,
		 *  called once when our new class is created.
		 */
		
		static void customTreeModelClassInit (void* klass)
		{
			GObjectClass* objectClass;
			
			parentClass = cast(GObjectClass*) Type.classPeekParent(klass);
			objectClass = cast(GObjectClass*) klass;
			
			objectClass.finalize = &customTreeModelFinalize;
		}
		
		/*
		 *  init callback for the interface registration
		 *  in customTreeModelGetType. Here we override
		 *  the GtkTreeModel interface functions that
		 *  we implement.
		 */
		
		static void customTreeModelInit (GtkTreeModelIface *iface)
		{
			iface.getFlags      = &customTreeModelGetFlags;
			iface.getNColumns   = &customTreeModelGetNColumns;
			iface.getColumnType = &customTreeModelGetColumnType;
			iface.getIter       = &customTreeModelGetIter;
			iface.getPath       = &customTreeModelGetPath;
			iface.getValue      = &customTreeModelGetValue;
			iface.iterNext      = &customTreeModelIterNext;
			iface.iterChildren  = &customTreeModelIterChildren;
			iface.iterHasChild  = &customTreeModelIterHasChild;
			iface.iterNChildren = &customTreeModelIterNChildren;
			iface.iterNthChild  = &customTreeModelIterNthChild;
			iface.iterParent    = &customTreeModelIterParent;
		}
		
		/*
		 *  this is called just before a custom list is
		 *  destroyed. Free dynamically allocated memory here.
		 */
		
		static void customTreeModelFinalize (GObject *object)
		{
			/* must chain up - finalize parent */
			parentClass.finalize(object);
		}
		
		static GtkTreeModelFlags customTreeModelGetFlags(GtkTreeModel *tree_model)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.getFlags();
		}
		
		static int customTreeModelGetNColumns(GtkTreeModel *tree_model)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.getNColumns();
		}
		
		static GType customTreeModelGetColumnType(GtkTreeModel *tree_model, int index)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.getColumnType(index);
		}
		
		static gboolean customTreeModelGetIter(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.getIter(new TreeIter(iter), new TreePath(path));
		}
		
		static GtkTreePath* customTreeModelGetPath(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = new TreeModel(tree_model);
			TreePath path = tm.getPath(new TreeIter(iter));
			
			return (path is null) ? null : path.getTreePathStruct();
		}
		
		static void customTreeModelGetValue(GtkTreeModel *tree_model, GtkTreeIter *iter, int column, GValue *value)
		{
			auto tm = new TreeModel(tree_model);
			
			tm.getValue(new TreeIter(iter), column, new Value(value));
		}
		
		static gboolean customTreeModelIterNext(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterNext(new TreeIter(iter));
		}
		
		static gboolean customTreeModelIterChildren(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterChildren(new TreeIter(iter), new TreeIter(parent));
		}
		
		static gboolean customTreeModelIterHasChild(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterHasChild(new TreeIter(iter));
		}
		
		static int customTreeModelIterNChildren(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterNChildren(new TreeIter(iter));
		}
		
		static gboolean customTreeModelIterNthChild(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, int n)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterNthChild(new TreeIter(iter), new TreeIter(parent), n);
		}
		
		static gboolean customTreeModelIterParent(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child)
		{
			auto tm = new TreeModel(tree_model);
			
			return tm.iterParent(new TreeIter(iter), new TreeIter(child));
		}
	}
}
code: end
outFile: TreeModel



file: GtkTreeSelection.html
struct: GtkTreeSelection
class: TreeSelection
prefix: gtk_tree_selection_
prefix: gtk_
import: gtk.TreeView
structWrap: GtkTreeView* TreeView
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeModelIF
import: gtk.TreeIter

out: gtk_tree_selection_get_selected model
nocode: gtk_tree_selection_get_selected_rows

code: start
	/**
	 * Returns an TreeIter set to the currently selected node if selection
	 * is set to GTK_SELECTION_SINGLE or GTK_SELECTION_BROWSE.
	 * This function will not work if you use selection is GTK_SELECTION_MULTIPLE.
	 * Returns: A TreeIter for the selected node.
	 */
	public TreeIter getSelected()
	{
		TreeModelIF model;
		TreeIter iter = new TreeIter();
		
		if ( getSelected(model, iter) )
		{
			iter.setModel(model);
			return iter;
		}
		else
		{
			return null;
		}
	}

	/**
	 * Creates a list of path of all selected rows. Additionally, if you are
	 * planning on modifying the model after calling this function, you may
	 * want to convert the returned list into a list of GtkTreeRowReferences.
	 * To do this, you can use gtk_tree_row_reference_new().
	 * To free the return value, use:
	 * g_list_foreach (list, gtk_tree_path_free, NULL);
	 * g_list_free (list);
	 * Since 2.2
	 * Params:
	 *  model = A pointer to set to the GtkTreeModel, or NULL.
	 * Returns:
	 *  A GList containing a GtkTreePath for each selected row.
	 */
	TreePath[] getSelectedRows(out TreeModelIF model)
	{
		TreePath[] paths;
		GtkTreeModel* outmodel = null;
		GList* gList = gtk_tree_selection_get_selected_rows(gtkTreeSelection, &outmodel);
		if ( gList !is null )
		{  
			ListG list = new ListG(gList);
			for ( int i=0 ; i<list.length() ; i++ )
			{
				paths ~= new TreePath(cast(GtkTreePath*)list.nthData(i));
			}
		}
		model = new TreeModel(outmodel);

		return paths;
	}

code: end


outFile: TreeSelection

file: GtkTreeViewColumn.html
struct: GtkTreeViewColumn
class: TreeViewColumn
implements: CellLayoutIF
prefix: gtk_tree_view_column_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: glib.Str

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_tree_view_column_cell_get_size x_offset
out: gtk_tree_view_column_cell_get_size y_offset
out: gtk_tree_view_column_cell_get_size width
out: gtk_tree_view_column_cell_get_size height
out: gtk_tree_view_column_cell_get_position start_pos
out: gtk_tree_view_column_cell_get_position width

#These are also implemented in CellLayoutT
nocode: gtk_tree_view_column_pack_start
nocode: gtk_tree_view_column_pack_end
nocode: gtk_tree_view_column_clear
nocode: gtk_tree_view_column_add_attribute
nocode: gtk_tree_view_column_clear_attributes

nocode: gtk_tree_view_column_new_with_attributes

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkTreeViewColumn);

	/**
	 * Creates a new Tree view column
	 * Params:
	 *  header = th column header text
	 *  renderer = the rederer for the column cells
	 *  type = the type of data to be displayed (shouldn't this be on the renderer?)
	 *  column = the column number
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string header, CellRenderer renderer, string type, int column)
	{
		auto p = gtk_tree_view_column_new_with_attributes(
				Str.toStringz(header), 
				renderer.getCellRendererStruct(), 
				Str.toStringz(type),
				column,
				null);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_view_column_new_with_attributes");
		}

		this(p);
	}
code: end

outFile: TreeViewColumn

file: GtkTreeView.html
struct: GtkTreeView
class: TreeView
prefix: gtk_tree_view_
prefix: gtk_
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeSelection
structWrap: GtkTreeSelection* TreeSelection
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.TreeViewColumn
structWrap: GtkTreeViewColumn* TreeViewColumn
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.TreeViewColumn*
#structWrap: GtkTreeViewColumn** TreeViewColumn*
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.TreeViewDropPosition
#structWrap: GtkTreeViewDropPosition* TreeViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.Entry
structWrap: GtkEntry* Entry

inout: gtk_tree_view_get_path_at_pos path
inout: gtk_tree_view_get_path_at_pos column
out: gtk_tree_view_get_path_at_pos cell_x
out: gtk_tree_view_get_path_at_pos cell_y
out: gtk_tree_view_get_cursor path
out: gtk_tree_view_get_cursor focus_column
out: gtk_tree_view_get_visible_range start_path
out: gtk_tree_view_get_visible_range end_path
out: gtk_tree_view_widget_to_tree_coords tx
out: gtk_tree_view_widget_to_tree_coords ty
out: gtk_tree_view_tree_to_widget_coords wx
out: gtk_tree_view_tree_to_widget_coords wy
out: gtk_tree_view_convert_bin_window_to_tree_coords tx
out: gtk_tree_view_convert_bin_window_to_tree_coords ty
out: gtk_tree_view_convert_bin_window_to_widget_coords wx
out: gtk_tree_view_convert_bin_window_to_widget_coords wy
out: gtk_tree_view_convert_tree_to_bin_window_coords bx
out: gtk_tree_view_convert_tree_to_bin_window_coords by
out: gtk_tree_view_convert_tree_to_widget_coords wx
out: gtk_tree_view_convert_tree_to_widget_coords wy
out: gtk_tree_view_convert_widget_to_bin_window_coords bx
out: gtk_tree_view_convert_widget_to_bin_window_coords by
out: gtk_tree_view_convert_widget_to_tree_coords tx
out: gtk_tree_view_convert_widget_to_tree_coords ty
array: gtk_tree_view_enable_model_drag_dest targets n_targets
array: gtk_tree_view_enable_model_drag_source targets n_targets
out: gtk_tree_view_get_drag_dest_row path
out: gtk_tree_view_get_drag_dest_row pos
out: gtk_tree_view_get_dest_row_at_pos path
out: gtk_tree_view_get_dest_row_at_pos pos
out: gtk_tree_view_get_tooltip_context model
out: gtk_tree_view_get_tooltip_context path

code: start
	/**
	 * Expands the row of the iter.
	 * Params:
	 *  iter =
	 *  openAll =
	 *  Returns =
	 */
	int expandRow(TreeIter iter, TreeModelIF model, int openAll)
	{
		return expandRow(model.getPath(iter), openAll);
	}

	/**
	 * gets the first selected iter or null if no rows are selected
	 */
	TreeIter getSelectedIter()
	{
		TreeIter iter = null;
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		if ( paths.length > 0 )
		{
			iter = new TreeIter();
			model.getIter(iter,paths[0]);
		}
		return iter;
	}

	/** */
	TreeIter[] getSelectedIters()
	{
		TreeIter[] iters;
		
		TreeIter iter = new TreeIter();
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		foreach ( TreePath p; selection.getSelectedRows(model) )
		{
			//iters.length = iters.length+1;
			//iters[iters.length-1] = model.getIter(iter,p);
			// iters ~= model.getIter(iter,p); >>> compile error can only concatenate arrays ???
			if ( model.getIter(iter,p) )
			{
				iters ~= iter;
				iter = new TreeIter();
			}
		}
		
		//printf("TreeView.getSelectedIters iters.lenght = %d\n", iters.length);
		return iters;
	}

	/**
	 * Inserts a column and sets it's attributes
	 * Params:
	 *  position =
	 *  title =
	 *  renderer =
	 *  editable =
	 * Returns: number of columns including the new one
	 */
	gint insertEditableColumn(int position, string title, CellRenderer renderer, bool editable)
	{
		// OK, this is a trick because of my ignorance on how to pass variable argument lists
		if ( position < 0 )
		{
			position = getColumns().length();
		}
		int tot = gtk_tree_view_insert_column_with_attributes(
			gtkTreeView, 
			position, 
			Str.toStringz(title),
			renderer.getCellRendererStruct(),
			Str.toStringz("text"),position,//v1.getV(),
			Str.toStringz("editable"),2,0);//v.getV(),0);
		return tot;
	}


	
code: end

outFile: TreeView

file: gtk-GtkTreeView-drag-and-drop.html
struct: GtkTreeDragSource
class: TreeDragSourceT
template: TStruct
prefix: gtk_tree_drag_source_
prefix: gtk_tree_
noprefix: gtk_tree_drag_dest_
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
import: gtk.TreeModelIF
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModelIF

out: gtk_tree_get_row_drag_data tree_model
out: gtk_tree_get_row_drag_data path

interface: TreeDragSourceIF
outFile: TreeDragSourceT

struct: GtkTreeDragDest
class: TreeDragDestT
template: TStruct
prefix: gtk_tree_drag_dest_
strictPrefix: Y
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData

interfaceCode: start
	/**
	 * Sets selection data of target type GTK_TREE_MODEL_ROW. Normally used
	 * in a drag_data_get handler.
	 * Params:
	 * selectionData =  some GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  a row in tree_model
	 * Returns: TRUE if the GtkSelectionData had the proper target type to allow us to set a tree row
	 */
	public static int setRowDragData(GtkSelectionData* selectionData, TreeModelIF treeModel, TreePath path);
	
	/**
	 * Obtains a tree_model and path from selection data of target type
	 * GTK_TREE_MODEL_ROW. Normally called from a drag_data_received handler.
	 * This function can only be used if selection_data originates from the same
	 * process that's calling this function, because a pointer to the tree model
	 * is being passed around. If you aren't in the same process, then you'll
	 * get memory corruption. In the GtkTreeDragDest drag_data_received handler,
	 * you can assume that selection data of type GTK_TREE_MODEL_ROW is
	 * in from the current process. The returned path must be freed with
	 * gtk_tree_path_free().
	 * Params:
	 * selectionData =  a GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  row in tree_model
	 * Returns: TRUE if selection_data had target type GTK_TREE_MODEL_ROW and is otherwise valid
	 */
	public static int getRowDragData(GtkSelectionData* selectionData, GtkTreeModel** treeModel, GtkTreePath** path);
interfaceCode: end
interface: TreeDragDestIF
outFile: TreeDragDestT

file: GtkCellView.html
struct: GtkCellView
class: CellView
implements: CellLayoutIF
prefix: gtk_cell_view_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
import: gdk.Color
structWrap: GdkColor* Color
import: glib.ListG
structWrap: GList* ListG

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_cell_view_get_size_of_row requisition

nocode: gtk_cell_view_new_with_text
nocode: gtk_cell_view_new_with_markup

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkCellView);

	/**
	 * Creates a new GtkCellView widget, adds a GtkCellRendererText
	 * to it, and makes its show text.
	 * If markup is true the text can be marked up with the Pango text
	 * markup language.
	 * Since 2.6
	 * Params:
	 *  text = the text to display in the cell view
	 * Returns:
	 *  A newly created GtkCellView widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string text, bool markup=true)
	{
		GtkCellView* p;

		if ( markup )
		{
			// GtkWidget* gtk_cell_view_new_with_markup (const gchar *markup);
			p = cast(GtkCellView*)gtk_cell_view_new_with_markup(Str.toStringz(text));
		}
		else
		{
			// GtkWidget* gtk_cell_view_new_with_text (const gchar *text);
			p = cast(GtkCellView*)gtk_cell_view_new_with_text(Str.toStringz(text));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_cell_view_new_with_");
		}

		this(p);
	}
code: end

outFile: CellView

file: GtkIconView.html
struct: GtkIconView
class: IconView
implements: CellLayoutIF
prefix: gtk_icon_view_
prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.CellRenderer*
#structWrap: GtkCellRenderer** CellRenderer*
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: glib.ListG
structWrap: GList* ListG
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.IconViewDropPosition
#structWrap: GtkIconViewDropPosition* IconViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_icon_view_get_item_at_pos path
out: gtk_icon_view_get_item_at_pos cell
out: gtk_icon_view_convert_widget_to_bin_window_coords bx
out: gtk_icon_view_convert_widget_to_bin_window_coords by
out: gtk_icon_view_get_cursor path
out: gtk_icon_view_get_cursor cell
out: gtk_icon_view_get_visible_range start_path
out: gtk_icon_view_get_visible_range end_path
out: gtk_icon_view_get_tooltip_context model
out: gtk_icon_view_get_tooltip_context path
array: gtk_icon_view_enable_model_drag_source targets n_targets
array: gtk_icon_view_enable_model_drag_dest targets n_targets
out: gtk_icon_view_get_drag_dest_item path
out: gtk_icon_view_get_drag_dest_item pos
out: gtk_icon_view_get_dest_item_at_pos path
out: gtk_icon_view_get_dest_item_at_pos pos

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkIconView);
code: end
outFile: IconView

file: GtkTreeSortable.html
struct: GtkTreeSortable
class: TreeSortableT
template: TStruct
prefix: gtk_tree_sortable_
prefix: gtk_
#import: gtk.SortType
#structWrap: GtkSortType* SortType

out: gtk_tree_sortable_get_sort_column_id sort_column_id
out: gtk_tree_sortable_get_sort_column_id order

interface: TreeSortableIF
outFile: TreeSortableT

file: GtkTreeModelSort.html
struct: GtkTreeModelSort
class: TreeModelSort
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeSortableIF
prefix: gtk_tree_model_sort_
prefix: gtk_
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelSort);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelSort);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeModelSort);
cade: end
outFile: TreeModelSort

file: GtkTreeModelFilter.html
struct: GtkTreeModelFilter
ctorStruct: GtkTreeModel
class: TreeModelFilter
implements: TreeModelIF
implements: TreeDragSourceIF
prefix: gtk_tree_model_filter_
prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

array: gtk_tree_model_filter_set_modify_func types n_columns

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelFilter);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelFilter);
cade: end
outFile: TreeModelFilter

file: GtkCellLayout.html
struct: GtkCellLayout
class: CellLayoutT
template: TStruct
prefix: gtk_cell_layout_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
interface: CellLayoutIF
outFile: CellLayoutT

file: GtkCellRenderer.html
struct: GtkCellRenderer
class: CellRenderer
prefix: gtk_cell_renderer_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.CellEditable
import: gtk.CellEditableIF
structWrap: GtkCellEditable* CellEditableIF

out: gtk_cell_renderer_get_size x_offset
out: gtk_cell_renderer_get_size y_offset
out: gtk_cell_renderer_get_size width
out: gtk_cell_renderer_get_size height
out: gtk_cell_renderer_get_fixed_size width
out: gtk_cell_renderer_get_fixed_size height
out: gtk_cell_renderer_get_alignment xalign
out: gtk_cell_renderer_get_alignment yalign
out: gtk_cell_renderer_get_padding xpad
out: gtk_cell_renderer_get_padding ypad

outFile: CellRenderer

file: GtkCellEditable.html
struct: GtkCellEditable
class: CellEditableT
template: TStruct
prefix: gtk_cell_editable_
prefix: gtk_
import: gdk.Event
structWrap: GdkEvent* Event
interface: CellEditableIF
outFile: CellEditableT

file:
class: CellEditable
extend: ObjectG
implements: CellEditableIF
import: gobject.ObjectG

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

code: start
	// Minimal implementation.
	mixin CellEditableT!(GtkCellEditable);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkCellEditable;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkCellEditable* gtkCellEditable)
	{
		if(gtkCellEditable is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gtkCellEditable);
		this.gtkCellEditable = gtkCellEditable;
	}
code: end
outFile: CellEditable

file: GtkCellRendererAccel.html
struct: GtkCellRendererAccel
ctorStruct: GtkCellRenderer
class: CellRendererAccel
prefix: gtk_cell_renderer_accel_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererAccel

file: GtkCellRendererCombo.html
struct: GtkCellRendererCombo
ctorStruct: GtkCellRenderer
class: CellRendererCombo
prefix: gtk_cell_renderer_combo_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: CellRendererCombo

file: GtkCellRendererPixbuf.html
struct: GtkCellRendererPixbuf
ctorStruct: GtkCellRenderer
class: CellRendererPixbuf
prefix: gtk_cell_renderer_pixbuf_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererPixbuf

file: GtkCellRendererProgress.html
struct:GtkCellRendererProgress
ctorStruct: GtkCellRenderer
class: CellRendererProgress
prefix: gtk_cell_renderer_progress_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererProgress

file: GtkCellRendererSpin.html
struct: GtkCellRendererSpin
ctorStruct: GtkCellRenderer
class: CellRendererSpin
prefix: gtk_cell_renderer_spin_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererSpin

file: GtkCellRendererText.html
struct: GtkCellRendererText
ctorStruct: GtkCellRenderer
class: CellRendererText
prefix: gtk_cell_renderer_text_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererText

file: GtkCellRendererToggle.html
struct: GtkCellRendererToggle
ctorStruct: GtkCellRenderer
class: CellRendererToggle
prefix: gtk_cell_renderer_toggle_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererToggle

file: GtkCellRendererSpinner.html
struct: GtkCellRendererSpinner
ctorStruct: GtkCellRenderer
class: CellRendererSpinner
prefix: gtk_cell_renderer_spinner_
outFile: CellRendererSpinner

file:
code: start
	/**
	 * TreeNode interface
	 */
	public interface TreeNode
	{
		string getNodeValue(int column);
		int columnCount();
	}
code: end
outFile: TreeNode

file: GtkListStore.html
struct: GtkListStore
class: ListStore
implements: BuildableIF
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_list_store_
prefix: gtk_
import: gtk.TreeModel
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_list_store_newv types n_columns
array: gtk_list_store_set_column_types types n_columns
array: gtk_list_store_set_valuesv values n_values
array: gtk_list_store_set_valuesv columns n_values
array: gtk_list_store_insert_with_valuesv values n_values
array: gtk_list_store_insert_with_valuesv columns n_values
array: gtk_list_store_reorder new_order

nocode: gtk_list_store_set

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkListStore);

	// add the TreeModel capabilities
	mixin TreeModelT!(GtkListStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkListStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkListStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkListStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter()
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_list_store_append(getListStoreStruct(), iter);
		return new TreeIter(iter);
	}
	
	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** */
	void set(TreeIter iter, int [] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/** */
	void setValue(TreeIter iter, int column, string value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
		//gtk_list_store_set_value(obj(), iter.getIter(), column, (GValue*)cChar(value));
	}

	/** */
	void setValue(TreeIter iter, int column, int value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}

code: end
outFile: ListStore

file: GtkTreeStore.html
struct: GtkTreeStore
class: TreeStore
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_tree_store_
prefix: gtk_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value
import: gtk.TreeNode
import: gdk.Pixbuf;
import: gobject.Value;

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_tree_store_newv types n_columns
array: gtk_tree_store_set_column_types types n_columns
array: gtk_tree_store_set_valuesv columns n_values
array: gtk_tree_store_set_valuesv values n_values
array: gtk_tree_store_insert_with_valuesv columns n_values
array: gtk_tree_store_insert_with_valuesv values n_values
array: gtk_tree_store_reorder new_order

nocode: gtk_tree_store_set

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkTreeStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter(TreeIter parent=null)
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_tree_store_append(getTreeStoreStruct(), iter, (parent is null) ? null : parent.getTreeIterStruct());
		return new TreeIter(iter);
	}
	
	/**
	 * Sets one value into one cells.
	 * \todo confirm we need to destroy the Value instance
	 * Params:
	 *  iter = the tree iteractor, effectivly the row
	 *  column = to column number to set
	 *  value = the value
	 */
	void setValue(TreeIter iter, int column, string value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, Str.toStringz(value) , -1);
	}

	/** */
	void setValue(TreeIter iter, int column, int value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, value, -1);
	}


	
	/**
	 * \todo confirm we need to destroy the Value instance
	 */
	void setValue(TreeIter iter, int column, Pixbuf pixbuf)
	{
		Value v = new Value(pixbuf);
		gtk_tree_store_set_value(gtkTreeStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}


	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** */
	void set(TreeIter iter, int [] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/**
	 * Sets an iteractor values from a tree node.
	 * This is the way to add a new row to the tree,
	 * the iteractor is either a top level iteractor created from createIter()
	 * or a nested iteractor created from append()
	 * Params:
	 *  iter = the iteractor to set
	 *  treeNode = the tree node
	 * See_Also: createIter(), append()
	 */
	void set(TreeIter iter, TreeNode treeNode)
	{
		int[] cols;
		string[] vals;
		for ( int i=0 ; i<treeNode.columnCount() ; i++ )
		{
			//printf(">>>>>>>>>>>>> requesting value for %d\n",i);
			cols ~= i;
			string value = treeNode.getNodeValue(i);
			if ( value  is  null )
			{
				vals ~= "";
			}
			else
			{
				vals ~= value;
			}
		}
		set(iter, cols, vals);				
	}


	/**
	 * Creates and prepends a new row to tree_store. If parent is non-NULL, then it will prepend
	 * the new row before the first child of parent, otherwise it will prepend a row
	 * to the top level. iter will be changed to point to this new row. The row
	 * will be empty after this function is called. To fill in values, you need to
	 * call gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter prepend(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_prepend (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_prepend(gtkTreeStore, iter.getTreeIterStruct(), (parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
	
	/**
	 * Creates and appends a new row to tree_store. If parent is non-NULL, then it will append the
	 * new row after the last child of parent, otherwise it will append a row to
	 * the top level. iter will be changed to point to this new row. The row will
	 * be empty after this function is called. To fill in values, you need to call
	 * gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter append(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_append (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_append(gtkTreeStore, 
			iter.getTreeIterStruct(), 
			(parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
code: end

outFile: TreeStore


###########################################################
### Menus, Combo Box, Toolbar #############################
###########################################################

file: GtkComboBox.html

struct: GtkComboBox
class: ComboBox
implements: CellLayoutIF
implements: CellEditableIF
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_combo_box_
prefix: gtk_
#noprefix: gtk_combo_box_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

nocode: gtk_combo_box_new
nocode: gtk_combo_box_new_text

code: start

	private int count = 0;
	public int maxCount = 0;
	

	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkComboBox);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkComboBox);

	/**
	 * Creates a new empty GtkComboBox.
	 * If text is true then
	 * constructs a new text combo box, which is a
	 * GtkComboBox just displaying strings. If you use this function to create
	 * a text combo box, you should only manipulate its data source with the
	 * following convenience functions: gtk_combo_box_append_text(),
	 * gtk_combo_box_insert_text(), gtk_combo_box_prepend_text() and
	 * gtk_combo_box_remove_text().
	 * Since 2.4
	 * Returns:
	 *  A new GtkComboBox.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool text=true)
	{
		GtkComboBox* p;
		if ( text )
		{
			// GtkWidget* gtk_combo_box_new_text (void);
			p = cast(GtkComboBox*)gtk_combo_box_new_text();
		}
		else
		{
			// GtkWidget* gtk_combo_box_new (void);
			p = cast(GtkComboBox*)gtk_combo_box_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}

	/** */
	public void setActiveText(string text, bool insert=false)
	{
            int active = 0;
            setActive(0);
            while ( getActive >= 0 ) // returns -1 if end of list if reached
            {
                if( text == getActiveText() ) return;
                ++active;
                setActive(active);
            }
            // was not found, the combo has now nothing selected
            if ( insert )
            {
                appendText(text);
                setActive(active);
            }
	}

	/** */
	int getIndex(string text)
	{
		TreeIter iter = new TreeIter();
		TreeModelIF model = getModel();
		iter.setModel(model);
		int index = 0;
		bool found = false;
		bool end = false;
		if ( model.getIterFirst(iter) )
		{
			while ( !end && iter !is  null && !found )
			{
				found = iter.getValueString(0) == text;
				if ( !found )
				{
					end = !model.iterNext(iter);
					++index;
				}
			}
		}
		else
		{
			end = true;
		}
		return end ? -1 : index;
	}

	/** */
	void prependOrReplaceText(string text)
	{
		int index = getIndex(text);
		if ( index > 0 )
		{
			removeText(index);
			prependText(text);
		}
		else if ( index == -1 )
		{
			prependText(text);
		}
	}


code: end
outFile: ComboBox

file: GtkComboBoxEntry.html

struct: GtkComboBoxEntry
class: ComboBoxEntry
prefix: gtk_combo_box_entry_
#noprefix: gtk_combo_box_entry_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

nocode: gtk_combo_box_entry_new
nocode: gtk_combo_box_entry_new_text

code: start
	/**
	 * Creates a new GtkComboBoxEntry which has a GtkEntry as child. After
	 * construction, you should set a model using gtk_combo_box_set_model() and a
	 * text_column * using gtk_combo_box_entry_set_text_column().
	 * Since 2.4
	 * Returns:
	 *  A new GtkComboBoxEntry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool text=true)
	{
		GtkComboBoxEntry* p;

		if ( text )
		{
			// GtkWidget* gtk_combo_box_entry_new_text (void);
			p = cast(GtkComboBoxEntry*)gtk_combo_box_entry_new_text();
		}
		else
		{
			// GtkWidget* gtk_combo_box_entry_new (void);
			p = cast(GtkComboBoxEntry*)gtk_combo_box_entry_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_entry_new");
		}

		this(p);
	}
code: end
outFile: ComboBoxEntry


file: GtkMenu.html
struct: GtkMenu
class: Menu
prefix: gtk_menu_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.MenuItem

code: start
	/**
	 * Popups up this menu
	 * Params:
	 *  button = you can pass a button number here
	 *  activateTime = you can pass the time from an event here
	 */
	void popup(guint button, guint32 activateTime)
	{
		popup(null, null, null, null, button, activateTime);
	}
	
	/**
	 * Creates and append a submenu to this menu.
	 * This menu item that actualy has the sub menu is also created.
	 * Params:
	 *  label = the sub menu item label
	 * Returns: the new menu
	 */
	Menu appendSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}

	/** */
	void appendSubmenu(string label, Menu submenu)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		item.setSubmenu(submenu);
	}

	/** */
	Menu prependSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		prepend(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}
code: end
outFile: Menu

file: GtkMenuBar.html
struct: GtkMenuBar
class: MenuBar
prefix: gtk_menu_bar_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Menu;
import: gtk.MenuItem;
structWrap: GtkMenu* Menu
structWrap: GtkMenuItem* MenuItem
code: start
	/** */
	Menu append(string label, bool rightJustify=false)
	{
		MenuItem item = new MenuItem(label);
		super.append(item);
		item.setRightJustified(rightJustify);
		Menu menu= new Menu();
		item.setSubmenu(menu);
		return menu;
	}

	/** */
	public override void append(Widget widget) 
	{ 
		super.append(widget); 
	}
code: end
outFile: MenuBar

file: GtkMenuItem.html
struct: GtkMenuItem
class: MenuItem
implements: ActivatableIF
prefix: gtk_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.AccelGroup
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

nocode: gtk_menu_item_new_with_label
nocode: gtk_menu_item_new_with_mnemonic

alias: activate itemActivate

override: select
override: deselect

code: start
	/** store the action code passed in by the applcation */
	private string actionLabel;

	// add the Activatable capabilities
	mixin ActivatableT!(GtkMenuItem);
	
	/** Gets the application set action code */
	public string getActionName()
	{
		if ( actionLabel is null )
		{
			actionLabel = "";
		}
		return actionLabel;
	}
	
	/**
	 * Creates a new menu item with a label and a listener and a action.
	 * used for backward compatibily with DUI.
	 */
	this(string label, void delegate(MenuItem)dlg, string action)
	{
		this(label);
		this.actionLabel = action;
		addOnActivate(dlg);
	}
	

	
	/**
	 * Creates a new Item associated with a "activate" delegate and with a action code
	 * and optionally accelGroup
	 */
	public this(void delegate(MenuItem) dlg, string label, string action, 
				bool mnemonic=true,
				AccelGroup accelGroup=null,
				char accelKey='\0',
				GdkModifierType modifierType=GdkModifierType.CONTROL_MASK,
				GtkAccelFlags accelFlags=GtkAccelFlags.VISIBLE
				)
	{
		this(label, mnemonic);
		this.actionLabel = action;
		addOnActivate(dlg);
		if ( accelGroup !is null && accelKey != '\0' )
		{
			addAccelerator("activate",accelGroup,accelKey,modifierType,accelFlags); 
		}
	}
	
	

	/**
	 * Creates a new Item associated with a "activate" delegate
	 */
	public this(void delegate(MenuItem) dlg, string label, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnActivate(dlg);
	}

	/**
	 * Creates a new GtkMenuItem whose child is a GtkLabel.
	 * Params:
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_item_new_with_");
		}

		this(p);

		setName(label);
	}	
code: end
outFile: MenuItem

file: GtkImageMenuItem.html
struct: GtkImageMenuItem
class: ImageMenuItem
prefix: gtk_image_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup

nocode: gtk_image_menu_item_new_with_label
nocode: gtk_image_menu_item_new_with_mnemonic
nocode: gtk_image_menu_item_new_from_stock

code: start
	/**
	 * Creates a new GtkImageMenuItem containing a label.
	 * If mnemonic it true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * Params:
	 *  label = the text of the menu item.
	 * Returns:
	 *  a new GtkImageMenuItem.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkImageMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_image_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_image_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_with_");
		}

		this(p);
	}

	/**
	 * Creates a new GtkImageMenuItem containing the image and text from a
	 * stock item. Some stock ids have preprocessor macros like GTK_STOCK_OK
	 * and GTK_STOCK_APPLY.
	 * If you want this menu item to have changeable accelerators, then pass in
	 * NULL for accel_group. Next call gtk_menu_item_set_accel_path() with an
	 * appropriate path for the menu item, use gtk_stock_lookup() to look up the
	 * standard accelerator for the stock item, and if one is found, call
	 * gtk_accel_map_add_entry() to register it.
	 * Params:
	 * StockID = the name of the stock item
	 * accelGroup =  the GtkAccelGroup to add the menu items accelerator to,
	 *  or NULL.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, AccelGroup accelGroup)
	{
		// GtkWidget* gtk_image_menu_item_new_from_stock (const gchar *stock_id,  GtkAccelGroup *accel_group);
		auto p = gtk_image_menu_item_new_from_stock(Str.toStringz(StockDesc[stockID]), (accelGroup is null) ? null : accelGroup.getAccelGroupStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_from_stock");
		}
		this(cast(GtkImageMenuItem*) p);
	}
code: end

outFile: ImageMenuItem

file: GtkRadioMenuItem.html
struct: GtkRadioMenuItem
class: RadioMenuItem
prefix: gtk_radio_menu_item_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioMenuItem* RadioMenuItem

nocode: gtk_radio_menu_item_new_with_label
nocode: gtk_radio_menu_item_new_with_mnemonic
nocode: gtk_radio_menu_item_new_with_mnemonic_from_widget
nocode: gtk_radio_menu_item_new_with_label_from_widget

code: start
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * The new GtkRadioMenuItem is added to the same group as group.
	 * If mnemonic is true the label will be
	 * created using gtk_label_new_with_mnemonic(), so underscores in label
	 * indicate the mnemonic for the menu item.
	 * Since 2.4
	 * Params:
	 *  group = an existing GtkRadioMenuItem
	 *  label = the text for the label
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioMenuItem radioMenuItem, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * Params:
	 *  group = the group to which the radio menu item is to be attached
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
code: end
outFile: RadioMenuItem

file: gtk-gtkcheckmenuitem.html
struct: GtkCheckMenuItem
class: CheckMenuItem
prefix: gtk_check_menu_item_
prefix: gtk_
import: glib.Str

nocode: gtk_check_menu_item_new_with_label
nocode: gtk_check_menu_item_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckMenuItem with a label.
	 * Params:
	 *  label = the string to use for the label.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_menu_item_new_with_");
		}

		this(p);
	}
code: end

outFile: CheckMenuItem

file: GtkSeparatorMenuItem.html
struct: GtkSeparatorMenuItem
class: SeparatorMenuItem
prefix: gtk_separator_menu_item_
prefix: gtk_
outFile: SeparatorMenuItem

file: GtkTearoffMenuItem.html
struct: GtkTearoffMenuItem
class: TearoffMenuItem
prefix: gtk_tearoff_menu_item_
prefix: gtk_
outFile: TearoffMenuItem

file: GtkToolShell.html
struct: GtkToolShell
class: ToolShellT
template: TStruct
prefix: gtk_tool_shell_
import: gtk.SizeGroup
structWrap: GtkSizeGroup* SizeGroup
alias: getStyle toolShellGetStyle
interface: ToolShellIF
outFile: ToolShellT

file: GtkToolbar.html
struct: GtkToolbar
class: Toolbar
implements: OrientableIF
implements: ToolShellIF
prefix: gtk_toolbar_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.Button
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT
nocode: gtk_toolbar_set_orientation
nocode: gtk_toolbar_get_orientation

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT
nocode: gtk_toolbar_get_icon_size
nocode: gtk_toolbar_get_relief_style

alias: getStyle toolbarGetStyle

nocode: gtk_toolbar_insert

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolbar);

	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolbar);

	/**
	 * Insert a GtkToolItem into the toolbar at position pos.
	 * If pos is 0 the item is prepended to the start of the toolbar. If pos is negative, the item is appended to the end of the toolbar.
	 * Since 2.4 
	 * Params:
	 * toolItem  = a GtkToolItem
	 * pos = the position of the new item
	 */
	public void insert (ToolItem toolItem, int pos=-1)
	{
		gtk_toolbar_insert(gtkToolbar, toolItem.getToolItemStruct(), pos);
	}

	/** */	
	public Widget insertStock(StockID stockId, string tooltipText, string tooltipPrivateText, GCallback callback, void* userData, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, callback, userData, position);
	}

	/** */
	public Widget insertStock(string stockId, string tooltipText, string tooltipPrivateText, int position)
	{
		return insertStock(stockId, tooltipText, tooltipPrivateText, null, null, position);
	}
	
	/** */
	public Widget insertStock(StockID stockId, string tooltipText, string tooltipPrivateText, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, null, null, position);
	}

	/** */
	Button insertButton(StockID stockID,
			string tooltipText, string tooltipPrivateText,
			gint position)
	{
		Button button = new Button(
				cast(GtkButton*)gtk_toolbar_insert_stock(
					gtkToolbar,
					Str.toStringz(StockDesc[stockID]),
					Str.toStringz(tooltipText), 
					Str.toStringz(tooltipPrivateText), 
					null, null, 
					position)
			);
		return button;
	}

code: end
outFile: Toolbar

file: GtkToolItem.html
struct: GtkToolItem
class: ToolItem
implements: ActivatableIF
prefix: gtk_tool_item_
prefix: gtk_
import: glib.Str
import: gtk.SizeGroup
structWrap: GtkSizeGroup* SizeGroup
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

override: setTooltipText
override: setTooltipMarkup

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkToolItem);

	/**
	 * Sets this widget tooltip
	 * Deprecated: Since 2.12 use setTooltipText() or setTooltipMarkup()
	 * Params:
	 *  tipText = the tooltip
	 *  tipPrivate = a private text
	 */
	override void setTooltip(string tipText, string tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}

code: end

outFile: ToolItem

file: GtkToolPalette.html
struct: GtkToolPalette
ctorStruct: GtkWidget
class: ToolPalette
implements: OrientableIF
prefix: gtk_tool_palette_
alias: getStyle getToolbarStyle
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.ToolItemGroup
structWrap: GtkToolItemGroup* ToolItemGroup
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolPalette);
code: end
outFile: ToolPalette

file: GtkToolItemGroup.html
struct: GtkToolItemGroup
ctorStruct: GtkWidget
class: ToolItemGroup
implements: ToolShellIF
prefix: gtk_tool_item_group_
alias: getStyle getToolbarStyle
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT

code: start
	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolItemGroup);
code: end
outFile: ToolItemGroup

file: GtkSeparatorToolItem.html
struct: GtkSeparatorToolItem
ctorStruct: GtkToolItem
class: SeparatorToolItem
prefix: gtk_separator_tool_item_
prefix: gtk_
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: SeparatorToolItem

file: GtkToolButton.html
struct: GtkToolButton
ctorStruct: GtkToolItem
class: ToolButton
prefix: gtk_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
#structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start
	/** An arbitrary string to be used by the application */
	private string action;

	/** */
	public void setActionName(string action)
	{
		this.action = action;
	}
	
	/** */
	public string getActionName()
	{
		return action;
	}

	/** */
	public this (StockID stockID)
	{
		this(StockDesc[stockID]);
	}
code: end

outFile: ToolButton

file: GtkMenuToolButton.html
struct: GtkMenuToolButton
ctorStruct: GtkToolItem
class: MenuToolButton
prefix: gtk_menu_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Menu


nocode: gtk_menu_tool_button_new
nocode: gtk_menu_tool_button_new_from_stock
nocode: gtk_menu_tool_button_get_menu

code: start
	/**
	 * Creates a new GtkMenuToolButton using icon_widget as icon and
	 * label as label.
	 * Since 2.6
	 * Params:
	 *  iconWidget = a widget that will be used as icon widget, or NULL
	 *  label = a string that will be used as label, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(Widget iconWidget, string label)
	{
		// GtkToolItem* gtk_menu_tool_button_new (GtkWidget *icon_widget,  const gchar *label);
		auto p = gtk_menu_tool_button_new((iconWidget is null) ? null : iconWidget.getWidgetStruct(), 
			Str.toStringz(label));

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_tool_button_new");
		}

		this(cast(GtkMenuToolButton*) p);
	}
	
	/**
	 * Creates a new GtkMenuToolButton.
	 * The new GtkMenuToolButton will contain an icon and label from
	 * the stock item indicated by stockID.
	 * Since 2.6
	 * Params:
	 * stockID = the name of a stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(StockID stockId)
	{
		// GtkToolItem* gtk_menu_tool_button_new_from_stock  (const gchar *stock_id);
		auto p = gtk_menu_tool_button_new_from_stock(
			Str.toStringz(StockDesc[stockId]));

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_tool_button_new_from_stock");
		}

		this(cast(GtkMenuToolButton*) p);
	}

	/**
	 * Gets the GtkMenu associated with GtkMenuToolButton.
	 * Since 2.6
	 * Params:
	 *  button = a GtkMenuToolButton
	 * Returns:
	 *  the GtkMenu associated with GtkMenuToolButton
	 */
	public Menu getMenu()
	{
		// GtkWidget* gtk_menu_tool_button_get_menu (GtkMenuToolButton *button);
		auto p =  gtk_menu_tool_button_get_menu(gtkMenuToolButton);
		if(p is null)
		{
			return null;
		}
		return new Menu(cast(GtkMenu*)p);
	}
	
	/**
	 * Sets the toolTip for the arrow
	 * Deprecated: Since 2.12 use Widget.setArrowTooltipText() or Widget.setArrowTooltipMarkup()
	 * Params:
	 *    	tipText = 	
	 *    	tipPrivate = 	
	 */
	public void setArrowTooltip(string tipText, string tipPrivate)
	{
		Tooltips tooltips = new Tooltips();
		gtk_menu_tool_button_set_arrow_tooltip(
			gtkMenuToolButton, 
			(tooltips is null) ? null : tooltips.getTooltipsStruct(), 
			Str.toStringz(tipText), 
			Str.toStringz(tipPrivate)
			);
	}

code: end

outFile: MenuToolButton

file: GtkToggleToolButton.html
struct: GtkToggleToolButton
ctorStruct: GtkToolItem
class: ToggleToolButton
prefix: gtk_toggle_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: ToggleToolButton

file: GtkRadioToolButton.html
struct: GtkRadioToolButton
ctorStruct: GtkToolItem
class: RadioToolButton
prefix: gtk_radio_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioToolButton* RadioToolButton
outFile: RadioToolButton

###########################################################
### Action-based menus and toolbars #######################
###########################################################

file: GtkUIManager.html
struct: GtkUIManager
class: UIManager
implements: BuildableIF
prefix: gtk_ui_manager_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.ActionGroup
structWrap: GtkActionGroup* ActionGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Action
structWrap: GtkAction* Action

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkUIManager);
code: end
outFile: UIManager

file: GtkActionGroup.html
struct: GtkActionGroup
class: ActionGroup
implements: BuildableIF
prefix: gtk_action_group_
prefix: gtk_
import: glib.Str
import: gtk.Action
structWrap: GtkAction* Action
import: glib.ListG
structWrap: GList* ListG
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.ActionEntry
#structWrap: GtkActionEntry* ActionEntry
#import: gtk.ToggleActionEntry
#structWrap: GtkToggleActionEntry* ToggleActionEntry
#import: gtk.RadioActionEntry
#structWrap: GtkRadioActionEntry* RadioActionEntry

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

array: gtk_action_group_add_actions entries n_entries
array: gtk_action_group_add_actions_full entries n_entries
array: gtk_action_group_add_toggle_actions entries n_entries
array: gtk_action_group_add_toggle_actions_full entries n_entries
array: gtk_action_group_add_radio_actions entries n_entries
array: gtk_action_group_add_radio_actions_full entries n_entries

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkActionGroup);
code: end
outFile: ActionGroup

file: GtkAction.html
struct: GtkAction
class: Action
implements: BuildableIF
prefix: gtk_action_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

nocode: gtk_action_get_stock_id
nocode: gtk_action_set_stock_id

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkAction);

	/**
	 * Creates a new GtkAction object. To add the action to a
	 * GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * See the section called UI Definitions for information on allowed action
	 * names.
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockId =  the stock icon to display in widgets representing the
	 *  action.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId()
	{
		// const gchar * gtk_action_get_stock_id (GtkAction *action);
		string id = Str.toString(gtk_action_get_stock_id(gtkAction));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(StockID stockId)
	{
		// void gtk_action_set_stock_id (GtkAction *action,  const gchar *stock_id);
		gtk_action_set_stock_id(gtkAction, Str.toStringz(StockDesc[stockId]));
	}
code: end
outFile: Action

file: GtkToggleAction.html
struct: GtkToggleAction
class: ToggleAction
prefix: gtk_toggle_action_
prefix: gtk_
import: glib.Str

code: start
/**
	 * Creates a new GtkToggleAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for the action, or NULL
	 * stockId =  The stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}
code: end
outFile: ToggleAction

file: GtkRadioAction.html
struct: GtkRadioAction
class: RadioAction
prefix: gtk_radio_action_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG

code: start
	/**
	 * Creates a new GtkRadioAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for this action, or NULL
	 * stockId =  The stock icon to display in widgets representing this
	 *  action, or NULL
	 * value =  The value which gtk_radio_action_get_current_value() should
	 *  return if this action is selected.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId, int value)
	{
		this(name, label, tooltip, StockDesc[stockId], value);
	}
code: end
outFile: RadioAction

file: GtkRecentAction.html
struct: GtkRecentAction
ctorStruct: GtkAction
class: RecentAction
prefix: gtk_recent_action_
prefix: gtk_
import: glib.Str
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

nocode: gtk_recent_action_new
nocode: gtk_recent_action_new_for_manager

code: start
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID)
	{
		// GtkAction* gtk_recent_action_new (const gchar *name,  const gchar *label,  const gchar *tooltip,  const gchar *stock_id);
		auto p = gtk_recent_action_new(Str.toStringz(name), Str.toStringz(label), Str.toStringz(tooltip), Str.toStringz(StockDesc[stockID]));
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_action_new");
		}
		this(cast(GtkRecentAction*) p);
	}
	
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * manager =  a GtkRecentManager, or NULL for using the default
	 *  GtkRecentManager
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID, RecentManager manager)
	{
		// GtkAction* gtk_recent_action_new_for_manager (const gchar *name,  const gchar *label,  const gchar *tooltip,  const gchar *stock_id,  GtkRecentManager *manager);
		auto p = gtk_recent_action_new_for_manager(Str.toStringz(name), Str.toStringz(label), Str.toStringz(tooltip), Str.toStringz(StockDesc[stockID]), (manager is null) ? null : manager.getRecentManagerStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_action_new_for_manager");
		}
		this(cast(GtkRecentAction*) p);
	}
code: end
outFile: RecentAction

file: GtkActivatable.html
struct: GtkActivatable
class: ActivatableT
template: TStruct
prefix: gtk_activatable_
import: gtk.Action
structWrap: GtkAction* Action
interface: ActivatableIF
outFile: ActivatableT

###########################################################
###  Selectors (File/Font/Color/Input Devices) ############
###########################################################

file: GtkColorButton.html
struct: GtkColorButton
class: ColorButton
prefix: gtk_color_button_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color
outFile: ColorButton

file: GtkColorSelection.html
struct: GtkColorSelection
class: ColorSelection
prefix: gtk_color_selection_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color

out: gtk_color_selection_palette_from_string colors
array: gtk_color_selection_palette_from_string colors n_colors
array: gtk_color_selection_set_color color
array: gtk_color_selection_get_color color

outFile: ColorSelection

file: GtkColorSelectionDialog.html
struct: GtkColorSelectionDialog
class: ColorSelectionDialog
prefix: gtk_color_selection_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: ColorSelectionDialog

file: GtkFileChooser.html
struct: GtkFileChooser
class: FileChooserT
template: TStruct
prefix: gtk_file_chooser_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.File
structWrap: GFile* File
import: gtk.Window
structWrap: GtkWindow* Window
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.FileFilter
structWrap: GtkFileFilter* FileFilter

alias: setAction setFileChooserAction
alias: getAction getFileChooserAction

interface: FileChooserIF
outFile: FileChooserT

file: GtkFileChooserButton.html
struct: GtkFileChooserButton
class: FileChooserButton
implements: FileChooserIF
prefix: gtk_file_chooser_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserButton);
cade: end
outFile: FileChooserButton

file: GtkFileChooserDialog.html
struct: GtkFileChooserDialog
class: FileChooserDialog
implements: FileChooserIF
prefix: gtk_file_chooser_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

nocode: gtk_file_chooser_dialog_new
nocode: gtk_file_chooser_dialog_new_with_backend

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserDialog);

	/**
	 * Creates a new GtkFileChooserDialog. This function is analogous to
	 * gtk_dialog_new_with_buttons().
	 * Since 2.4
	 * Params:
	 *  title = Title of the dialog, or NULL
	 *  parent = Transient parent of the dialog, or NULL
	 *  action = Open or save mode for the dialog
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string title, Window parent, FileChooserAction action,  string[] buttonsText=null, ResponseType[] responses=null)
	{
		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.GTK_RESPONSE_OK;
			responses ~= ResponseType.GTK_RESPONSE_CANCEL;
		}

		auto p = gtk_file_chooser_dialog_new(
				Str.toStringz(title),
				parent.getWindowStruct(),
				action,
				null,
				0);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_file_chooser_dialog_new");
		}

		this(cast(GtkFileChooserDialog*) p);

		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkFileChooserDialog with a specified backend. This is
	 * especially useful if you use gtk_file_chooser_set_local_only() to allow
	 * non-local files and you use a more expressive vfs, such as gnome-vfs,
	 * to load files.
	 * Since 2.4
	 * Params:
	 *  title = Title of the dialog, or NULL
	 *  parent = Transient parent of the dialog, or NULL
	 *  action = Open or save mode for the dialog
	 *  backend = The name of the specific filesystem backend to use.
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * See_Also:
	 *  GtkFileChooser, GtkDialog
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, GtkFileChooserAction action, string backend,  string[] buttonsText=null, ResponseType[] responses=null)
	{
		// GtkWidget* gtk_file_chooser_dialog_new_with_backend  (const gchar *title,  GtkWindow *parent,  GtkFileChooserAction action,  const gchar *backend,  const gchar *first_button_text,  ...);
		auto p = gtk_file_chooser_dialog_new_with_backend(
				Str.toStringz(title), 
				parent.getWindowStruct(), 
				action, 
				Str.toStringz(backend), 
				null,
				0
				);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_file_chooser_dialog_new_with_backend");
		}

		this(cast(GtkFileChooserDialog*) p);

		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.GTK_RESPONSE_OK;
			responses ~= ResponseType.GTK_RESPONSE_CANCEL;
		}

		addButtons(buttonsText, responses);
	}
code: end
outFile: FileChooserDialog

file: GtkFileChooserWidget.html
struct: GtkFileChooserWidget
ctorStruct: GtkWidget
class: FileChooserWidget
prefix: gtk_file_chooser_widget_
prefix: gtk_
import: glib.Str

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(FileChooserWidget);
cade: end
outFile: FileChooserWidget

file: gtk-gtkfilefilter.html
struct:  GtkFileFilter
class: FileFilter
prefix: gtk_file_filter_
prefix: gtk_
import: glib.Str
outFile: FileFilter

file: GtkFontButton.html
struct: GtkFontButton
class: FontButton
prefix: gtk_font_button_
prefix: gtk_
import: glib.Str
outFile: FontButton

file: GtkFontSelection.html
struct: GtkFontSelection
class: FontSelection
prefix: gtk_font_selection_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgFontFace
structWrap: PangoFontFace* PgFontFace
import:  pango.PgFontFamily
structWrap: PangoFontFamily* PgFontFamily
outFile: FontSelection

file: GtkFontSelectionDialog.html
struct: GtkFontSelectionDialog
class: FontSelectionDialog
prefix: gtk_font_selection_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: FontSelectionDialog

file: GtkInputDialog.html
struct: GtkInputDialog
class: InputDialog
prefix: gtk_input_dialog_
prefix: gtk_
import: gtk.Button

code: start
	Button getCloseButton()
	{
		//int[] arr= [144, 148, 152, 160, 164, 168, 172, 176,
		//	184, 188, 192, 196, 200, 204, 208, 212, 216,
		//	224];

		//foreach(i; arr)
		//{
		//	int* pt2 =cast(int*)getStruct();
		//	pt2+=i/4;
		//	printf("*pt+%d=%X\n", i, *pt2);

		//	Widget wg = new Widget(cast(GtkWidget*)(*pt2));
		//	Stdout(wg.getName()).newline;
		//}

		int* pt =cast(int*)getStruct();
		pt += 172/4;
		return new Button(cast(GtkButton*)(*pt));
	}

	Button getSaveButton()
	{
		//int[] arr= [144, 148, 152, 160, 164, 168, 172, 176,
		//	184, 188, 192, 196, 200, 204, 208, 212, 216,
		//	224];

		//foreach(i; arr)
		//{
		//	int* pt2 =cast(int*)getStruct();
		//	pt2+=i/4;
		//	printf("*pt+%d=%X\n", i, *pt2);

		//	Widget wg = new Widget(cast(GtkWidget*)(*pt2));
		//	Stdout(wg.getName()).newline;
		//}

		int* pt =cast(int*)getStruct();
		pt += 176/4;
		return new Button(cast(GtkButton*)(*pt));
	}
code: end
outFile: InputDialog

###########################################################
### Layout Containers #####################################
###########################################################

file: GtkAlignment.html
struct: GtkAlignment
class: Alignment
prefix: gtk_alignment_
prefix: gtk_
import: gtk.Widget

out: gtk_alignment_get_padding padding_top
out: gtk_alignment_get_padding padding_bottom
out: gtk_alignment_get_padding padding_left
out: gtk_alignment_get_padding padding_right

code: start
	/** */
	public static Alignment center(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment north(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment south(Widget widget)
	{
		Alignment a = new Alignment(0.5, 1.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment east(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
	/** */
	public static Alignment west(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment northWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment northEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 1.0, 0, 0);
		a.add(widget);
		return a;
	}
code: end
outFile: Alignment

file: GtkAspectFrame.html
struct: GtkAspectFrame
class: AspectFrame
prefix: gtk_aspect_frame_
prefix: gtk_
import: glib.Str
outFile: AspectFrame

file: GtkHBox.html
struct: GtkHBox
class: HBox
prefix: gtk_hbox_
prefix: gtk_
outFile: HBox

file: GtkVBox.html
struct: GtkVBox
class: VBox
prefix: gtk_vbox_
prefix: gtk_
outFile: VBox

file: GtkHButtonBox.html
struct: GtkHButtonBox
class: HButtonBox
prefix: gtk_hbutton_box_
prefix: gtk_
code: start
	/**
	 * Creates a new HButtonBox and sets comon parameters
	 */
	static HButtonBox createActionBox()
	{
		HButtonBox bBox = new HButtonBox();
		bBox.setLayout(ButtonBoxStyle.END);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
	
code: end
outFile: HButtonBox

file: GtkVButtonBox.html
struct: GtkVButtonBox
class: VButtonBox
prefix: gtk_vbutton_box_
prefix: gtk_
code: start
    /**
     * Creates a new vertical button box and sets standart values for it's comon parameters
     * Returns: a new vertical button box
     */
	static VButtonBox createActionBox()
	{
		VButtonBox bBox = new VButtonBox();
		bBox.setLayout(ButtonBoxStyle.START);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
code: end
outFile: VButtonBox

file: GtkFixed.html
struct: GtkFixed
class: Fixed
prefix: gtk_fixed_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
override: getHasWindow
override: setHasWindow
outFile: Fixed

file: GtkHPaned.html
struct: GtkHPaned
class: HPaned
prefix: gtk_hpaned_
prefix: gtk_
structWrap: GtkWidget* Widget
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: HPaned

file: GtkVPaned.html
struct: GtkVPaned
class: VPaned
prefix: gtk_vpaned_
prefix: gtk_
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: VPaned

file: GtkLayout.html
struct: GtkLayout
class: Layout
prefix: gtk_layout_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_layout_get_size width
out: gtk_layout_get_size height

outFile: Layout

file: GtkNotebook.html
struct: GtkNotebook
class: Notebook
prefix: gtk_notebook_
prefix: gtk_
import: glib.Str
import: gtk.Label
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_notebook_query_tab_label_packing expand
out: gtk_notebook_query_tab_label_packing fill
out: gtk_notebook_query_tab_label_packing pack_type

code: start
/** The GtkNotebookTab is not documented */
public enum GtkNotebookTab
{
  GTK_NOTEBOOK_TAB_FIRST,
  GTK_NOTEBOOK_TAB_LAST
}
alias GtkNotebookTab NotebookTab;

	/**
	 * Append a page with a widget and a text for a label
	 */
	public int appendPage(Widget child, string tabLabel)
	{
		return appendPage(child, new Label(tabLabel));
	}

	/** */
	void setCurrentPage(Widget child)
	{
		gtk_notebook_set_current_page(gtkNotebook,gtk_notebook_page_num(gtkNotebook, child.getWidgetStruct()));
	}
code: end
outFile: Notebook

file: GtkTable.html
struct: GtkTable
class: Table
import: gtk.Widget
structWrap: GtkWidget* Widget
prefix: gtk_table_
prefix: gtk_

nocode: gtk_table_new

code: start

	int row;
	int col;
	int maxRows;
	int maxCols;

	public AttachOptions defaultXOption = AttachOptions.SHRINK;
	public AttachOptions defaultYOption = AttachOptions.SHRINK;
	
	/**
	 * Removes all children and resizes the table to 1,1
	 */
	override void removeAll()
	{
		super.removeAll();
		resize(1,1);
	}
	
	/**
	 * Used to create a new table widget. An initial size must be given by
	 * specifying how many rows and columns the table should have, although
	 * this can be changed later with gtk_table_resize(). rows and columns
	 * must both be in the range 0 .. 65535.
	 * Params:
	 *  rows = The number of rows the new table should have.
	 *  columns = The number of columns the new table should have.
	 *  homogeneous = If set to TRUE, all table cells are resized to the size of the cell
	 *  containing the largest widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (uint rows, uint columns, int homogeneous)
	{
		// GtkWidget* gtk_table_new (guint rows,  guint columns,  gboolean homogeneous);
		auto p = gtk_table_new(rows, columns, homogeneous);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_table_new");
		}

		this(cast(GtkTable*) p);

		row = 0;
		col = 0;
		maxRows = rows;
		maxCols = columns;
	}
	

	/**
	 * Attach a new widget creating a new row if necessary
	 */
	void attach(Widget child)
	{
		attach(child, col, col + 1, row, row + 1,
				defaultXOption, defaultYOption,
				getDefaultColSpacing(), getDefaultRowSpacing());
		++col;
		if (col >= maxCols)
		{
			col = 0;
			++row;
		}
	}
code: end
outFile: Table

file: GtkExpander.html
struct: GtkExpander
class: Expander
prefix: gtk_expander_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_expander_new
nocode: gtk_expander_new_with_mnemonic

code: start
	/**
	 * Creates a new expander using label as the text of the label.
	 * Since 2.4
	 * Params:
	 *  label = the text of the label
	 *  mnemonic = if true characters in label that are preceded by an underscore,
	 *  are underlined.
	 *  If you need a literal underscore character in a label, use '__' (two
	 *  underscores). The first underlined character represents a keyboard
	 *  accelerator called a mnemonic.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkExpander* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_expander_new_with_mnemonic (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_expander_new (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_expander_new");
		}

		this(p);
	}
code: end

outFile: Expander

file: gtk-Orientable.html
struct: GtkOrientable
class: OrientableT
template: TStruct
prefix: gtk_orientable_
interface: OrientableIF
outFile: OrientableT

###########################################################
### Ornaments #############################################
###########################################################

file: GtkFrame.html
struct: GtkFrame
class: Frame
prefix: gtk_frame_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_frame_get_label_align xalign
out: gtk_frame_get_label_align yalign

code: start
	/**
	 * Creates frame with label and set it's child widget
	 */
	public this(Widget widget, string label)
	{
		this(label);
		add(widget);
	}
code: end

outFile: Frame

file: GtkHSeparator.html
struct: GtkHSeparator
class: HSeparator
prefix: gtk_hseparator_
prefix: gtk_
outFile: HSeparator

file: GtkVSeparator.html
struct: GtkVSeparator
class: VSeparator
prefix: gtk_vseparator_
prefix: gtk_
outFile: VSeparator

###########################################################
### Scrolling #############################################
###########################################################

file: GtkHScrollbar.html
struct: GtkHScrollbar
class: HScrollbar
prefix: gtk_hscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScrollbar

file: GtkVScrollbar.html
struct: GtkVScrollbar
class: VScrollbar
prefix: gtk_vscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScrollbar

file: GtkScrolledWindow.html
struct: GtkScrolledWindow
class: ScrolledWindow
prefix: gtk_scrolled_window_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_scrolled_window_get_policy hscrollbar_policy
out: gtk_scrolled_window_get_policy vscrollbar_policy

nocode: gtk_scrolled_window_new

code: start
	/** */
	public this()
	{
		this(null, null);
	}

	/** */
	public this(Widget widget)
	{
		this();
		addWithViewport(widget);
	}
	
	/**
	 * Creates a new scrolled window. The two arguments are the scrolled
	 * window's adjustments; these will be shared with the scrollbars and the
	 * child widget to keep the bars in sync with the child. Usually you want
	 * to pass NULL for the adjustments, which will cause the scrolled window
	 * to create them for you.
	 * Params:
	 *  hadjustment = Horizontal adjustment.
	 *  vadjustment = Vertical adjustment.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (Adjustment hadjustment, Adjustment vadjustment)
	{
		// GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment,  GtkAdjustment *vadjustment);
		auto p = gtk_scrolled_window_new(
				hadjustment is null ? null : hadjustment.getAdjustmentStruct(), 
				vadjustment is null ? null : vadjustment.getAdjustmentStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_scrolled_window_new");
		}

		this(cast(GtkScrolledWindow*) p);
	}

	/**
	 * Creates a new Scrolled window and set the policy type
	 * Params:
	 *  hPolicy = the horizontal policy
	 *  vPolicy = the vertical policy
	 */
	this(PolicyType hPolicy, PolicyType vPolicy)
	{
		this();
		setPolicy(hPolicy, vPolicy);
	}
code: end
outFile: ScrolledWindow

###########################################################
### Printing ##############################################
###########################################################

file: gtk-High-level-Printing-API.html
struct: GtkPrintOperation
class: PrintOperation
implements: PrintOperationPreviewIF
prefix: gtk_print_operation_
noprefix: gtk_print_operation_preview_
nosignal: got-page-size 
nosignal: ready
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintContext
structWrap: GtkPrintContext* PrintContext
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException

#imports for PrintOperationPreview Interface.
import: gtk.PrintOperationPreviewT
import: gtk.PrintOperationPreviewIF
#import: gtk.Widget
#import: gtk.PageSetup
#import: gtk.PrintSettings

code: start
	// add the PrintOperationPreview capabilities
	mixin PrintOperationPreviewT!(GtkPrintOperation);
code: end
outFile: PrintOperation

struct: GtkPrintOperationPreview
class: PrintOperationPreviewT
template: TStruct
strictPrefix: Y
nosignal: begin-print
nosignal: create-custom-widget
nosignal: custom-widget-apply
nosignal: done
nosignal: draw-page
nosignal: end-print
nosignal: paginate
nosignal: preview
nosignal: request-page-setup 
nosignal: status-changed
prefix: gtk_print_operation_preview_
#prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
interface: PrintOperationPreviewIF
outFile: PrintOperationPreviewT

file: GtkPrintContext.html
struct: GtkPrintContext
class: PrintContext
prefix: gtk_print_context_
prefix: gtk_
import: cairo.Context
structWrap: cairo_t* Context
import: pango.PgContext
structWrap: PangoContext* PgContext
import: pango.PgFontMap
structWrap: PangoFontMap* PgFontMap
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup

out: gtk_print_context_get_hard_margins top
out: gtk_print_context_get_hard_margins bottom
out: gtk_print_context_get_hard_margins left
out: gtk_print_context_get_hard_margins right
outFile: PrintContext

file: GtkPrintSettings.html
struct: GtkPrintSettings
class: PrintSettings
prefix: gtk_print_settings_
prefix: gtk_
import: glib.Str
import: gtk.PaperSize
structWrap: GtkPaperSize* PaperSize
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile

array: gtk_print_settings_get_page_ranges Return num_ranges
array: gtk_print_settings_set_page_ranges page_ranges num_ranges

outFile: PrintSettings

file: GtkPageSetup.html
struct: GtkPageSetup
class: PageSetup
prefix: gtk_page_setup_
prefix: gtk_
import: glib.Str
import: gtk.PaperSize
structWrap: GtkPaperSize* PaperSize
structWrap: GtkPageSetup* PageSetup
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile
outFile: PageSetup

file: gtk-GtkPaperSize.html
struct: GtkPaperSize
class: PaperSize
prefix: gtk_paper_size_
prefix: gtk_
import: glib.Str
structWrap: GtkPaperSize* PaperSize
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile
import: glib.ListG
structWrap: GList* ListG
outFile: PaperSize

file: GtkPrinter.html
struct: GtkPrinter
class: Printer
prefix: gtk_printer_
prefix: gtk_
import: glib.Str
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: glib.ListG
structWrap: GList* ListG

out: gtk_printer_get_hard_margins top
out: gtk_printer_get_hard_margins bottom
out: gtk_printer_get_hard_margins left
out: gtk_printer_get_hard_margins right
outFile: Printer

file: GtkPrintJob.html
struct: GtkPrintJob
class: PrintJob
prefix: gtk_print_job_
prefix: gtk_
import: glib.Str
import: cairo.Surface
structWrap: cairo_surface_t* Surface
import: gtk.Printer
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException
outFile: PrintJob

file: GtkPrintUnixDialog.html
struct: GtkPrintUnixDialog
class: PrintUnixDialog
prefix: gtk_print_unix_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Printer
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings

alias: setSettings setPrintSettings
alias: getSettings getPrintSettings
outFile: PrintUnixDialog

file: GtkPageSetupUnixDialog.html
struct: GtkPageSetupUnixDialog
class: PageSetupUnixDialog
prefix: gtk_page_setup_unix_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
outFile: PageSetupUnixDialog

###########################################################
### Miscellaneous #########################################
###########################################################

file: GtkAdjustment.html
struct: GtkAdjustment
class: Adjustment
prefix: gtk_adjustment_
prefix: gtk_
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
outFile: Adjustment

file: GtkArrow.html
struct: GtkArrow
class: Arrow
prefix: gtk_arrow_
prefix: gtk_
outFile: Arrow

file: GtkCalendar.html
struct: GtkCalendar
class: Calendar
prefix: gtk_calendar_
prefix: gtk_

out: gtk_calendar_get_date year
out: gtk_calendar_get_date month
out: gtk_calendar_get_date day

outFile: Calendar

file: GtkDrawingArea.html
struct: GtkDrawingArea
class: DrawingArea
prefix: gtk_drawing_area_
prefix: gtk_

code: start
	/**
	 * Create a new DrawingArea and sets the SizeRequest
	 * Params:
	 *    	width = 	
	 *    	height =
	 */
	this(int width, int height)
	{
		this();
		setSizeRequest(width, height);
	}
	
code: end

outFile: DrawingArea

file: GtkEventBox.html
struct: GtkEventBox
class: EventBox
prefix: gtk_event_box_
prefix: gtk_
outFile: EventBox

file: GtkHandleBox.html
struct: GtkHandleBox
class: HandleBox
prefix: gtk_handle_box_
prefix: gtk_
outFile: HandleBox

file: GtkIMContextSimple.html
struct: GtkIMContextSimple
class: IMContextSimple
prefix: gtk_im_context_simple_
prefix: gtk_
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
array: gtk_im_context_simple_add_table data n_seqs
outFile: IMContextSimple

file: GtkIMMulticontext.html
struct: GtkIMMulticontext
class: IMMulticontext
prefix: gtk_im_multicontext_
prefix: gtk_
import: glib.Str
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
import: gtk.MenuShell
structWrap: GtkMenuShell* MenuShell
outFile: IMMulticontext

file: GtkSizeGroup.html
struct: GtkSizeGroup
class: SizeGroup
implements: BuildableIF
prefix: gtk_size_group_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkSizeGroup);
code: end
outFile: SizeGroup

file: GtkTooltip.html
struct: GtkTooltip
class: Tooltip
prefix: gtk_tooltip_
prefix: gtk_
import: glib.Str
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Tooltip

file: GtkViewport.html
struct: GtkViewport
class: Viewport
prefix: gtk_viewport_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Viewport

file: GtkAccessible.html
struct: GtkAccessible
class: Accessible
prefix: gtk_accessible_
prefix: gtk_
outFile: Accessible

###########################################################
### Abstract Base Classes #################################
###########################################################

file: GtkBin.html
struct: GtkBin
class: Bin
prefix: gtk_bin_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Bin

file: GtkBox.html
struct: GtkBox
class: Box
implements: OrientableIF
prefix: gtk_box_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_box_query_child_packing expand
out: gtk_box_query_child_packing fill
out: gtk_box_query_child_packing padding
out: gtk_box_query_child_packing pack_type

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkBox);
code: end
outFile: Box

file: GtkButtonBox.html
struct: GtkButtonBox
class: ButtonBox
prefix: gtk_button_box_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Button
import: gtk.HButtonBox
import: gtk.VButtonBox

out: gtk_button_box_get_child_size min_width
out: gtk_button_box_get_child_size min_height
out: gtk_button_box_get_child_ipadding ipad_x
out: gtk_button_box_get_child_ipadding ipad_y

code: start
	/** */
	static ButtonBox createActionBox(
			void delegate(Button) onClicked, 
			StockID[] stocks, 
			string[] actions,
			bool vertical=false
		)
	{
		ButtonBox bBox;
		if ( vertical )
		{
			bBox = VButtonBox.createActionBox();
		}
		else
		{
			bBox = HButtonBox.createActionBox();
		}

		Button button;
		for( int i=0 ; i<stocks.length && i<actions.length ; i++)
		{
			button =  new Button(stocks[i]);
			bBox.packEnd(button, false, false, 7);
			button.setActionName(actions[i]);
			button.addOnClicked(onClicked);
		}
		return bBox;
	}

	/** */
	static ButtonBox createOkBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK];
		string[] actions;
		actions ~= "action.ok";
		return createActionBox(onClicked, stocks, actions);
	}

	/** */
	static ButtonBox createOkCancelBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK, StockID.CANCEL];
		string[] actions;
		actions ~= "action.ok";
		actions ~= "action.cancel";
		return createActionBox(onClicked, stocks, actions);
	}
code: end
outFile: ButtonBox

file: GtkContainer.html
struct: GtkContainer
class: Container
structWrap: GtkContainerClass* Container
structWrap: GtkWidget* Widget
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
prefix: gtk_container_
prefix: gtk_
import: glib.ListG
structWrap: GList* ListG
import: gobject.Value
structWrap: GValue* Value
#import: gdk.EventExpose
#structWrap: GdkEventExpose* EventExpose
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
#import: g.ObjectClass
#structWrap: GObjectClass* ObjectClass

out: gtk_container_get_focus_chain focusable_widgets
array: gtk_container_class_list_child_properties Return n_properties

code: start

	/**
	 * Removes all widgets from the container
	 */
	void removeAll()
	{
		GList* gList = gtk_container_get_children(getContainerStruct());
		if ( gList !is null )
		{
			ListG children = new ListG(gList);
			for ( int i=children.length()-1 ; i>=0 ; i-- )
			{
				gtk_container_remove(getContainerStruct(), cast(GtkWidget*)children.nthData(i));
			}
		}
	}

code: end
outFile: Container

file: GtkItem.html
struct: GtkItem
class: Item
prefix: gtk_item_
prefix: gtk_
outFile: Item

file: GtkMenuShell.html
struct: GtkMenuShell
class: MenuShell
prefix: gtk_menu_shell_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: MenuShell

file: GtkMisc.html
struct: GtkMisc
class: Misc
prefix: gtk_misc_
prefix: gtk_

out: gtk_misc_get_alignment xalign
out: gtk_misc_get_alignment yalign
out: gtk_misc_get_padding xpad
out: gtk_misc_get_padding ypad

outFile: Misc

file: GtkObject.html
struct: GtkObject
class: ObjectGtk
prefix: gtk_object_
prefix: gtk_
import: glib.Str
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk

nocode: gtk_object_ref
nocode: gtk_object_unref
nocode: gtk_object_set_data
nocode: gtk_object_get_data
nocode: gtk_object_set_data_full
nocode: gtk_object_remove_data

code: star
	/** */
	public static string getId(StockID id)
	{
		return StockDesc[id];
	}
code: end

outFile: ObjectGtk

file: GtkPaned.html
struct: GtkPaned
class: Paned
implements: OrientableIF
prefix: gtk_paned_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkPaned);

	/** */
	public void add(Widget child1, Widget child2)
	{
		add1(child1);
		add2(child2);
	}
code: end
outFile: Paned

file: GtkRange.html
struct: GtkRange
class: Range
implements: OrientableIF
prefix: gtk_range_
prefix: gtk_
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_range_get_slider_range slider_start
out: gtk_range_get_slider_range slider_end

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkRange);
code: end
outFile: Range

file: GtkScale.html
struct: GtkScale
class: Scale
prefix: gtk_scale_
prefix: gtk_
import: glib.Str
import: pango.PgLayout
structWrap: PangoLayout* PgLayout

out: gtk_scale_get_layout_offsets x
out: gtk_scale_get_layout_offsets y

outFile: Scale

file: GtkScrollbar.html
struct: GtkScrollbar
class: Scrollbar
prefix: gtk_scrollbar_
prefix: gtk_
outFile: Scrollbar

file: GtkSeparator.html
struct: GtkSeparator
class: Separator
implements: OrientableIF
prefix: gtk_separator
prefix: gtk_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkSeparator);
code: end
outFile: Separator

file: GtkWidget.html
struct: GtkWidget
nostruct: GtkWidgetClass
class: Widget
implements: BuildableIF
import: glib.Str
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_widget_
prefix: gtk_
# This function is exactly the same as calling g_object_ref(), and exists mostly for historical reasons.
noprefix: gtk_widget_ref
structWrap: GtkWidget* Widget
import: gtk.Action
structWrap: GtkAction* Action 
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
#import: gtk.Allocation
#structWrap: GtkAllocation* Allocation
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gtk.Style
structWrap: GtkStyle* Style
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gtk.RcStyle
structWrap: GtkRcStyle* RcStyle
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
#import: gtk.WidgetClass
#structWrap: GtkWidgetClass* WidgetClass
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: gdk.Region
structWrap: GdkRegion* Region
import: gobject.Value
structWrap: GValue* Value
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtkc.gdk
import: gdk.Cursor

import: pango.PgLayout
structWrap: PangoLayout* PgLayout
import: pango.PgContext
structWrap: PangoContext* PgContext
import: pango.PgFontDescription
structWrap: PangoFontDescription* PgFontDescription
import: gdk.Drawable
import: gtk.Tooltips
import: gobject.Type
import: std.conv

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

# New in 2.14, keep using the manually added ones for backwards compatibility.
nocode: gtk_widget_get_window
nocode: gtk_widget_get_allocation

override: unref
override: destroy
override: set

inout: gtk_widget_destroyed widget_pointer
out: gtk_widget_get_size_request width
out: gtk_widget_get_size_request height
out: gtk_widget_translate_coordinates dest_x
out: gtk_widget_translate_coordinates dest_y
out: gtk_widget_size_request requisition
out: gtk_widget_get_child_requisition requisition
out: gtk_widget_get_pointer x
out: gtk_widget_get_pointer y
array: gtk_widget_class_list_style_properties Return n_properties
out: gtk_widget_path path_length
out: gtk_widget_path path
out: gtk_widget_path path_reversed
out: gtk_widget_class_path path_length
out: gtk_widget_class_path path
out: gtk_widget_class_path path_reversed
inout: gtk_widget_set_allocation allocation
out: gtk_widget_get_requisition requisition

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkWidget);

	public GtkWidgetClass* getWidgetClass()
	{
		return Type.getInstanceClass!(GtkWidgetClass)(this);
	}

	/** */
	public int getWidth()
	{
		int width;
		gtk_widget_get_size_request(gtkWidget, &width, null);
		return width;
	}

	/** */
	public int getHeight()
	{
		int height;
		gtk_widget_get_size_request(gtkWidget, null, &height);
		return height;
	}

	/**
	 * The widget's allocated size.
	 * Returns: the GtkAllocation for this widget
	 */
	public GtkAllocation getAllocation()
	{
		GtkAllocation allo;
		int* pt = cast(int*)getStruct();

		version (X86_64)
		{
			pt += 64/4; 
		}
		else
		{ 
			pt += 36/4;
		} 

		allo.x = *pt;

		pt++;
		allo.y = *pt;

		pt++;
		allo.width = *pt;

		pt++;
		allo.height = *pt;

		return allo;
	}

	/**
	 * Gets the drawable for this widget
	 * Returns:
	 * 		The drawable for this widget
	 * Deprecated: use getWindow().
	 */
	deprecated Drawable getDrawable()
	{
		return getWindow();
	}

	/**
	 * Gets the Window for this widget
	 * Returns:
	 * 		The window for this widget
	 */
	Window getWindow()
	{
		
		//		ubyte *p = cast(ubyte*)getStruct();
		//
		//		for ( int i=0 ; i<120 ; i+=4 )
		//		{
			//			printf("(%d) %X %x %x %x %x\n", i,p,*(p+0), *(p+1), *(p+2), *(p+3));
			//			p+=4;
		//		}
		//
		//		int* pt =cast(int*)getStruct();
		//
		//		printf("pt=%X strcut=%X\n", pt, getStruct());
		//		printf("*pt=%X\n", *pt);
		//		pt+=52/4;
		//		printf("pt+52=%X strcut.window=%X\n", pt, getWidgetStruct().window);
		//		printf("*pt+52=%X\n", *pt);
		//
		//		//return new Drawable(cast(GdkDrawable*)(getWidgetStruct().window));
		int* pt =cast(int*)getStruct();

		version (X86_64)
		{
			pt += 80/4; 
		}
		else
		{ 
			pt += 52/4; 
		} 

		return new Window(cast(GdkWindow*)(*pt));
	}

	/**
	 * Sets  the cursor.
	 * Params:
	 *  cursor = the new cursor
	 * Bugs: the cursor changes to the parent widget also
	 */
	void setCursor(Cursor cursor)
	{
		getWindow().setCursor(cursor);
	}
	
	/**
	 * Resets the cursor.
	 * don't know if this is implemented by GTK+. Seems that it's not
	 * Bugs: does nothing
	 */
	public void resetCursor()
	{
		getWindow().setCursor(null);
	}

	/**
	 * Modifies the font for this widget.
	 * This just calls modifyFont(new PgFontDescription(PgFontDescription.fromString(family ~ " " ~ size)));
	 */
	public void modifyFont(string family, int size)
	{
		if ( size < 0 ) size = -size;	// hack to workaround leds bug - TO BE REMOVED

		version(Tango)
		{
			char[10] s;
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ tango.text.convert.Integer.itoa(s,size)
				)
			);
		}
		else version(D_Version2)
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ to!(string)(size)
				)
			);
		}
		else
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ std.string.toString(size)
				)
			);
		}
	}
	
	
	/**
	 * Sets this widget tooltip
	 * Deprecated: Since 2.12 use setTooltipText() or setTooltipMarkup()
	 * Params:
	 *  tipText = the tooltip
	 *  tipPrivate = a private text
	 */
	void setTooltip(string tipText, string tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}

	/** */
	public bool onEvent(GdkEvent* event)
	{
		return getWidgetClass().event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonPressEvent(GdkEventButton* event)
	{
		return getWidgetClass().buttonPressEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonReleaseEvent(GdkEventButton* event)
	{
		return getWidgetClass().buttonReleaseEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onScrollEvent(GdkEventScroll* event)
	{
		return getWidgetClass().scrollEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMotionNotifyEvent(GdkEventMotion* event)
	{
		return getWidgetClass().motionNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onDeleteEvent(GdkEventAny* event)
	{
		return getWidgetClass().deleteEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onExposeEvent(GdkEventExpose* event)
	{
		return getWidgetClass().exposeEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyPressEvent(GdkEventKey* event)
	{
		return getWidgetClass().keyPressEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyReleaseEvent(GdkEventKey* event)
	{
		return getWidgetClass().keyReleaseEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onEnterNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().enterNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onLeaveNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().leaveNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onConfigureEvent(GdkEventConfigure* event)
	{
		return getWidgetClass().configureEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusInEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focusInEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusOutEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focusOutEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMapEvent(GdkEventAny* event)
	{
		return getWidgetClass().mapEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onUnmapEvent(GdkEventAny* event)
	{
		return getWidgetClass().unmapEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onPropertyNotifyEvent(GdkEventProperty* event)
	{
		return getWidgetClass().propertyNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionClearEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionClearEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionRequestEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionRequestEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionNotifyEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityInEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximityInEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityOutEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximityOutEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onVisibilityNotifyEvent(GdkEventVisibility* event)
	{
		return getWidgetClass().visibilityNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onClientEvent(GdkEventClient* event)
	{
		return getWidgetClass().clientEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onNoExposeEvent(GdkEventAny* event)
	{
		return getWidgetClass().noExposeEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onWindowStateEvent(GdkEventWindowState* event)
	{
		return getWidgetClass().windowStateEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	//get the addOnDestroy from ObjectGtk
	alias ObjectGtk.addOnDestroy addOnDestroy;
code: end
outFile: Widget

file: GtkIMContext.html
struct: GtkIMContext
class: IMContext
prefix: gtk_im_context_
prefix: gtk_
import: glib.Str
import: gdk.Window
structWrap: GdkWindow* Window
#import: gtk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle

out: gtk_im_context_get_preedit_string str
out: gtk_im_context_get_preedit_string attrs
out: gtk_im_context_get_preedit_string cursor_pos
out: gtk_im_context_get_surrounding text
out: gtk_im_context_get_surrounding cursor_index


outFile: IMContext

###########################################################
### Cross-process Embedding ###############################
###########################################################

file: GtkPlug.html
struct: GtkPlug
class: Plug
prefix: gtk_plug_
prefix: gtk_
import: gdk.Display
structWrap: GdkDisplay* Display
outFile: Plug

file: GtkSocket.html
struct: GtkSocket
class: Socket
prefix: gtk_socket_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
outFile: Socket

###########################################################
### Special-purpose features ##############################
###########################################################

file: GtkCurve.html
struct: GtkCurve
class: Curve
prefix: gtk_curve_
prefix: gtk_
outFile: Curve

file: GtkGammaCurve.html
struct: GtkGammaCurve
class: GammaCurve
prefix: gtk_gamma_curve_
prefix: gtk_
outFile: GammaCurve

file: GtkRuler.html
struct: GtkRuler
class: Ruler
implements: OrientableIF
prefix: gtk_ruler_
prefix: gtk_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_ruler_get_range lower
out: gtk_ruler_get_range upper
out: gtk_ruler_get_range position
out: gtk_ruler_get_range max_size

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkRuler);
code: end
outFile: Ruler

file: GtkHRuler.html
struct: GtkHRuler
class: HRuler
prefix: gtk_hruler_
prefix: gtk_
outFile: HRuler

file: GtkVRuler.html
struct: GtkVRuler
class: VRuler
prefix: gtk_vruler_
prefix: gtk_
outFile: VRuler

###########################################################
### Recently Used Documents ###############################
###########################################################

file: GtkRecentManager.html
struct: GtkRecentManager
class: RecentManager
prefix: gtk_recent_manager_
#prefix: gtk_
noprefix: gtk_recent_info_
import: glib.Str
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.RecentInfo
structWrap: GtkRecentInfo* RecentInfo
structWrap: GtkRecentManager* RecentManager
import: glib.ErrorG
import: glib.GException
import: glib.ListG
structWrap: GList* ListG
outFile: RecentManager

struct: GtkRecentInfo
class: RecentInfo
strictPrefix: Y
nosignal: changed
prefix: gtk_recent_info_
#prefix: gtk_
import: glib.Str
structWrap: GtkRecentInfo* RecentInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

out: gtk_recent_info_get_application_info app_exec
out: gtk_recent_info_get_application_info count
out: gtk_recent_info_get_application_info time_
array: gtk_recent_info_get_applications Return length
array: gtk_recent_info_get_groups Return length

outFile: RecentInfo

file: GtkRecentChooser.html
struct: GtkRecentChooser
class: RecentChooserT
template: TStruct
prefix: gtk_recent_chooser_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.RecentInfo
structWrap: GtkRecentInfo* RecentInfo
import: gtk.RecentFilter
structWrap: GtkRecentFilter* RecentFilter
import: glib.ListG
structWrap: GList* ListG
import: glib.ListSG
structWrap: GSList* ListSG
alias: setShowNumbers recentChooserSetShowNumbers
alias: getShowNumbers recentChooserGetShowNumbers
array: gtk_recent_chooser_get_uris Return length
interface: RecentChooserIF
outFile: RecentChooserT

file: GtkRecentChooserDialog.html
struct: GtkRecentChooserDialog
class: RecentChooserDialog
implements: RecentChooserIF
prefix: gtk_recent_chooser_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

nocode: gtk_recent_chooser_dialog_new
nocode: gtk_recent_chooser_dialog_new_for_manager

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserDialog);

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  string[] buttonsText=null, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  stockIDs = stockIDs of the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  StockID[] stockIDs, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(stockIDs, responses);
	}
code: end
outFile: RecentChooserDialog

file: GtkRecentChooserMenu.html
struct: GtkRecentChooserMenu
class: RecentChooserMenu
implements: ActivatableIF
implements: RecentChooserIF
prefix: gtk_recent_chooser_menu_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkRecentChooserMenu);

	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserMenu);
code: end
outFile: RecentChooserMenu

file: GtkRecentChooserWidget.html
struct: GtkRecentChooserWidget
class: RecentChooserWidget
implements: RecentChooserIF
prefix: gtk_recent_chooser_widget_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserWidget);
code: end
outFile: RecentChooserWidget

file: GtkRecentFilter.html
struct: GtkRecentFilter
class: RecentFilter
prefix: gtk_recent_filter_
prefix: gtk_
import: glib.Str
outFile: RecentFilter

###########################################################
### Interface builder #####################################
###########################################################

file: gtk-gtkbuildable.html
struct: GtkBuildable
class: BuildableT
template: TStruct
prefix: gtk_buildable_
prefix: gtk_
import: glib.Str
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gobject.Value
structWrap: GValue* Value
import: gtk.Builder
structWrap: GtkBuilder* Builder
#import: glib.MarkupParser
#structWrap: GMarkupParser* MarkupParser

alias: setName buildableSetName
alias: getName buildableGetName

interface: BuildableIF
outFile: BuildableT

file: GtkBuilder.html
struct: GtkBuilder
class: Builder
prefix: gtk_builder_
prefix: gtk_
import: glib.ErrorG
import: glib.GException
import: glib.ListSG
import: glib.Str
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
import: std.string
import: gtkc.glib;
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GSList* ListSG
structWrap: GValue* Value

nocode: gtk_builder_get_object
nocode: gtk_builder_get_objects

#imports for gtk_builder_real_get_type_from_name_override
import: gtkc.gobject
import: gtkc.paths
import: glib.Module
import: gobject.Type

array: gtk_builder_add_objects_from_file object_ids
array: gtk_builder_add_objects_from_string object_ids

nocode: gtk_builder_new
code: start
	private struct GtkBuilderClass
	{
		GObjectClass parentClass;
		extern(C) GType function( GtkBuilder*, char* ) get_type_from_name;
		
		/* Padding for future expansion */
		extern(C) void  function()  _gtk_reserved1;
		extern(C) void  function()  _gtk_reserved2;
		extern(C) void  function()  _gtk_reserved3;
		extern(C) void  function()  _gtk_reserved4;
		extern(C) void  function()  _gtk_reserved5;
		extern(C) void  function()  _gtk_reserved6;
		extern(C) void  function()  _gtk_reserved7;
		extern(C) void  function()  _gtk_reserved8;
	}

	/**
	 * Creates a new builder object.
	 * Since 2.12
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this ()
	{
		// GtkBuilder* gtk_builder_new (void);
		auto p = gtk_builder_new();
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_builder_new()");
		}
		this(cast(GtkBuilder*) p);

		GtkBuilderClass* klass = Type.getInstanceClass!(GtkBuilderClass)( this );
		klass.get_type_from_name = &gtk_builder_real_get_type_from_name_override;
	}

	/**
	 * This function is a modification of _gtk_builder_resolve_type_lazily from "gtk/gtkbuilder.c".
	 * It is needed because it assumes we are linking at compile time to the gtk libs.
	 * specifically the NULL in g_module_open( NULL, 0 );
	 * It replaces the default function pointer "get_type_from_name" in GtkBuilderClass.
	 */
	extern(C) private static GType gtk_builder_real_get_type_from_name_override ( GtkBuilder* builder, char *name )
	{
		GType gtype;
		gtype = g_type_from_name( name );
		if (gtype != GType.INVALID)
		{
			return gtype;
		}
		
		/*
		 * Try to map a type name to a _get_type function
		 * and call it, eg:
		 *
		 * GtkWindow -> gtk_window_get_type
		 * GtkHBox -> gtk_hbox_get_type
		 * GtkUIManager -> gtk_ui_manager_get_type
		 *
		 */
		char   c;
		string symbol_name;

		for (int i = 0; name[i] != '\0'; i++)
		{
			c = name[i];
			/* skip if uppercase, first or previous is uppercase */
			if ((c == Str.asciiToupper (c) &&
			   i > 0 && name[i-1] != Str.asciiToupper (name[i-1])) ||
			  (i > 2 && name[i]   == Str.asciiToupper (name[i]) &&
			   name[i-1] == Str.asciiToupper (name[i-1]) &&
			   name[i-2] == Str.asciiToupper (name[i-2]))
			   )

			symbol_name ~= '_';
			symbol_name ~= Str.asciiTolower (c);
		}
		symbol_name ~=  "_get_type" ;

		/* scan linked librarys for function symbol */
		foreach ( lib; importLibs )
		{
			GType function() func;
			Module mod = Module.open( libPath ~ lib, GModuleFlags.BIND_LAZY );
			if( mod is null )
				continue;
			
			scope(exit) mod.close();

			if ( mod.symbol( symbol_name, cast(void**) &func ) ) {
				return func();
			}
		}

		return GType.INVALID;
	}

	/**
	 * Gets the object named name. Note that this function does not
	 * increment the reference count of the returned object.
	 * Since 2.12
	 * Params:
	 * name = name of object to get
	 * Returns: the object named name or NULL if it could not be found in the object tree.. transfer none.
	 */
	public ObjectG getObject(string name)
	{
		// GObject* gtk_builder_get_object (GtkBuilder *builder,  const gchar *name);
		return newFromObject( gtk_builder_get_object(gtkBuilder, Str.toStringz(name)) );
	}

	/**
	 * Gets all objects that have been constructed by builder.
	 * Since 2.12
	 * Returns: an array containing all the objects constructed by the GtkBuilder instance.
	 */
	public ObjectG[] getObjects()
	{
		ObjectG[] objects;

		// GSList* gtk_builder_get_objects (GtkBuilder *builder);
		GSList* list = gtk_builder_get_objects(gtkBuilder);

		while ( list.next !is null )
		{
			objects ~= newFromObject( cast(GObject*)list.data );
			list = list.next;
		}

		g_slist_free(list);

		return objects;
	}

	/**
	 * This function creates an D object corresponding to the Struct pointer passed in.
	 */
	public ObjectG newFromObject(GObject* cobj)
	{
		//version( !LLVM )
		version(LLVM) {} else
		{
			alias ClassInfo.find findClassInfo;
		}

		if(cobj is null)
		{
			return null;
		}

		string type = convertClassName(Type.name((cast(GTypeInstance*)cobj).gClass.gType));
		ClassInfo ci = findClassInfo(type);

		//Gobject and Gio types both start with g, so try both.
		if(ci is null && startsWith(type, "gobject"))
		{
				ci = findClassInfo("gio"~ type[7..$]);
		}

		if(ci is null)
		{
			return null;
		}

		ObjectG obj = cast(ObjectG)_d_newclass(ci);

		version(D_Version2)
		{
			obj.__ctor(cobj);
		}
		else
		{
			obj._ctor(cobj);
		}

		return obj;
	}

	/**
	 * Turn the name of a C Type in to the name of the corresponding D type.
	 * Note: If the prefix of the type is "G" this always usses "gobject" as
	 *     the prefix, extra care should be taken for types from GIO.
	 */
	private string convertClassName(string gName)
	{
		string conv;
		string prefix;

		version(Tango)
		{
			alias toUpper toupper;
			alias toLower tolower;
		}

		if      ( startsWith(gName, "GtkSource" ) ) prefix = "Gsv";
		else if ( startsWith(gName, "Gtk") )        prefix = "Gtk";
		else if ( startsWith(gName, "Gdk") )        prefix = "Gdk";
		else if ( startsWith(gName, "Gst") )        prefix = "Gst";
		else if ( startsWith(gName, "Gda") )        prefix = "Gda";
		else if ( startsWith(gName, "Atk") )        prefix = "Atk";
		else if ( startsWith(gName, "G") )          prefix = "G";
		else if ( startsWith(gName, "Pango") )      prefix = "Pg";
		else if ( startsWith(gName, "cairo") )      prefix = "cairo";

		conv = gName[prefix.length..gName.length];

		if ( conv == "Object" ) conv ~= prefix;
		if ( prefix == "Pg" )   conv = "Pg" ~ gName[5..gName.length];
		if ( prefix == "cairo") conv = toupper(gName[6..7]) ~ gName[7..gName.length - 2];

		prefix = tolower(prefix);

		if( prefix == "gst") prefix = "gstreamer";
		if( prefix == "g")   prefix = "gobject";
		if( prefix == "pg" ) prefix = "pango";

		return prefix ~"."~ conv ~"."~ conv;
	}

	private bool startsWith(string str, string prefix)
	{
		return str.length >= prefix.length && str[0..prefix.length] == prefix;
	}

	version(LLVM)
	{
		private Object _d_newclass(ClassInfo ci)
		{
			void* p = cast(void*)_d_allocclass(ci);
			(cast(byte*) p)[0 .. ci.init.length] = ci.init[];

			return cast(Object) p;
		}

		private ClassInfo findClassInfo(string classname)
		{
			foreach ( m; ModuleInfo )
			{
				foreach ( c; m.localClasses )
				{
					if ( c.name == classname )
					return c;
				}
			}
		}
	}
code: end
outFile: Builder

###########################################################
### Deprecated ############################################
###########################################################

#file: GtkCList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCombo.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkFileSelection.html
struct: GtkFileSelection
class: FileSelection
prefix: gtk_file_selection_
prefix: gtk_
import: glib.Str
outFile: FileSelection

file: GtkItemFactory.html
struct: GtkItemFactory
class: ItemFactory
prefix: gtk_item_factory_
prefix: gtk_
noprefix: gtk_item_factory_create_menu_entries
import: glib.Str
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
structWrap: GtkItemFactory* ItemFactory
#import: gtk.ItemFactoryEntry
#structWrap: GtkItemFactoryEntry* ItemFactoryEntry
outFile: ItemFactory

#file: GtkList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkListItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOldEditable.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOptionMenu.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPixmap.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPreview.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkText.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkTooltips.html
struct: GtkTooltips
class: Tooltips
prefix: gtk_tooltips_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TooltipsData
#structWrap: GtkTooltipsData* TooltipsData
import: gtk.Window
structWrap: GtkWindow* Window

out: gtk_tooltips_get_info_from_tip_window tooltips
out: gtk_tooltips_get_info_from_tip_window current_widget

outFile: Tooltips

#file: gtkTipsQuery.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTreeItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkProgress.html
struct: GtkProgress
class: Progress
prefix: gtk_progress_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Progress
