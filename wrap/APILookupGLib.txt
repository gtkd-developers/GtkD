#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping GLib
#####
###
#


addTypedefs: start
/* The GLib Basic Types */
public alias int gint;
public alias uint guint;
public alias int gboolean;
public alias void* gpointer;
public alias void* gconstpointer;
public alias char gchar;
public alias char guchar;
public alias short gshort;
public alias ushort gushort;
public alias byte gint8;
public alias ubyte guint8;
public alias short gint16;
public alias ushort guint16;
public alias int gint32;
public alias long gint64;
public alias uint guint32;
public alias ulong guint64;
public alias float gfloat;
public alias double gdouble;
public alias size_t gsize;
public alias ptrdiff_t gssize;
public alias long goffset;
public alias void* va_list;
public alias dchar unichar;
public alias wchar unichar2;
public alias uint time_t;
public alias uint XID;
public alias uint uid_t;


version(Tango)
{
	//avoid some conflicts with other string aliases.
	static if( !is(string) )
		alias char[] string;
}

version( Windows )
{
	alias int glong;
	alias uint gulong;
}
else version( X86_64 )
{
	alias long glong;
	alias ulong gulong;
}
else
{
	alias int glong;
	alias uint gulong;
}

version(D_Version2)
{
	mixin("enum _shared = \"shared \";");
	mixin("enum gshared = \"__gshared \";");
}
else
{
	const char[] _shared = "";
	const char[] gshared = "";
}

version (Windows)
{
	version(Tango)
	{
		private import tango.stdc.stdio;

		//Phobos defines this function in std.c.stdio
		extern (C) FILE*  fdopen(int, char*);
	}
	version(D_Version2)
	{
		private import core.stdc.stdio;

		extern (C) FILE*  fdopen(int, char*);
	}
}
addTypedefs: end

addAliases: start
addAliases: end

addEnums: start

enum GPriority
{
	HIGH = -100,
	DEFAULT = 0,
	HIGH_IDLE = 100,
	DEFAULT_IDLE = 200,
	LOW = 300
}

addEnums: end

addStructs: start
public struct GSocketControlMessageClass{}
public struct GInetSocketAddressClass{}
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start

const uint G_MAXUINT = 4294967295;

addConstants: end


# must start with wrap

wrap: glib

###########################################################
### GLib Fundamentals #####################################
###########################################################

file: glib-Version-Information.html
class: Version
prefix: glib_
import: glib.Str
outFile: GLib

#file: glib-Basic-Types.html
#outFile: types

#file: glib-Limits-of-Basic-Types.html
#outFile: typeLimits

#file: glib-Standard-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Type-Conversion-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Byte-Order-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Numerical-Definitions.html
#class: 
#prefix: 
#outFile: 

#file: glib-Miscellaneous-Macros.html
#class: 
#prefix: 
#outFile: 

file: glib-Atomic-Operations.html
class: Atomic
prefix: g_atomic_
outFile: Atomic

###########################################################
### GLib Core Application Support #########################
###########################################################

file: glib-The-Main-Event-Loop.html

struct: GMainLoop
class: MainLoop
prefix: g_main_loop_
prefix: g_
noprefix: g_main_context_
noprefix: g_timeout_
noprefix: g_idle_
noprefix: g_child_
noprefix: g_source_
structWrap: GMainLoop* MainLoop
import: glib.MainContext
structWrap: GMainContext* MainContext
import: glib.Source
structWrap: GSource* Source
import: gtkc.paths;
import: gtkc.Loader;
array: g_poll fds nfds

code: start
	~this()
	{
		if ( importLibs[LIBRARY.GLIB] in Linker.loadedLibraries )
		{
			unref();
		}
	}
code: end
outFile: MainLoop

struct: GMainContext
class: MainContext
prefix: g_main_context_
strictPrefix: Yes
import: glib.Source
structWrap: GSource* Source
import: gthread.Cond
structWrap: GCond* Cond
import: gthread.Mutex
structWrap: GMutex* Mutex
structWrap: GMainContext* MainContext
#import: glib.SourceFuncs
#structWrap: GSourceFuncs* SourceFuncs
#import: glib.PollFD
#structWrap: GPollFD* PollFD

out: g_main_context_prepare priority
out: g_main_context_query timeout_

outFile: MainContext

class: Timeout
prefix: g_timeout_
strictPrefix: Yes
import: glib.Source
structWrap: GSource* Source
code: start
	/** Holds all timeout delegates */
	bool delegate()[] timeoutListeners;
	/** our gtk timeout ID */
	uint timeoutID;

	 
	/**
	 * Creates a new timeout cycle with the default priority, GPriority.DEFAULT.
	 *
	 * Note that timeout functions may be delayed, due to the processing of other
	 * event sources. Thus they should not be relied on for precise timing.
	 * After each call to the timeout function, the time of the next timeout is
	 * recalculated based on the current time and the given interval
	 * (it does not try to 'catch up' time lost in delays). 
	 * Params:
	 *    	interval = 	the timeout in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(uint interval, bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = g_timeout_add(interval, cast(GSourceFunc)&timeoutCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/**
	 * Creates a new timeout cycle.
	 * Params:
	 *    	interval = 	the timeout in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *      priority = Priority for the timeout function
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(uint interval, bool delegate() dlg, GPriority priority, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = g_timeout_add_full(priority, interval, cast(GSourceFunc)&timeoutCallback, cast(void*)this, null);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/**
	 * Creates a new timeout cycle with the default priority, GPriority.DEFAULT.
	 * Params:
	 *    	delegate() = 	the delegate to be executed
	 *      seconds = interval in seconds.
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, uint seconds, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = g_timeout_add_seconds(seconds, cast(GSourceFunc)&timeoutCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/**
	 * Creates a new timeout cycle.
	 * Params:
	 *    	delegate() = 	the delegate to be executed
	 *      seconds = interval in seconds.
	 *      priority = Priority for the timeout function
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, uint seconds, GPriority priority, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = g_timeout_add_seconds_full(priority, seconds, cast(GSourceFunc)&timeoutCallback, cast(void*)this, null);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( timeoutID > 0 )
		{
			g_source_remove(timeoutID);
		}
		timeoutListeners.length = 0;
	}
	
	/**
	 * Removes the timeout from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this timeout cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = timeoutListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	timeout = 	
	 * Returns: 
	 */
	extern(C) static bool timeoutCallback(Timeout timeout)
	{
		return timeout.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<timeoutListeners.length )
		{
			if ( !timeoutListeners[i]() )
			{
				timeoutListeners = timeoutListeners[0..i] ~ timeoutListeners[i+1..timeoutListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Timeout

class: Idle
prefix: g_idle_
strictPrefix: Yes
import: glib.Source
structWrap: GSource* Source
code: start
	/** Holds all idle delegates */
	bool delegate()[] idleListeners;
	/** our idle ID */
	uint idleID;

	/**
	 * Creates a new idle cycle.
	 * Params:
	 *    	interval = the idle in milieconds
	 *    	dlg = the delegate to be executed
	 *    	fireNow = When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		idleID = g_idle_add(cast(GSourceFunc)&idleCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = 0;
			}
		}
	}

	/**
	 * Creates a new idle cycle.
	 * Params:
	 *    	dlg = the delegate to be executed
	 *      priority = Priority for the idle function
	 *    	fireNow = When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, GPriority priority, bool fireNow=false)
	{
		idleListeners ~= dlg;
		idleID = g_idle_add_full(priority, cast(GSourceFunc)&idleCallback, cast(void*)this, null);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( idleID > 0 )
		{
			g_source_remove(idleID);
		}
		idleListeners.length = 0;
	}
	
	/**
	 * Removes the idle from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this idle cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = idleListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	idle = 	
	 * Returns: 
	 */
	extern(C) static bool idleCallback(Idle idle)
	{
		return idle.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<idleListeners.length )
		{
			if ( !idleListeners[i]() )
			{
				idleListeners = idleListeners[0..i] ~ idleListeners[i+1..idleListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Idle

class: Child
import: glib.Source
structWrap: GSource* Source
prefix: g_child_
strictPrefix: Yes
outFile: Child

struct: GSource
class: Source
prefix: g_source_
strictPrefix: Yes
import: glib.Str
#import: glib.SourceFuncs
#structWrap: GSourceFuncs* SourceFuncs
structWrap: GSource* Source
import: glib.MainContext
structWrap: GMainContext* MainContext
#import: glib.SourceCallbackFuncs
#structWrap: GSourceCallbackFuncs* SourceCallbackFuncs
#import: glib.PollFD
#structWrap: GPollFD* PollFD
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
outFile: Source


#file: glib-Threads.html
#In APILookupGThread.txt

file: glib-Thread-Pools.html
struct: GThreadPool
class: ThreadPool
prefix: g_thread_pool_
import: glib.ErrorG
import: glib.GException
outFile: ThreadPool


file: glib-Asynchronous-Queues.html
struct: GAsyncQueue
class: AsyncQueue
prefix: g_async_queue_
structWrap: GAsyncQueue* AsyncQueue
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
outFile: AsyncQueue

file: glib-Dynamic-Loading-of-Modules.html
struct: GModule
class: Module
prefix: g_module_
structWrap: GModule* Module
import: glib.Str
text: start
g_module_open ()
GModule* g_module_open (const gchar *file_name, GModuleFlags flags);
Opens a module. If the module has already been opened, its reference
count is incremented.
First of all g_module_open() tries to open file_name as a module. If
that fails and file_name has the ".la"-suffix (and is a libtool archive)
it tries to open the corresponding module. If that fails and it doesn't
have the proper module suffix for the platform (G_MODULE_SUFFIX), this
suffix will be appended and the corresponding module will be opended. If
that fails and file_name doesn't have the ".la"-suffix, this suffix is
appended and g_module_open() tries to open the corresponding module. If
eventually that fails as well, NULL is returned.
file_name :
the name of the file containing the module, or NULL to obtain
a GModule representing the main program itself.
flags :
the flags used for opening the module.
This can be the logical OR of any of the GModuleFlags.
Returns :
a GModule on success, or NULL on failure.
text: end
outFile: Module

file: glib-Memory-Allocation.html
class: Memory
prefix: g_
#import: glib.MemVTable
#structWrap: GMemVTable* MemVTable
outFile: Memory

file: glib-IO-Channels.html
struct: GIOChannel
class: IOChannel
prefix: g_io_channel_
import: glib.ErrorG
import: glib.GException
import: glib.StringG
import: glib.Source
import: glib.Str
import: gtkc.paths;
import: gtkc.Loader;
structWrap: GString* StringG
structWrap: GSource* Source
structWrap: GIOChannel* IOChannel

out: g_io_channel_read_chars bytes_read
out: g_io_channel_read_unichar thechar
out: g_io_channel_read_line_string terminator_pos
out: g_io_channel_write_chars bytes_written
out: g_io_channel_get_line_term length
out: g_io_channel_read bytes_read
out: g_io_channel_write bytes_written

nocode: g_io_channel_read_line
nocode: g_io_channel_read_to_end

code: start
	~this()
	{
		if ( importLibs[LIBRARY.GLIB] in Linker.loadedLibraries )
		{
			unref();
		}
	}

	/**
	 * Reads a line, including the terminating character(s),
	 * from a GIOChannel into a newly-allocated string.
	 * str_return will contain allocated memory if the return
	 * is G_IO_STATUS_NORMAL.
	 * Params:
	 * strReturn =  The line read from the GIOChannel, including the
	 *  line terminator. This data should be freed with g_free()
	 *  when no longer needed. This is a nul-terminated string.
	 *  If a length of zero is returned, this will be NULL instead.
	 * terminatorPos =  location to store position of line terminator, or NULL
	 * Returns: the status of the operation.
	 * Throws: GException on failure.
	 */
	public GIOStatus readLine(out string strReturn, out gsize terminatorPos)
	{
		// GIOStatus g_io_channel_read_line (GIOChannel *channel,  gchar **str_return,  gsize *length,  gsize *terminator_pos,  GError **error);
		GError* err = null;
		char* str = null;
		gsize len;
		
		auto p = g_io_channel_read_line(gIOChannel, &str, &len, &terminatorPos, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}

		if ( str !is null )
		{
			version(D_Version2)
				strReturn = str[0 .. len-1].idup;
			else
				strReturn = str[0 .. len-1];
		}
		
		return p;
	}

	/**
	 * Reads all the remaining data from the file.
	 * Params:
	 * strReturn =  Location to store a pointer to a string holding
	 *  the remaining data in the GIOChannel. This data should
	 *  be freed with g_free() when no longer needed. This
	 *  data is terminated by an extra nul character, but there
	 *  may be other nuls in the intervening data.
	 * Returns: G_IO_STATUS_NORMAL on success.  This function never returns G_IO_STATUS_EOF.
	 * Throws: GException on failure.
	 */
	public GIOStatus readToEnd(out string strReturn)
	{
		// GIOStatus g_io_channel_read_to_end (GIOChannel *channel,  gchar **str_return,  gsize *length,  GError **error);
		GError* err = null;
		char* str = null;
		gsize len;

		auto p = g_io_channel_read_to_end(gIOChannel, &str, &len, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}

	
		if ( str !is null )
		{
			version(D_Version2)
				strReturn = str[0 .. len-1].idup;
			else
				strReturn = str[0 .. len-1];
		}

		return p;
	}
code: end
outFile: IOChannel


file: glib-Error-Reporting.html
struct: GError
class: ErrorG
prefix: g_error_
import: glib.Str
structWrap: GError* ErrorG

out: g_propagate_error dest
inout: g_clear_error err
out: g_set_error_literal err

outFile: ErrorG

file:
import: glib.Str
import: glib.ErrorG
import: glib.GException
code: start

class GException : Exception
{
	ErrorG error;

	this(ErrorG error)
	{
		super( Str.toString(error.getErrorGStruct.message) );
		this.error = error;
	}
}

code: end
outFile: GException

file:
code: start

class ConstructionException : Exception
{
	this(string message)
	{
		super(message);
	}

	override string toString()
	{
		return "Construction failure, " ~ msg;
	}
}

code: end
outFile: ConstructionException

file: glib-Warnings-and-Assertions.html
class: Messages
prefix: g_
import: glib.Str
outFile: Messages

file: glib-Message-Logging.html
class: MessageLog
prefix: g_
import: glib.Str
outFile: MessageLog


###########################################################
### GLib Utilities ########################################
###########################################################

file: glib-String-Utility-Functions.html
class: Str
import: std.c.stdio
import: glib.StringG
structWrap: GString* StringG
import: std.c.string
prefix: g_

array: g_strdupv str_array
out: g_vasprintf string
out: g_ascii_strtoll endptr
out: g_ascii_strtoll endptr
out: g_ascii_strtoull endptr
out: g_ascii_strtod endptr
out: g_strtod endptr
array: g_strfreev str_array
array: g_strjoinv str_array
array: g_strv_length str_array

code: start
	const static char[10] digits    = "0123456789";			/// 0..9
	
	/*************************************************
	 * Convert C-style 0 terminated string s to char[] string.
	 * copied from phobos
	 */
	public static string toString(char *s, size_t len = 0)
	{
		if ( s is null )
			return cast(string)null;

		if ( len == 0 )
			len = strlen(s);
		
		version(D_Version2)
			return s[0 .. len].idup;
		else
			return s[0 .. len].dup;
	}
	
	/*********************************
	 * Convert array of chars s[] to a C-style 0 terminated string.
	 * copied from phobos
	 */
	public static char* toStringz(string s)
	in
	{
	}
	out (result)
	{
	//	if (result)
	//	{
	//		// TODO this one fails in some case???
	//		assert(strlen(result) == s.length);
	//		assert(memcmp(result, s, s.length) == 0);
	//	}
	}
	body
	{
		if ( s is null ) return null;
		char[] copy;
		
		if (s.length == 0)
		{
			copy = "\0".dup;
		}
		else
		{
			// Need to make a copy
			copy = new char[s.length + 1];
			copy[0..s.length] = s.dup;
			copy[s.length] = 0;
		}
		
		return copy.ptr;
	}
	
	/** */
	public static char** toStringzArray(string[] args)
	{
		if ( args is null )
		{
			return null;
		}
		char** argv = (new char*[args.length]).ptr;
		int argc = 0;
		foreach (string p; args)
		{
			argv[argc++] = cast(char*)(p.dup~'\0');
		}
		argv[argc] = null;
		
		return argv;
	}
	
	/** */
	public static string[] toStringArray(char** args)
	{
		if ( args is null )
		{
			return null;
		}
		string[] argv;
		
		char* arg = args[0];
		int i=0;
		while( (arg) != null && i<10)
		{
			argv ~= toString(arg);
			++i;
			arg = args[i];
		}
		
		return argv;
	}
	
	/** */
	public static string toString(bool b)
	{
		return b ? "true" : "false";
	}
	
	/** */
	public static char[] toString(char c)
	{
		char[] result = new char[2];
		result[0] = c;
		result[1] = 0;
		return result[0 .. 1];
	}
	
	/** */
	public static string toString(ubyte ub)  { return toString(cast(uint) ub); } /// ditto
	/** */
	public static string toString(ushort us) { return toString(cast(uint) us); } /// ditto
	
	/** */
	public static string toString(uint u)
	{
		char[uint.sizeof * 3] buffer = void;
		int ndigits;
		char c;
		string result;
		
		ndigits = 0;
		if (u < 10)
		{
			version(D_Version2)
				result = digits[u .. u + 1].idup;
			else
				// Avoid storage allocation for simple stuff
				result = digits[u .. u + 1];
		}
		else
		{
			while (u)
			{
				c = cast(char)((u % 10) + '0');
				u /= 10;
				ndigits++;
				buffer[buffer.length - ndigits] = c;
			}

			version(D_Version2)
			{
				//result = new char[ndigits];
				result = buffer[buffer.length - ndigits .. buffer.length].idup;
			}
			else
			{
				result = new char[ndigits];
				result[] = buffer[buffer.length - ndigits .. buffer.length];
			}
		}
		return result;
	}
	
	/** */
	public static string toString(ulong u)
	{
		char[ulong.sizeof * 3] buffer;
		int ndigits;
		char c;
		string result;
		
		if (u < 0x1_0000_0000)
			return toString(cast(uint)u);
		
		ndigits = 0;
		while (u)
		{
			c = cast(char)((u % 10) + '0');
			u /= 10;
			ndigits++;
			buffer[buffer.length - ndigits] = c;
		}

		version(D_Version2)
		{
			//result = new char[ndigits];
			result = buffer[buffer.length - ndigits .. buffer.length].idup;
		}
		else
		{
			result = new char[ndigits];
			result[] = buffer[buffer.length - ndigits .. buffer.length];
		}
		return result;
	}
	
	/** */
	public static string toString(byte b)  { return toString(cast(int) b); } /// ditto
	/** */
	public static string toString(short s) { return toString(cast(int) s); } /// ditto
	
	/** */
	public static string toString(int i)
	{
		char[1 + int.sizeof * 3] buffer;
		char c;
		string result;
		
		if (i >= 0)
			return toString(cast(uint)i);
		
		uint u = -i;
		int ndigits = 1;
		while (u)
		{
			c = cast(char)((u % 10) + '0');
			u /= 10;
			buffer[buffer.length - ndigits] = c;
			ndigits++;
		}
		buffer[buffer.length - ndigits] = '-';

		version(D_Version2)
		{
			//result = new char[ndigits];
			result = buffer[buffer.length - ndigits .. buffer.length].idup;
		}
		else
		{
			result = new char[ndigits];
			result[] = buffer[buffer.length - ndigits .. buffer.length];
		}
		return result;
	}
code: end


outFile: Str

file: glib-Character-Set-Conversion.html
class: CharacterSet
prefix: g_
import: glib.Str
import: glib.ErrorG
import: glib.GException
# these fail to compile because of a reference to a struct that size is not known
noprefix: g_convert_with_iconv
noprefix: g_iconv_open
noprefix: g_iconv
noprefix: g_iconv_close

out: g_convert bytes_read
out: g_convert bytes_written
out: g_convert_with_fallback bytes_read
out: g_convert_with_fallback bytes_written
out: g_locale_to_utf8 bytes_read
out: g_locale_to_utf8 bytes_written
out: g_filename_to_utf8 bytes_read
out: g_filename_to_utf8 bytes_written
out: g_filename_from_utf8 bytes_read
out: g_filename_from_utf8 bytes_written
out: g_locale_from_utf8 bytes_read
out: g_locale_from_utf8 bytes_written
out: g_filename_from_uri hostname
out: g_get_charset charset
out: g_get_filename_charsets charsets
array: g_get_filename_charsets charsets

outFile: CharacterSet

file: glib-Unicode-Manipulation.html
class: Unicode
prefix: g_
import: glib.Str
import: glib.ErrorG
import: glib.GException

out: g_unicode_canonical_decomposition result_len
out: g_utf8_validate end
out: g_utf8_to_utf16 items_read
out: g_utf8_to_utf16 items_written
out: g_utf8_to_ucs4 items_read
out: g_utf8_to_ucs4 items_written
out: g_utf8_to_ucs4_fast items_written
out: g_utf16_to_ucs4 items_read
out: g_utf16_to_ucs4 items_written
out: g_utf16_to_utf8 items_read
out: g_utf16_to_utf8 items_written
out: g_ucs4_to_utf16 items_read
out: g_ucs4_to_utf16 items_written
out: g_ucs4_to_utf8 items_read
out: g_ucs4_to_utf8 items_written

outFile: Unicode

file: glib-Base64-Encoding.html
class: Base64
prefix: g_base64_
import: glib.Str

inout: g_base64_encode_step state
inout: g_base64_encode_step save
inout: g_base64_encode_close state
inout: g_base64_encode_close save
inout: g_base64_decode_step state
inout: g_base64_decode_step save
array: g_base64_decode Return out_len
array: g_base64_decode_inplace Return out_len

outFile: Base64

file: glib-Data-Checksums.html
struct: GChecksum
class: Checksum
prefix: g_checksum_
import: glib.Str
structWrap: GChecksum* Checksum
outFile: Checksum

file: glib-I18N.html
class: Internationalization
prefix: g_
import: glib.Str
outFile: Internationalization

file: glib-Date-and-Time-Functions.html
struct: GTimeVal
class: TimeVal
prefix: g_time_val_
prefix: g_
noprefix: g_date_
import: glib.Str
outFile: TimeVal

struct: GDate
class: Date
prefix: g_date_
strictPrefix: Y
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
import: glib.Str
structWrap: GDate* Date
outFile: Date

file: glib-GTimeZone.html
struct: GTimeZone
class: TimeZone
prefix: g_time_zone_
import: glib.Str
structWrap: GTimeZone* TimeZone
nocode: g_time_zone_new_local
nocode: g_time_zone_new_utc
inout: g_time_zone_adjust_time time
outFile: TimeZone

file: glib-GDateTime.html
struct: GDateTime
class: DateTime
prefix: g_date_time_
import: glib.Str
import: glib.TimeZone
import: glib.TimeVal
structWrap: GDateTime* DateTime
structWrap: GTimeZone* TimeZone
structWrap: GTimeVal* TimeVal
structWrap: gconstpointer DateTime

nocode: g_date_time_new_now_utc
nocode: g_date_time_new_now_local
nocode: g_date_time_new_from_unix_local
nocode: g_date_time_new_from_unix_utc
nocode: g_date_time_new_from_timeval_local
nocode: g_date_time_new_from_timeval_utc
nocode: g_date_time_new_local
nocode: g_date_time_new_utc
nocode: g_date_time_hash

code: start
	/**
	 * Creates a GDateTime corresponding to the given Unix time t
	 * Unix time is the number of seconds that have elapsed since 1970-01-01
	 * 00:00:00 UTC, regardless of the local time offset.
	 * 
	 * This call can fail (returning NULL) if t represents a time outside
	 * of the supported range of GDateTime.
	 * You should release the return value by calling g_date_time_unref()
	 * when you are done with it.
	 * Since 2.26
	 * 
	 * Params:
	 *     t   = the Unix time
	 *     utc = If true use utc else use the local timezone.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (long t, bool utc = true)
	{
		// GDateTime * g_date_time_new_from_unix_local (gint64 t);
		GDateTime* p;

		if ( utc )
		{
			p = g_date_time_new_from_unix_utc(t);
		}
		else
		{
			p = g_date_time_new_from_unix_local(t);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by g_date_time_new_from_unix_local(t)");
		}
		this(cast(GDateTime*) p);
	}

	/**
	 * Creates a GDateTime corresponding to the given GTimeVal tv.
	 * The time contained in a GTimeVal is always stored in the form of
	 * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
	 * local time offset.
	 * 
	 * This call can fail (returning NULL) if tv represents a time outside
	 * of the supported range of GDateTime.
	 * You should release the return value by calling unref()
	 * when you are done with it.
	 * Since 2.26
	 * 
	 * Params:
	 *     tv  = a GTimeVal
	 *     utc = If true use utc else use the local timezone.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (TimeVal tv, bool utc = true)
	{
		// GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
		GDateTime* p;

		if ( utc )
		{
			p = g_date_time_new_from_timeval_utc((tv is null) ? null : tv.getTimeValStruct());
		}
		else
		{
			p = g_date_time_new_from_timeval_local((tv is null) ? null : tv.getTimeValStruct());
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by g_date_time_new_from_timeval_local((tv is null) ? null : tv.getTimeValStruct())");
		}
		this(cast(GDateTime*) p);
	}

	version(D_Version2)
	{
		override bool opEquals(Object rhs)
		{
			DateTime date = cast(DateTime)rhs;

			if ( date is null )
				return false;

			return equal(this, date) != 0;
		}
	}
	else
	{
		override int opEquals(Object rhs)
		{
			DateTime date = cast(DateTime)rhs;

			if ( date is null )
				return false;

			return equal(this, date);
		}
	}

	override int opCmp(Object rhs)
	{
		DateTime date = cast(DateTime)rhs;

		if ( date is null )
			return int.min;

		return compare(this, date);
	}

	override hash_t toHash()
	{
		return hash(this);
	}

	version(D_Version2)
	{
		/**
		 * Hashes datetime into a guint, suitable for use within GHashTable.
		 * Since 2.26
		 * Params:
		 * datetime = a GDateTime
		 * Returns: a guint containing the hash
		 */
		mixin("public static nothrow @trusted uint hash(DateTime datetime)
		{
			try
			{
				// guint g_date_time_hash (gconstpointer datetime);
				return g_date_time_hash((datetime is null) ? null : datetime.getDateTimeStruct());
			}
			catch
			{
				return 0;
			}
		}");
	}
	else
	{
		/**
		 * Hashes datetime into a guint, suitable for use within GHashTable.
		 * Since 2.26
		 * Params:
		 * datetime = a GDateTime
		 * Returns: a guint containing the hash
		 */
		public static uint hash(DateTime datetime)
		{
			// guint g_date_time_hash (gconstpointer datetime);
			return g_date_time_hash((datetime is null) ? null : datetime.getDateTimeStruct());
		}
	}
code: end
outFile: DateTime

file: glib-Random-Numbers.html
struct: GRand
class: RandG
prefix: g_rand_
prefix: g_

array: g_rand_set_seed_array seed seed_length
array: g_rand_new_with_seed_array seed seed_length

structWrap: GRand* RandG

alias: int randInt
alias: intRange randIntRange
alias: double randDouble
alias: doubleRange randDoubleRange

outFile: RandG

#file: glib-Hook-Functions.html
#class: Hook
#prefix: g_hook_
##import: glib.HookList
##structWrap: GHookList* HookList
##import: glib.Hook
#structWrap: GHook* Hook
#outFile: Hook

file: glib-Miscellaneous-Utility-Functions.html
class: Util
import: glib.ListG
structWrap: GList* ListG
prefix: g_
#import: glib.DebugKey
#structWrap: GDebugKey* DebugKey
import: glib.Str
code: start
	/**
	 * Creates a filename from a series of elements using the correct
	 * separator for filenames.
	 * On Unix, this function behaves identically to g_build_path
	 * (G_DIR_SEPARATOR_S, first_element, ....).
	 * On Windows, it takes into account that either the backslash
	 * (\ or slash (/) can be used
	 * as separator in filenames, but otherwise behaves as on Unix. When
	 * file pathname separators need to be inserted, the one that last
	 * previously occurred in the parameters (reading from left to right)
	 * is used.
	 * No attempt is made to force the resulting filename to be an absolute
	 * path. If the first element is a relative path, the result will
	 * be a relative path.
	 * Params:
	 * firstElement =  the first element in the path
	 * ... =  remaining elements in path, terminated by NULL
	 * Returns: a newly-allocated string that must be freed with g_free().
	 */
	public static string buildFilename(string[] firstElement ... )
	{
		// gchar* g_build_filename (const gchar *first_element,  ...);
		return buildFilenamev(Str.toStringzArray(firstElement));
	}

	/**
	 * Creates a path from a series of elements using separator as the
	 * separator between elements. At the boundary between two elements,
	 * any trailing occurrences of separator in the first element, or
	 * leading occurrences of separator in the second element are removed
	 * and exactly one copy of the separator is inserted.
	 * Empty elements are ignored.
	 * The number of leading copies of the separator on the result is
	 * the same as the number of leading copies of the separator on
	 * the first non-empty element.
	 * The number of trailing copies of the separator on the result is
	 * the same as the number of trailing copies of the separator on
	 * the last non-empty element. (Determination of the number of
	 * trailing copies is done without stripping leading copies, so
	 * if the separator is ABA, ABABA
	 * has 1 trailing copy.)
	 * However, if there is only a single non-empty element, and there
	 * are no characters in that element not part of the leading or
	 * trailing separators, then the result is exactly the original value
	 * of that element.
	 * Other than for determination of the number of leading and trailing
	 * copies of the separator, elements consisting only of copies
	 * of the separator are ignored.
	 * Params:
	 * separator =  a string used to separator the elements of the path.
	 * firstElement =  the first element in the path
	 * ... =  remaining elements in path, terminated by NULL
	 * Returns: a newly-allocated string that must be freed with g_free().
	 */
	public static string buildPath(string separator, string[] firstElement ... )
	{
		// gchar* g_build_path (const gchar *separator,  const gchar *first_element,  ...);
		return buildPathv(separator, Str.toStringzArray(firstElement));
	}
code: end
outFile: Util

file: glib-Lexical-Scanner.html
struct: GScanner
class: ScannerG
prefix: g_scanner_
structWrap: GScanner* ScannerG
#import: glib.ScannerConfig
#structWrap: GScannerConfig* ScannerConfig
import: glib.Str
outFile: ScannerG

file: glib-Automatic-String-Completion.html
struct: GCompletion
class: StringCompletion
import: glib.ListG
structWrap: GList* ListG
prefix:g_completion_
import: glib.Str

out: g_completion_complete new_prefix
out: g_completion_complete_utf8 new_prefix

outFile: StringCompletion

file: glib-Timers.html
struct: GTimer
class: Timer
prefix: g_timer_
structWrap: GTimer* Timer

out: g_timer_elapsed microseconds

outFile: Timer

file: glib-Spawning-Processes.html
class: Spawn
import: glib.ErrorG
import: glib.GException
import: glib.MainLoop
structWrap: GMainLoop* MainLoop
prefix: g_spawn_
#import: glib.Pid
#structWrap: GPid* Pid
#import: glib.Error*
import: glib.Str
import: std.thread
import: std.c.stdio
import: std.string
import: std.c.string

array: g_spawn_async argv
array: g_spawn_async envp
array: g_spawn_sync argv
array: g_spawn_sync envp
out: g_spawn_sync standard_output
out: g_spawn_sync standard_error
out: g_spawn_sync exit_status
out: g_spawn_command_line_sync standard_output
out: g_spawn_command_line_sync standard_error
out: g_spawn_command_line_sync exit_status

nocode: g_spawn_async_with_pipes

code: start
	//we need fdopen.
	version(Posix)
	{
		version(Tango)
		{
			private import tango.stdc.posix.stdio;
		}
		else version(D_Version2)
		{
			private import core.sys.posix.stdio;
		}
	}
	//fdopen for Windows is defined in gtkc.glibtypes.

	version(Tango) alias splitLines splitlines;
	version(D_Version2) alias splitLines splitlines;

	string workingDirectory = ".";
	string[] argv;
	string[] envp;
	GSpawnFlags flags = SpawnFlags.SEARCH_PATH;
	GSpawnChildSetupFunc childSetup;
	void* userData;
	GPid childPid;
	FILE* standardInput;
	FILE* standardOutput;
	FILE* standardError;
	GError* error;
	int stdIn;
	int stdOut;
	int stdErr;
	
	// for commandLineSync
	int exitStatus;
	char* strOutput;
	char* strError;
	
	alias bool delegate(Spawn) ChildWatch;
	ChildWatch externalWatch;
	
	/**
	 * Creates a Spawn for execution.
	 */
	public this(string program, string[] envp=null)
	{
		argv ~= program;
		this.envp = envp;
	}
	
	/**
	 * Creates a Spawn for execution.
	 */
	public this(string[] program, string[] envp=null)
	{
		argv = program;
		this.envp = envp;
	}
	
	/**
	 * Adds a delegate to be notified on the end of the child process.
	 * Params:
	 *    	dlg =
	 */
	public void addChildWatch(ChildWatch dlg)
	{
		externalWatch = dlg;
	}
	
	/**
	 * Closes all open streams and child process.
	 */
	public void close()
	{
		if (stdIn != 0 )
		{
			fclose(standardInput);
			stdIn = 0;
		}
		if (stdOut != 0 )
		{
			fclose(standardOutput);
			stdOut = 0;
		}
		if (stdErr != 0 )
		{
			fclose(standardError);
			stdErr = 0;
		}
		if ( childPid != 0 )
		{
			closePid(childPid);
			childPid = 0;
		}
	}
	
	/**
	 * Adds a parameter to the execution program
	 */
	public void addParm(string parm)
	{
		argv ~= parm;
	}
	
	/**
	 * Gets the last error message
	 */
	public string getLastError()
	{
		if ( error != null )
		{
			return Str.toString(error.message);
		}
		return "";
	}
	
	/**
	 * Executes the prepared process
	 */
	public int execAsyncWithPipes(
		ChildWatch externalWatch = null,
		bool delegate(string) readOutput = null,
		bool delegate(string) readError = null )
	{
		int result = g_spawn_async_with_pipes(
		Str.toStringz(workingDirectory),
		Str.toStringzArray(argv),
		Str.toStringzArray(envp),
		flags,
		childSetup,
		userData,
		&childPid,
		&stdIn,
		&stdOut,
		&stdErr,
		&error
		);
		
		if ( result != 0 )
		{
			this.externalWatch = externalWatch;
			g_child_watch_add(childPid, cast(GChildWatchFunc)(&childWatchCallback), cast(void*)this);
			standardInput = fdopen(stdIn, Str.toStringz("w"));
			standardOutput = fdopen(stdOut, Str.toStringz("r"));
			standardError = fdopen(stdErr, Str.toStringz("r"));
			
			if ( readOutput !is null )
			{
				(new ReadFile(standardOutput, readOutput)).start();
			}
			if ( readError !is null )
			{
				(new ReadFile(standardError, readError)).start();
			}
		}
		
		return result;
	}
	
	class ReadFile : Thread
	{
		bool delegate(string) read;
		FILE* file;
		
		int lineCount;
		
		this(FILE* file, bool delegate (string) read )
		{
			this.file = file;
			this.read = read;

			version(druntime)
			{
				super(&run);
			}
		}
		
		version(druntime)
		{
			public void run()
			{
				string line = readLine(file);
				while( line !is null )
				{
					++lineCount;
					if ( read !is null )
					{
						read(line);
					}
					line = readLine(file);
				}
			}
		}
		else
		{
			public override int run()
			{
				string line = readLine(file);
				while( line !is null )
				{
					++lineCount;
					//writefln("Spawn.ReadFile.run line (%s) ========== >>>%s<<<", lineCount, line);
					//printf("Spawn.ReadFile.run line (%d) ========== >>>%.*s<<<", lineCount, line);
					if ( read !is null )
					{
						read(line);
					}
					line = readLine(file);
				}
				return 0;
			}
		}
	}
	
	private string readLine(FILE* stream, int max=4096)
	{
		if ( feof(stream) )
		{
			if ( externalWatch !is null )
			{
				externalWatch(this);
			}
			return null;
		}
		string line;
		line.length = max+1;
		char* lineP = fgets(Str.toStringz(line), max, stream);
		if ( lineP is null )
		{
			return "";
		}
		size_t l = strlen(line.ptr);
		if ( l > 0 ) --l;
		//printf("\nreadLine\n");
		//foreach ( char c ; line )
		//{
		//       printf("%c", c);
		//}
		//printf("\n\n");
		return line[0..l];
	}
	
	extern(C) static void childWatchCallback(int pid, int status, Spawn spawn)
	{
		//writefln("Spawn.childWatchCallback %s %s", pid, status);
		spawn.exitStatus = status;
		if ( spawn.externalWatch !is null )
		{
			spawn.externalWatch(spawn);
		}
		spawn.close();
	}
	
	
	public bool endOfOutput()
	{
		if ( standardOutput is null ) return true;
		return feof(standardOutput) != 0;
	}
	
	public bool endOfError()
	{
		if ( standardError is null ) return true;
		return feof(standardError) != 0;
	}
	
	string getOutputString()
	{
		return Str.toString(strOutput);
	}
	
	string getErrorString()
	{
		return Str.toString(strError);
	}
	
	int getExitStatus()
	{
		return exitStatus;
	}
	
	/**
	 * Executes a command synchronasly and
	 * optionally calls delegates for sysout, syserr and end of job
	 *
	 */
	public int commandLineSync(
		ChildWatch externalWatch = null,
		bool delegate(string) readOutput = null,
		bool delegate(string) readError = null )
	{
		string commandLine;
		foreach ( int count, string arg; argv)
		{
			if ( count > 0 )
			{
				commandLine ~= ' ';
			}
			commandLine ~= arg;
		}
		int status = g_spawn_command_line_sync(
			Str.toStringz(commandLine),
			&strOutput,
			&strError,
			&exitStatus,
			&error);
		if ( readOutput != null )
		{
			foreach ( string line ; splitlines(Str.toString(strOutput)) )
			{
				readOutput(line);
			}
		}
		if ( readError != null )
		{
			foreach ( string line ; splitlines(Str.toString(strError)) )
			{
				readError(line);
			}
		}
		if ( externalWatch != null )
		{
			externalWatch(this);
		}
		return status;
	}
code: end

outFile: Spawn

file: glib-File-Utilities.html
class: FileUtils
prefix: g_
noprefix: g_dir_
noprefix: g_mapped_file_
import: std.c.stdio
import: glib.Str
import: glib.ErrorG
import: glib.GException

out: g_file_get_contents contents
out: g_file_get_contents length
out: g_file_open_tmp name_used
outFile: FileUtils

struct: GDir
class: Directory
prefix: g_dir_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GDir* Directory
outFile: Directory

struct: GMappedFile
class: MappedFile
prefix: g_mapped_file_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GMappedFile* MappedFile
outFile: MappedFile

file: glib-URI-Functions.html
class: URI
prefix: g_uri_
import: glib.Str
import: glib.ErrorG
import: glib.GException
outFile: URI

file: glib-Hostname-Utilities.html
class: Hostname
prefix: g_hostname_
import: glib.Str
outFile: Hostname

file: glib-Shell-related-Utilities.html
class: ShellUtils
prefix: g_shell_
import: glib.Str
import: glib.ErrorG
import: glib.GException

nocode: g_shell_parse_argv

code: start
	/**
	 * Parses a command line into an argument vector, in much the same way
	 * the shell would, but without many of the expansions the shell would
	 * perform (variable expansion, globs, operators, filename expansion,
	 * etc. are not supported). The results are defined to be the same as
	 * those you would get from a UNIX98 /bin/sh, as long as the input
	 * contains none of the unsupported shell expansions. If the input
	 * does contain such expansions, they are passed through
	 * literally. Possible errors are those from the G_SHELL_ERROR
	 * domain. Free the returned vector with g_strfreev().
	 * Params:
	 * commandLine =  command line to parse
	 * argcp =  return location for number of args
	 * argvp =  return location for array of args
	 * Returns: TRUE on success, FALSE if error set
	 * Throws: GException on failure.
	 */
	public static int parseArgv(string commandLine, out int argcp, out string[] argvp)
	{
		// gboolean g_shell_parse_argv (const gchar *command_line,  gint *argcp,  gchar ***argvp,  GError **error);
		GError* err = null;
		char** arg = null;
		
		auto p = g_shell_parse_argv(Str.toStringz(commandLine), &argcp, &arg, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}

		argvp = Str.toStringArray(arg);		
		return p;
	}
code: end
outFile: ShellUtils

file: glib-Commandline-option-parser.html

struct: GOptionContext
class: OptionContext
prefix: g_option_context_
noprefix: g_option_group_
import: glib.ErrorG
import: glib.GException
#import: glib.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.OptionGroup
structWrap: GOptionGroup* OptionGroup
import: glib.Str

nocode: g_option_context_parse

code: start
	/**
	 * Parses the command line arguments, recognizing options
	 * which have been added to context. A side-effect of
	 * calling this function is that g_set_prgname() will be
	 * called.
	 * If the parsing is successful, any parsed arguments are
	 * removed from the array and argc and argv are updated
	 * accordingly. A '--' option is stripped from argv
	 * unless there are unparsed options before and after it,
	 * or some of the options after it start with '-'. In case
	 * of an error, argc and argv are left unmodified.
	 * If automatic --help support is enabled
	 * (see g_option_context_set_help_enabled()), and the
	 * argv array contains one of the recognized help options,
	 * this function will produce help output to stdout and
	 * call exit (0).
	 * Note that function depends on the
	 * current locale for
	 * automatic character set conversion of string and filename
	 * arguments.
	 * Since 2.6
	 * Params:
	 * argc =  a pointer to the number of command line arguments
	 * argv =  a pointer to the array of command line arguments
	 * Returns: TRUE if the parsing was successful,  FALSE if an error occurred
	 * Throws: GException on failure.
	 */
	public int parse(out int argc, out string[] argv)
	{
		// gboolean g_option_context_parse (GOptionContext *context,  gint *argc,  gchar ***argv,  GError **error);
		GError* err = null;
		char** arg = null;

		auto p = g_option_context_parse(gOptionContext, &argc, &arg, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}

		argv = Str.toStringArray(arg);
		return p;
	}
code: end
outFile: OptionContext

struct: GOptionGroup
class: OptionGroup
prefix: g_option_group_
strictPrefix: Yes
#import: glib.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.Str
outFile: OptionGroup

file: glib-Glob-style-pattern-matching.html
struct: GPatternSpec
class: Pattern
prefix: g_pattern_spec_
prefix: g_pattern_
structWrap: GPatternSpec* Pattern
import: glib.Str
outFile: Pattern

file: glib-Perl-compatible-regular-expressions.html
struct: GRegex
class: Regex
prefix: g_regex_
noprefix: g_match_info_
import: glib.Str
structWrap: GRegex* Regex
import: glib.ErrorG
import: glib.GException
import: glib.MatchInfo
structWrap: GMatchInfo* MatchInfo

out: g_regex_match match_info
out: g_regex_match_full match_info
out: g_regex_match_all match_info
out: g_regex_match_all_full match_info
out: g_regex_check_replacement has_references

outFile: Regex

struct: GMatchInfo
class: MatchInfo
prefix: g_match_info_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Regex
structWrap: GRegex* Regex

out: g_match_info_fetch_pos start_pos
out: g_match_info_fetch_pos end_pos
out: g_match_info_fetch_named_pos start_pos
out: g_match_info_fetch_named_pos end_pos

outFile: MatchInfo

file: glib-Simple-XML-Subset-Parser.html
struct: GMarkupParseContext
class: SimpleXML
prefix: g_markup_parse_context_
prefix: g_markup_
import: glib.ListSG
structWrap: GSList* ListSG
import: glib.ErrorG
import: glib.GException
#import: glib.MarkupParser
#structWrap: GMarkupParser* MarkupParser
import: glib.Str

out: g_markup_parse_context_get_position line_number
out: g_markup_parse_context_get_position char_number

outFile: SimpleXML

file: glib-Key-value-file-parser.html
struct: GKeyFile
class: KeyFile
prefix: g_key_file_
import: glib.ErrorG
import: glib.GException
import: glib.Str

out: g_key_file_load_from_data_dirs full_path
out: g_key_file_to_data length
out: g_key_file_get_groups length
out: g_key_file_get_keys length
out: g_key_file_get_string_list length
out: g_key_file_get_locale_string_list length
out: g_key_file_get_boolean_list length
out: g_key_file_get_integer_list length
out: g_key_file_get_double_list length
array: g_key_file_get_boolean_list Return length
array: g_key_file_get_integer_list Return length
array: g_key_file_get_double_list Return length
array: g_key_file_set_string_list list length
array: g_key_file_set_locale_string_list list length
array: g_key_file_set_boolean_list list length
array: g_key_file_set_integer_list list length
array: g_key_file_set_double_list list length

nocode: g_key_file_load_from_dirs

code: start
	/**
	 * This function looks for a key file named file in the paths
	 * specified in search_dirs, loads the file into key_file and
	 * returns the file's full path in full_path. If the file could not
	 * be loaded then an error is set to either a GFileError or
	 * GKeyFileError.
	 * Since 2.14
	 * Params:
	 * file =  a relative path to a filename to open and parse
	 * searchDirs =  NULL-terminated array of directories to search
	 * fullPath =  return location for a string containing the full path
	 *  of the file, or NULL
	 * flags =  flags from GKeyFileFlags
	 * Returns: TRUE if a key file could be loaded, FALSE otherwise
	 * Throws: GException on failure.
	 */
	public int loadFromDirs(string file, string[] searchDirs, out string fullPath, GKeyFileFlags flags)
	{
		// gboolean g_key_file_load_from_dirs (GKeyFile *key_file,  const gchar *file,  const gchar **search_dirs,  gchar **full_path,  GKeyFileFlags flags,  GError **error);
		char* outStr = null;
		GError* err = null;
		
		auto p = g_key_file_load_from_dirs(gKeyFile, Str.toStringz(file), Str.toStringzArray(searchDirs), &outStr, flags, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		fullPath = Str.toString(outStr);
		return p;
	}
code: end
outFile: KeyFile

file: glib-Bookmark-file-parser.html
struct: GBookmarkFile
class: BookmarkFile
prefix: g_bookmark_file_
import: glib.ErrorG
import: glib.GException
import: glib.Str

out: g_bookmark_file_load_from_data_dirs full_path 
out: g_bookmark_file_to_data length
out: g_bookmark_file_get_uris length
out: g_bookmark_file_get_icon href
out: g_bookmark_file_get_icon mime_type
out: g_bookmark_file_get_groups length
out: g_bookmark_file_get_applications length
out: g_bookmark_file_get_app_info exec
out: g_bookmark_file_get_app_info count
out: g_bookmark_file_get_app_info stamp

nocode: g_bookmark_file_set_groups

code: start
	/**
	 * Sets a list of group names for the item with URI uri. Each previously
	 * set group name list is removed.
	 * If uri cannot be found then an item for it is created.
	 * Since 2.12
	 * Params:
	 * uri =  an item's URI
	 * groups =  an array of group names, or NULL to remove all groups
	 * length =  number of group name values in groups
	 */
	public void setGroups(string uri, string[] groups, uint length)
	{
		// void g_bookmark_file_set_groups (GBookmarkFile *bookmark,  const gchar *uri,  const gchar **groups,  gsize length);
		g_bookmark_file_set_groups(gBookmarkFile, Str.toStringz(uri), Str.toStringzArray(groups), length);
	}
code: end
outFile: BookmarkFile

file: glib-Windows-Compatibility-Functions.html
class: WindowsUtils
prefix: g_win32_
import: glib.Str
outFile: WindowsUtils


###########################################################
### GLib Data Types #######################################
###########################################################

file: glib-Memory-Slices.html
class: MemorySlice
prefix: g_slice_
outFile: MemorySlice

file: glib-Memory-Chunks.html
struct: GMemChunk
class: MemoryChunk
prefix: g_mem_chunk_
prefix: g_
import: glib.Str

nocode: g_mem_chunk_print

code: start
	/**
	 * Warning
	 * g_mem_chunk_print has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice
	 *  allocator instead
	 * Outputs debugging information for a GMemChunk.
	 * It outputs the name of the GMemChunk (set with g_mem_chunk_new()),
	 * the number of bytes used, and the number of blocks of memory allocated.
	 */
	version(Tango)
	{
		public void print()
		{
			// void g_mem_chunk_print (GMemChunk *mem_chunk);
			g_mem_chunk_print(gMemChunk);
		}
	}
	else version(D_Version2)
	{
		public void print()
		{
			// void g_mem_chunk_print (GMemChunk *mem_chunk);
			g_mem_chunk_print(gMemChunk);
		}
	}
	else
	{
		public override void print()
		{
			// void g_mem_chunk_print (GMemChunk *mem_chunk);
			g_mem_chunk_print(gMemChunk);
		}
	}
code: end
outFile: MemoryChunk

file: glib-Doubly-Linked-Lists.html
struct: GList
class: ListG
prefix: g_list_
structWrap: GList* ListG

code: start
  	/** */ 
	void* data()
	{
		return getListGStruct().data;
	}

  	/**
	 * get the next element
	 * Returns: the next element, or NULL if there are no more elements.
	 */ 
	ListG next()
	{
		return new ListG(getListGStruct().next);
	}

	/**
	 * get the previous element
	 * Returns: the previous element, or NULL if there are no more elements.
	 */ 
	ListG previous()
	{
		return new ListG(getListGStruct().prev);
	}
code: end
outFile: ListG

file: glib-Singly-Linked-Lists.html
struct: GSList
class: ListSG
prefix: g_slist_
structWrap: GSList* ListSG

code: start
  	/** */ 
	void* data()
	{
		return getListSGStruct().data;
	}

  	/**
	 * get the next element
	 * Returns: the next element, or NULL if there are no more elements.
	 */ 
	ListSG next()
	{
		return new ListSG(getListSGStruct().next);
	}
code: end
outFile: ListSG

file: glib-Double-ended-Queues.html
struct: GQueue
class: QueueG
prefix: g_queue_
structWrap: GQueue* QueueG
import: glib.ListG
structWrap: GList* ListG
outFile: QueueG

file: glib-Sequences.html
struct: GSequence
class: Sequence
prefix: g_sequence_
noprefix: g_sequence_iter_
structWrap: GSequence* Sequence
import: glib.SequenceIter
structWrap: GSequenceIter* SequenceIter
outFile: Sequence

struct: GSequenceIter
class: SequenceIter
prefix: g_sequence_iter_
strictPrefix: Y
import: glib.Sequence
structWrap: GSequence* Sequence
structWrap: GSequenceIter* SequenceIter
outFile: SequenceIter

file: glib-Trash-Stacks.html
struct: GTrashStack
class: TrashStack
prefix: g_trash_stack_
#structWrap: GTrashStack** TrashStack*
outFile: TrashStack

file: glib-Hash-Tables.html
struct: GHashTable
class: HashTable
prefix: g_hash_table_
noprefix: g_hash_table_iter_
structWrap: GHashTable* HashTable
import: glib.HashTableIter
structWrap: GHashTableIter* HashTableIter
import: glib.ListG
structWrap: GList* ListG
outFile: HashTable

struct: GHashTableIter
class: HashTableIter
prefix: g_hash_table_iter_
strictPrefix: Y
import: glib.HashTable
structWrap: GHashTable* HashTable
outFile: HashTableIter

file: glib-Strings.html
struct: GString
class: StringG
prefix: g_string_
structWrap: GString* StringG
import: glib.Str
outFile: StringG

file: glib-String-Chunks.html
struct: GStringChunk
class: StringGChunk
prefix: g_string_chunk_
import: glib.Str
outFile: StringGChunk

file: glib-Arrays.html
struct: GArray
class: ArrayG
prefix: g_array_
structWrap: GArray* ArrayG
import: glib.Str
outFile: ArrayG

file: glib-Pointer-Arrays.html
struct: GPtrArray
class: PtrArray
prefix: g_ptr_array_
structWrap: GPtrArray* PtrArray
outFile: PtrArray

file: glib-Byte-Arrays.html
struct: GByteArray
class: ByteArray
prefix: g_byte_array_
structWrap: GByteArray* ByteArray

array: g_byte_array_append data len
array: g_byte_array_prepend data len

outFile: ByteArray

file: glib-Balanced-Binary-Trees.html
struct: GTree
class: BBTree
prefix: g_tree_
structWrap: GTree* BBTree
outFile: BBTree

file: glib-N-ary-Trees.html
struct: GNode
class: Node
prefix: g_node_
structWrap: GNode* Node
outFile: Node

file: glib-Quarks.html
struct: GQuark
class: Quark
prefix: g_quark_
import: glib.Str
outFile: Quark

file: glib-Keyed-Data-Lists.html
struct: GData
class: DataList
prefix: g_datalist_
outFile: DataList

file: glib-Datasets.html
class: Dataset
prefix: g_dataset_
outFile: Dataset

file: glib-Relations-and-Tuples.html
struct: GRelation
class: Relation
prefix: g_relation_
noprefix: g_tuples_
import: glib.Tuples
structWrap: GTuples* Tuples

nocode: g_relation_print

code: start
	/**
	 * Outputs information about all records in a GRelation, as well as the indexes.
	 * It is for debugging.
	 */
	version(Tango)
	{
		public void print()
		{
			// void g_relation_print (GRelation *relation);
			g_relation_print(gRelation);
		}
	}
	else version(D_Version2)
	{
		public void print()
		{
			// void g_relation_print (GRelation *relation);
			g_relation_print(gRelation);
		}
	}
	else
	{
		public override void print()
		{
			// void g_relation_print (GRelation *relation);
			g_relation_print(gRelation);
		}
	}
code: end
outFile: Relation

struct: GTuples
class: Tuples
prefix: g_tuples_
strictPrefix: Yes
outFile: Tuples

file: glib-Caches.html
struct: GCache
class: Cache
prefix: g_cache_
outFile: Cache

file: glib-Memory-Allocators.html
struct: GAllocator
class: Allocator
prefix: g_allocator_
import: glib.Str
outFile: Allocator

file: glib-GVariantType.html
struct: GVariantType
class: VariantType
prefix: g_variant_type_
import: glib.Str
structWrap: GVariantType* VariantType
alias: string str

out: g_variant_type_string_scan endptr
array: g_variant_type_new_tuple items length

nocode: g_variant_type_new_maybe
code: start
	/**
	 * Constructs the type corresponding to a maybe instance containing
	 * type type or Nothing.
	 * It is appropriate to call g_variant_type_free() on the return value.
	 * Since 2.24
	 * Params:
	 * element = a GVariantType
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static VariantType newMaybe(VariantType element)
	{
		// GVariantType * g_variant_type_new_maybe (const GVariantType *element);
		auto p = g_variant_type_new_maybe((element is null) ? null : element.getVariantTypeStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_type_new_maybe((element is null) ? null : element.getVariantTypeStruct())");
		}
		return new VariantType(cast(GVariantType*) p);
	}
code: end
outFile: VariantType

file: glib-GVariant.html
struct: GVariant
class: Variant
prefix: g_variant_
noprefix: g_variant_iter_
noprefix: g_variant_builder_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.StringG
import: glib.VariantType
structWrap: GString* StringG
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
alias: byte b
nocode: g_variant_new_boolean
nocode: g_variant_new_bytestring_array
nocode: g_variant_new_object_path
nocode: g_variant_new_signature
nocode: g_variant_new_bytestring

array: g_variant_get_strv Return length
array: g_variant_dup_strv Return length
#array: g_variant_get_fixed_array Return n_elements
array: g_variant_new_tuple children n_children
array: g_variant_new_array children n_children
out: g_variant_get_string length
array: g_variant_dup_string Return length
array: g_variant_new_strv strv length
out: g_variant_new_va endptr
out: g_variant_get_va endptr
out: g_variant_parse endptr
array: g_variant_dup_bytestring Return length
array: g_variant_dup_bytestring_array Return length
array: g_variant_get_bytestring_array Return length

code: start
	/**
	 * Creates a new boolean GVariant instance -- either TRUE or FALSE.
	 * Since 2.24
	 * Params:
	 * boolean = a gboolean value
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool boolean)
	{
		// GVariant * g_variant_new_boolean (gboolean boolean);
		auto p = g_variant_new_boolean(boolean);
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_new_boolean(boolean)");
		}
		this(cast(GVariant*) p);
	}

	/**
	 * Creates a DBus object path GVariant with the contents of string.
	 * string must be a valid DBus object path.
	 * Use Variant.isObjectPath() if you're not sure.
	 * Since 2.24
	 *
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Variant fromObjectPath(string path)
	{
		auto p = g_variant_new_object_path(Str.toStringz(path));
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_new_object_path");
		}
		return new Variant(cast(GVariant*) p);
	}

	/**
	 * Creates a DBus type signature GVariant with the contents of string.
	 * string must be a valid DBus type signature.
	 * Use Variant.isSignature() if you're not sure.
	 * Since 2.24
	 *
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Variant fromSignature(string signature)
	{
		auto p = g_variant_new_signature(Str.toStringz(signature));
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_new_signature");
		}
		return new Variant(cast(GVariant*) p);
	}

	/**
	 * Creates an array-of-bytes GVariant with the contents of string.
	 * This function is just like new Variant(string) except that the string
	 * need not be valid utf8.
	 * 
	 * The nul terminator character at the end of the string is stored in
	 * the array.
	 *
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Variant fromByteString(string byteString)
	{
		auto p = g_variant_new_bytestring(Str.toStringz(byteString));
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_new_bytestring");
		}
		return new Variant(cast(GVariant*) p);
	}	

	/**
	 * Constructs an array of bytestring GVariant from the given array of
	 * strings. If length is -1 then strv is NULL-terminated.
	 * Since 2.26
	 * 
	 * Params:
	 *     strv   = an array of strings.
	 *     length = the length of strv, or -1
	 * 
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Variant fromByteStringArray(string[] strv)
	{
		// GVariant * g_variant_new_bytestring_array (const gchar * const *strv,  gssize length);
		auto p = g_variant_new_bytestring_array(Str.toStringzArray(strv), strv.length);
		if(p is null)
		{
			throw new ConstructionException("null returned by g_variant_new_bytestring_array(strv, length)");
		}
		return new Variant(cast(GVariant*) p);
	}
code: end
outFile: Variant

struct: GVariantIter
class: VariantIter
prefix: g_variant_iter_
strictPrefix: Yes
import: glib.Str
import: glib.Variant
structWrap: GVariant* Variant
structWrap: GVariantIter* VariantIter
outFile: VariantIter

struct: GVariantBuilder
class: VariantBuilder
prefix: g_variant_builder_
strictPrefix: Yes
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantBuilder* VariantBuilder
structWrap: GVariantType* VariantType
outFile: VariantBuilder

###########################################################
### GLib Tools ############################################
###########################################################
